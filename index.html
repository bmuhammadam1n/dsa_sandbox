<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DSA Sandbox Pro - Ultimate Algorithm Visualizer</title>
  <style>
    /* =============== GLOBAL STYLES =============== */
    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      background: #0f0f1a;
      color: #ddd;
      line-height: 1.6;
    }
    header {
      background: linear-gradient(135deg, #667eea, #764ba2);
      padding: 40px;
      text-align: center;
      color: white;
      position: relative;
    }
    .lang-bar {
      margin-top: 14px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .lang-btn {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: rgba(0, 0, 0, 0.25);
      color: white;
      font-weight: 700;
    }
    .lang-btn:hover {
      transform: translateY(-1px);
    }
    #global-search {
      width: 100%;
      max-width: 600px;
      padding: 12px 20px;
      border-radius: 50px;
      border: none;
      font-size: 16px;
      outline: none;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      margin-top: 15px;
    }
    #search-results {
      display: none;
      background: #1a1a2e;
      border-radius: 12px;
      margin-top: 8px;
      max-height: 300px;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      max-width: 600px;
      margin: 8px auto 0;
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
    }
    #search-results div {
      padding: 12px 16px;
      cursor: pointer;
      border-bottom: 1px solid #333;
      transition: background 0.2s;
    }
    #search-results div:hover {
      background: #252535;
    }
    nav {
      background: #1a1a2e;
      padding: 15px;
      overflow-x: auto;
      white-space: nowrap;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
    }
    nav a {
      color: #82d8ff;
      margin: 0 20px;
      text-decoration: none;
      font-weight: bold;
      font-size: 1.1em;
    }
    nav a:hover {
      color: #ff6bcb;
    }
    .container {
      max-width: 1200px;
      margin: 20px auto;
      padding: 20px;
    }
    .section {
      display: none;
      background: #16213e;
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
      margin-bottom: 30px;
    }
    .active {
      display: block;
    }
    h2 {
      color: #82d8ff;
      margin-top: 0;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
    }
    h3 {
      color: #82d8ff;
      margin-top: 25px;
    }
    .controls {
      margin: 15px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      background: #1a1a2e;
      padding: 15px;
      border-radius: 8px;
    }
    input,
    select,
    button {
      padding: 10px 14px;
      border-radius: 8px;
      border: none;
      font-size: 15px;
    }
    input,
    select {
      background: #0f1629;
      color: #a2e0a2;
    }
    button {
      background: #00d4aa;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    }
    button:hover {
      background: #00b893;
      transform: translateY(-2px);
    }
    canvas {
      display: block;
      margin: 20px auto;
      background: #0b1021;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
    }
    .info {
      margin-top: 10px;
      padding: 12px;
      background: #0004;
      border-radius: 8px;
      font-family: monospace;
      color: #0f0;
    }
    .details {
      margin: 20px 0;
      padding: 20px;
      background: #1a1a2e;
      border-radius: 12px;
      border-left: 4px solid #667eea;
    }
    .python-code {
      background: #0a0a14;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.4;
      color: #a2e0a2;
    }
    .python-code pre {
      margin: 0;
      white-space: pre-wrap;
    }
    .code-header {
      background: #333;
      color: #82d8ff;
      padding: 10px;
      border-radius: 6px 6px 0 0;
      font-weight: bold;
      text-align: center;
    }

    /* =============== LINKED LIST SANDBOX MODE STYLES =============== */
    :root{
      --bg:#0f0f1a;
      --panel:#16162a;
      --panel2:#0d0d18;
      --border:#2a2a44;
      --border2:#3a3a66;
      --text:#ddd;
      --muted:rgba(221,221,221,.75);
      --good:#2a7a4a;
      --bad:#7a2a2a;
      --accent:#82d8ff;
      --accent2:#ff6bcb;
      --warn:#f5d06f;
    }
    #linkedlist .wrap{max-width:1280px;margin:0 auto;padding:18px}
    #linkedlist .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      padding:16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      margin-bottom:16px;
    }
    #linkedlist .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    #linkedlist .row + .row{margin-top:12px}
    #linkedlist label{font-size:.95rem;opacity:.95}
    #linkedlist input, #linkedlist select, #linkedlist button{
      background:#101022;
      border:1px solid var(--border);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      outline:none;
      font-size:14px;
    }
    #linkedlist input{min-width:190px}
    #linkedlist input[type="number"]{min-width:110px;width:110px}
    #linkedlist button{
      cursor:pointer;
      border:1px solid var(--border2);
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    #linkedlist button:hover{background:#1b1b33}
    #linkedlist button:active{transform:scale(.98)}
    #linkedlist button.good{border-color:rgba(42,122,74,.85)}
    #linkedlist button.bad{border-color:rgba(122,42,42,.9)}
    #linkedlist button.accent{border-color:rgba(130,216,255,.8)}
    #linkedlist button.warn{border-color:rgba(245,208,111,.85)}
    #linkedlist button:disabled, #linkedlist input:disabled, #linkedlist select:disabled{
      opacity:.55;
      cursor:not-allowed;
    }
    #linkedlist .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      background:#1a1a2e;
      border:1px solid var(--border);
      font-size:12px;
      opacity:.95;
      white-space:nowrap;
    }
    #linkedlist .canvas{
      overflow:auto;
      background:var(--panel2);
      border:1px dashed var(--border);
      border-radius:16px;
      padding:18px;
      min-height:180px;
    }
    #linkedlist .list{
      display:flex;
      align-items:center;
      gap:14px;
      min-width:max-content;
      padding:8px 6px;
    }
    #linkedlist .node{
      width:110px;
      min-height:76px;
      border-radius:16px;
      border:1px solid var(--border2);
      background: linear-gradient(180deg,#1b1b34,#121225);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      position:relative;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      padding:8px 10px;
      gap:2px;
    }
    #linkedlist .node .top{
      display:flex;
      align-items:center;
      gap:6px;
      margin-bottom:2px;
    }
    #linkedlist .badge{
      font-size:10px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#101022;
      opacity:.95;
    }
    #linkedlist .badge.head{border-color:rgba(130,216,255,.9)}
    #linkedlist .badge.tail{border-color:rgba(255,107,203,.85)}
    #linkedlist .node .val{font-size:20px;font-weight:800;line-height:1}
    #linkedlist .node .id{font-size:11px;opacity:.8}
    #linkedlist .node .ptr{
      margin-top:4px;
      font-size:11px;
      opacity:.85;
      line-height:1.2;
      text-align:center;
      white-space:nowrap;
    }
    #linkedlist .node.active{
      border-color:var(--accent);
      box-shadow: 0 0 0 3px rgba(130,216,255,.16), 0 12px 28px rgba(0,0,0,.35);
    }
    #linkedlist .node.found{
      border-color:rgba(42,122,74,.95);
      box-shadow: 0 0 0 3px rgba(42,122,74,.18), 0 12px 28px rgba(0,0,0,.35);
    }
    #linkedlist .node.checked{
      border-color:rgba(245,208,111,.85);
      box-shadow: 0 0 0 3px rgba(245,208,111,.12), 0 12px 28px rgba(0,0,0,.35);
    }
    #linkedlist .arrow{
      font-size:22px;
      opacity:.9;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:2px;
      min-width:22px;
    }
    #linkedlist .arrow .back{font-size:18px;opacity:.72}
    #linkedlist .loop{
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:2px;
      padding:6px 10px;
      border-radius:14px;
      border:1px solid var(--border);
      background:#101022;
      opacity:.92;
      margin-left:6px;
    }
    #linkedlist .loop .t{font-size:12px;opacity:.85}
    #linkedlist .hint{
      opacity:.82;
      font-size:.92rem;
      line-height:1.45;
    }
    #linkedlist .status{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--border);
      background:var(--panel2);
      font-size:13px;
      opacity:.95;
      min-height:44px;
      display:flex;
      align-items:center;
    }
    #linkedlist .log{
      max-height:170px;
      overflow:auto;
      padding:10px;
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:14px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:13px;
      line-height:1.45;
    }
    #linkedlist .log div{padding:2px 0;opacity:.95}
    #linkedlist .split{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 920px){
      #linkedlist .split{grid-template-columns: 1fr}
    }
    #linkedlist .rangeWrap{
      display:flex; align-items:center; gap:10px;
      padding:8px 10px;
      border:1px solid var(--border);
      background:#101022;
      border-radius:12px;
    }
    #linkedlist input[type="range"]{width:160px}
    #linkedlist .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}
  </style>
</head>
<body>
  <!-- ====================== HEADER & NAV ====================== -->
  <header>
    <h1 data-i18n="title">DSA Sandbox Pro</h1>
    <p data-i18n="subtitle">Interactive ‚Ä¢ Beautiful ‚Ä¢ Fully Visual Algorithm Playground</p>
    <div class="lang-bar">
      <button class="lang-btn" onclick="setLang('en')">EN</button>
      <button class="lang-btn" onclick="setLang('uz')">UZ</button>
    </div>
    <input type="text" id="global-search" data-i18n-ph="ph_search" placeholder="üîç Search DSA topics...">
    <div id="search-results"></div>
  </header>

  <nav>
    <a href="#" onclick="show('arrays')" data-i18n="nav_arrays">Arrays</a>
    <a href="#" onclick="show('sorting')" data-i18n="nav_sorting">Sorting</a>
    <a href="#" onclick="show('searching')" data-i18n="nav_searching">Searching</a>
    <a href="#" onclick="show('bt')" data-i18n="nav_bt">Binary Tree</a>
    <a href="#" onclick="show('bst')" data-i18n="nav_bst">BST</a>
    <a href="#" onclick="show('avl')" data-i18n="nav_avl">AVL Tree</a>
    <a href="#" onclick="show('trie')" data-i18n="nav_trie">Trie</a>
    <a href="#" onclick="show('heaps')" data-i18n="nav_heaps">Heaps & Heap Sort</a>
    <a href="#" onclick="show('graphs')" data-i18n="nav_graphs">Graphs</a>
    <a href="#" onclick="show('bellman')" data-i18n="nav_bellman">Bellman-Ford</a>
    <a href="#" onclick="show('dijkstra')" data-i18n="nav_dijkstra">Dijkstra</a>
    <a href="#" onclick="show('astar')" data-i18n="nav_astar">A*</a>
    <a href="#" onclick="show('recursion')" data-i18n="nav_recursion">Recursion</a>
    <a href="#" onclick="show('linkedlist')" data-i18n="nav_linkedlist">Linked List</a>
    <a href="#" onclick="show('hashtable')" data-i18n="nav_hashtable">Hash Table</a>
    <a href="#" onclick="show('toposort')" data-i18n="nav_toposort">Topo Sort</a>
    <a href="#" onclick="show('kruskal')" data-i18n="nav_kruskal">Kruskal's</a>
    <a href="#" onclick="show('floyd')" data-i18n="nav_floyd">Floyd-Warshall</a>
    <a href="#" onclick="show('sliding')" data-i18n="nav_sliding">Sliding Window</a>
    <a href="#" onclick="show('time-complexity')" data-i18n="nav_time_complexity">Time Complexity</a>
    <a href="#" onclick="show('space-complexity')" data-i18n="nav_space_complexity">Space Complexity</a>
    <a href="#" onclick="show('complexity')" data-i18n="nav_complexity">Complexity Race</a>
    <a href="#" onclick="show('rotting')" data-i18n="nav_rotting">Rotting Oranges</a>
    <a href="#" onclick="show('advanced-sorting')" data-i18n="nav_advanced_sorting">Advanced Sorting</a>
    <a href="#" onclick="show('string-algos')" data-i18n="nav_string_algos">String Algorithms</a>
    <a href="#" onclick="show('dp-algos')" data-i18n="nav_dp_algos">Dynamic Programming</a>
    <button onclick="if(confirm(T('confirm_reset'))) location.reload();"
      style="background:#ff6b6b;color:white;border:none;padding:8px 12px;border-radius:6px;margin-left:15px;cursor:pointer;font-weight:bold;"
      data-i18n="btn_reset_all">Reset All</button>
  </nav>

  <div class="container">

    
<!-- =============== DYNAMIC PROGRAMMING SECTION =============== -->
<div id="dp-algos" class="section">
  <h2 data-i18n="dp_algos_title">Dynamic Programming Algorithms</h2>
  
  <!-- ===== ALGORITHM SELECTION & INPUTS ===== -->
  <div class="panel" style="margin-bottom:20px;">
    <div class="row" style="flex-wrap:wrap; gap:15px;">
      <label><strong data-i18n="select_algorithm">Select Algorithm:</strong></label>
      <select id="dp-algo" style="flex:1; min-width:200px;">
        <option value="knapsack">0/1 Knapsack</option>
        <option value="lcs">Longest Common Subsequence (LCS)</option>
        <option value="matrix-chain">Matrix Chain Multiplication</option>
      </select>
      
      <button id="run-dp-algo" class="accent" style="padding:10px 24px; font-size:16px;">
        <span data-i18n="btn_run_dp">Run Algorithm</span>
      </button>
      <button id="random-dp" style="padding:10px 24px; background:#6a5acd; border-color:#7a6add;">
        <span data-i18n="btn_random_data">Random Data</span>
      </button>
    </div>
    
    <!-- Knapsack Inputs -->
    <div id="knapsack-inputs" class="row" style="margin-top:15px; flex-wrap:wrap; gap:15px; display:none;">
      <div style="flex:2; min-width:300px;">
        <label><strong data-i18n="weights_input">Weights:</strong></label>
        <input type="text" id="weights-input" placeholder="e.g., 10,20,30" style="width:100%; padding:10px; font-size:16px;">
      </div>
      <div style="flex:2; min-width:300px;">
        <label><strong data-i18n="values_input">Values:</strong></label>
        <input type="text" id="values-input" placeholder="e.g., 60,100,120" style="width:100%; padding:10px; font-size:16px;">
      </div>
      <div style="flex:1; min-width:150px;">
        <label><strong data-i18n="capacity_input">Capacity:</strong></label>
        <input type="number" id="capacity-input" placeholder="e.g., 50" style="width:100%; padding:10px; font-size:16px;">
      </div>
    </div>
    
    <!-- LCS Inputs -->
    <div id="lcs-inputs" class="row" style="margin-top:15px; flex-wrap:wrap; gap:15px; display:none;">
      <div style="flex:2; min-width:300px;">
        <label><strong data-i18n="string1_input">String 1:</strong></label>
        <input type="text" id="string1-input" placeholder="e.g., ABCBDAB" style="width:100%; padding:10px; font-size:16px;">
      </div>
      <div style="flex:2; min-width:300px;">
        <label><strong data-i18n="string2_input">String 2:</strong></label>
        <input type="text" id="string2-input" placeholder="e.g., BDCABA" style="width:100%; padding:10px; font-size:16px;">
      </div>
    </div>
    
    <!-- Matrix Chain Inputs -->
    <div id="matrix-inputs" class="row" style="margin-top:15px; flex-wrap:wrap; gap:15px; display:none;">
      <div style="flex:1; min-width:300px;">
        <label><strong data-i18n="dimensions_input">Matrix Dimensions:</strong></label>
        <input type="text" id="dimensions-input" placeholder="e.g., 10,30,5,60" style="width:100%; padding:10px; font-size:16px;">
        <div style="margin-top:5px; font-size:12px; opacity:0.8;" data-i18n="matrix_help">For n matrices, provide n+1 dimensions</div>
      </div>
    </div>
  </div>

  <!-- ===== DETAILS & PYTHON CODE ===== -->
  <div class="details">
    <h3 data-i18n="details_heading">Algorithm Details</h3>
    <p id="dp-desc">
      <!-- Dynamically updated based on selected algorithm -->
    </p>
    
    <div class="python-code" style="margin-top:15px;">
      <div class="code-header" data-i18n="py_heading">Python Implementation</div>
      <pre id="dp-python-code"></pre>
    </div>
    
    <div class="row" style="margin-top:15px; padding:12px; background:#1a1a2e; border-radius:8px;">
      <div style="display:flex; flex-wrap:wrap; gap:20px; flex:1;">
        <div>
          <strong data-i18n="time_complexity_label">Time Complexity:</strong>
          <div id="time-complexity-dp" style="margin-top:5px; font-family:monospace;"></div>
        </div>
        <div>
          <strong data-i18n="space_complexity_label">Space Complexity:</strong>
          <div id="space-complexity-dp" style="margin-top:5px; font-family:monospace;"></div>
        </div>
        <div>
          <strong data-i18n="best_for">Best For:</strong>
          <div id="best-for-dp" style="margin-top:5px; font-family:monospace;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ===== VISUALIZATION CANVAS ===== -->
  <div class="panel" style="margin-top:20px;">
    <div id="dp-canvas-container" style="overflow:auto; background:#0b1021; border-radius:12px; padding:15px; min-height:300px;">
      <!-- Visualization will be rendered here -->
    </div>
  </div>

  <!-- ===== RESULTS & FEEDBACK ===== -->
  <div class="panel" style="margin-top:20px;">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <h3 style="margin:0;" data-i18n="result_heading">Result</h3>
      <div id="dp-status" style="font-weight:bold; padding:8px 16px; border-radius:8px;"></div>
    </div>
    <div id="dp-result" style="margin-top:15px; padding:15px; background:#1a1a2e; border-radius:8px; min-height:60px; font-size:18px; font-family:monospace;"></div>
  </div>

  <!-- ===== INSTRUCTIONS ===== -->
  <div class="panel" style="margin-top:20px; background:#16213e; border-left:4px solid #f5d06f;">
    <h3 style="margin:0 0 15px 0; color:#f5d06f;" data-i18n="instructions">How to Use</h3>
    <ol style="padding-left:20px; line-height:1.6;">
      <li data-i18n="dp_instr1">Select an algorithm from the dropdown</li>
      <li data-i18n="dp_instr2">Enter required inputs or use "Random Data"</li>
      <li data-i18n="dp_instr3">Click "Run Algorithm" to see step-by-step DP table construction</li>
      <li data-i18n="dp_instr4">Green cells = optimal solution path, Blue = current computation</li>
    </ol>
  </div>
</div>

<script>
// ====================== DYNAMIC PROGRAMMING SANDBOX ======================
(() => {
  const container = document.getElementById('dp-algos');
  if (!container) return;

  // State
  let isAnimating = false;
  let animationSpeed = 400;

  // DOM Elements
  const algoSelect = container.querySelector('#dp-algo');
  const runBtn = container.querySelector('#run-dp-algo');
  const randomBtn = container.querySelector('#random-dp');
  const canvasContainer = container.querySelector('#dp-canvas-container');
  const descDiv = container.querySelector('#dp-desc');
  const codeDiv = container.querySelector('#dp-python-code');
  const timeComplexityDiv = container.querySelector('#time-complexity-dp');
  const spaceComplexityDiv = container.querySelector('#space-complexity-dp');
  const bestForDiv = container.querySelector('#best-for-dp');
  const statusDiv = container.querySelector('#dp-status');
  const resultDiv = container.querySelector('#dp-result');

  // Input elements
  const weightsInput = container.querySelector('#weights-input');
  const valuesInput = container.querySelector('#values-input');
  const capacityInput = container.querySelector('#capacity-input');
  const string1Input = container.querySelector('#string1-input');
  const string2Input = container.querySelector('#string2-input');
  const dimensionsInput = container.querySelector('#dimensions-input');

  // Input containers
  const knapsackInputs = container.querySelector('#knapsack-inputs');
  const lcsInputs = container.querySelector('#lcs-inputs');
  const matrixInputs = container.querySelector('#matrix-inputs');

  // Algorithm configurations
  const algorithms = {
    en: {
      knapsack: {
        name: "0/1 Knapsack",
        desc: "The 0/1 Knapsack problem involves selecting items with given weights and values to maximize total value without exceeding a weight capacity. Each item can be taken at most once (0/1). It's solved using dynamic programming by building a 2D table where dp[i][w] represents the maximum value achievable with the first i items and weight limit w.",
        python: `def knapsack(weights, values, capacity):
    n = len(weights)
    # Create DP table
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]
    
    # Fill DP table
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                # Include or exclude current item
                dp[i][w] = max(
                    values[i-1] + dp[i-1][w - weights[i-1]],
                    dp[i-1][w]
                )
            else:
                # Cannot include current item
                dp[i][w] = dp[i-1][w]
    
    # Backtrack to find selected items
    selected = []
    w = capacity
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i-1][w]:
            selected.append(i-1)
            w -= weights[i-1]
    
    return dp[n][capacity], selected[::-1]`,
        time: "O(n √ó W)",
        space: "O(n √ó W)",
        bestFor: "Resource allocation, portfolio optimization"
      },
      lcs: {
        name: "Longest Common Subsequence (LCS)",
        desc: "LCS finds the longest subsequence common to two sequences. A subsequence maintains relative order but not necessarily continuity. It's used in diff utilities, bioinformatics (DNA sequence alignment), and version control systems. The DP approach builds a 2D table where dp[i][j] represents the LCS length of the first i characters of string1 and first j characters of string2.",
        python: `def lcs_length(str1, str2):
    m, n = len(str1), len(str2)
    # Create DP table
    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
    
    # Fill DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

def lcs_string(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
    
    # Fill DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # Backtrack to construct LCS string
    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs.append(str1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    return ''.join(reversed(lcs))`,
        time: "O(m √ó n)",
        space: "O(m √ó n)",
        bestFor: "Diff tools, DNA sequence alignment, plagiarism detection"
      },
      'matrix-chain': {
        name: "Matrix Chain Multiplication",
        desc: "Matrix Chain Multiplication finds the optimal way to parenthesize matrix multiplication to minimize scalar multiplications. Given matrices A‚ÇÅ, A‚ÇÇ, ..., A‚Çô with dimensions p‚ÇÄ√óp‚ÇÅ, p‚ÇÅ√óp‚ÇÇ, ..., p‚Çô‚Çã‚ÇÅ√óp‚Çô, the goal is to find the multiplication order that minimizes operations. The DP solution uses a 2D table where m[i][j] stores the minimum cost to multiply matrices from i to j.",
        python: `def matrix_chain_order(dimensions):
    n = len(dimensions) - 1  # Number of matrices
    # m[i][j] = minimum scalar multiplications needed
    m = [[0 for _ in range(n)] for _ in range(n)]
    # s[i][j] = split point for optimal parenthesization
    s = [[0 for _ in range(n)] for _ in range(n)]
    
    # L is chain length
    for L in range(2, n + 1):
        for i in range(n - L + 1):
            j = i + L - 1
            m[i][j] = float('inf')
            
            for k in range(i, j):
                # Cost = cost of left + cost of right + cost of multiplication
                cost = m[i][k] + m[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1]
                
                if cost < m[i][j]:
                    m[i][j] = cost
                    s[i][j] = k
    
    return m[0][n-1], s

def print_optimal_parens(s, i, j):
    if i == j:
        return f"A{i+1}"
    else:
        k = s[i][j]
        left = print_optimal_parens(s, i, k)
        right = print_optimal_parens(s, k+1, j)
        return f"({left} √ó {right})"`,
        time: "O(n¬≥)",
        space: "O(n¬≤)",
        bestFor: "Optimizing matrix multiplication sequences, compiler design"
      }
    },
    uz: {
      knapsack: {
        name: "0/1 Rucksak",
        desc: "0/1 Rucksak muammosi berilgan og'irlik va qiymatlarga ega bo'lgan buyumlarni tanlash orqali og'irlik sig'imini oshirmasdan umumiy qiymatni maksimal darajada oshirishni nazarda tutadi. Har bir buyumni eng ko'pi bilan bir marta (0/1) olish mumkin. Bu dinamik dasturlash yordamida hal qilinadi, bu yerda dp[i][w] birinchi i ta buyum va w og'irlik chegarasi bilan erishish mumkin bo'lgan maksimal qiymatni ifodalaydi.",
        python: `def knapsack(weights, values, capacity):
    n = len(weights)
    # DP jadvalini yaratish
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]
    
    # DP jadvalini to'ldirish
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                # Joriy buyumni kiritish yoki chiqarish
                dp[i][w] = max(
                    values[i-1] + dp[i-1][w - weights[i-1]],
                    dp[i-1][w]
                )
            else:
                # Joriy buyumni kiritib bo'lmaydi
                dp[i][w] = dp[i-1][w]
    
    # Tanlangan buyumlarni topish uchun orqaga qaytish
    selected = []
    w = capacity
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i-1][w]:
            selected.append(i-1)
            w -= weights[i-1]
    
    return dp[n][capacity], selected[::-1]`,
        time: "O(n √ó W)",
        space: "O(n √ó W)",
        bestFor: "Resurs taqsimoti, portfel optimallashtirish"
      },
      lcs: {
        name: "Eng Uzun Umumiy Ostki Ketma-ketlik (LCS)",
        desc: "LCS ikkita ketma-ketlik uchun umumiy eng uzun ostki ketma-ketlikni topadi. Ostki ketma-ketlik nisbiy tartibni saqlaydi, lekin doimiy bo'lishi shart emas. U diff utilitalari, bioinformatika (DNK ketma-ketligini tekshirish) va versiya nazorati tizimlarida ishlatiladi. DP yondashuvi 2D jadval quradi, bu yerda dp[i][j] string1 ning birinchi i ta belgisi va string2 ning birinchi j ta belgisi uchun LCS uzunligini ifodalaydi.",
        python: `def lcs_length(str1, str2):
    m, n = len(str1), len(str2)
    # DP jadvalini yaratish
    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
    
    # DP jadvalini to'ldirish
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

def lcs_string(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
    
    # DP jadvalini to'ldirish
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # LCS satrini qurish uchun orqaga qaytish
    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs.append(str1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    return ''.join(reversed(lcs))`,
        time: "O(m √ó n)",
        space: "O(m √ó n)",
        bestFor: "Farqlash vositalari, DNK ketma-ketligini tekshirish, plagiatni aniqlash"
      },
      'matrix-chain': {
        name: "Matritsa Zanjiri Ko'paytirish",
        desc: "Matritsa zanjiri ko'paytirishi matritsalarni ko'paytirishning optimal usulini topish orqali skalar ko'paytirishlarni minimal darajada kamaytirishni nazarda tutadi. A‚ÇÅ, A‚ÇÇ, ..., A‚Çô matritsalari p‚ÇÄ√óp‚ÇÅ, p‚ÇÅ√óp‚ÇÇ, ..., p‚Çô‚Çã‚ÇÅ√óp‚Çô o'lchamlariga ega bo'lsa, maqsad operatsiyalarni minimallashtiruvchi ko'paytirish tartibini topishdir. DP yechimi 2D jadvaldan foydalanadi, bu yerda m[i][j] i dan j gacha bo'lgan matritsalarni ko'paytirishning minimal xarajatini saqlaydi.",
        python: `def matrix_chain_order(dimensions):
    n = len(dimensions) - 1  # Matritsalar soni
    # m[i][j] = kerakli minimal skalar ko'paytirishlar
    m = [[0 for _ in range(n)] for _ in range(n)]
    # s[i][j] = optimal qavslash uchun bo'linish nuqtasi
    s = [[0 for _ in range(n)] for _ in range(n)]
    
    # L - zanjir uzunligi
    for L in range(2, n + 1):
        for i in range(n - L + 1):
            j = i + L - 1
            m[i][j] = float('inf')
            
            for k in range(i, j):
                # Xarajat = chap xarajat + o'ng xarajat + ko'paytirish xarajati
                cost = m[i][k] + m[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1]
                
                if cost < m[i][j]:
                    m[i][j] = cost
                    s[i][j] = k
    
    return m[0][n-1], s

def print_optimal_parens(s, i, j):
    if i == j:
        return f"A{i+1}"
    else:
        k = s[i][j]
        left = print_optimal_parens(s, i, k)
        right = print_optimal_parens(s, k+1, j)
        return f"({left} √ó {right})"`,
        time: "O(n¬≥)",
        space: "O(n¬≤)",
        bestFor: "Matritsa ko'paytirish ketma-ketligini optimallashtirish, kompilyator dizayni"
      }
    }
  };

  // Show/hide input fields based on selected algorithm
  const updateInputFields = () => {
    const algo = algoSelect.value;
    knapsackInputs.style.display = algo === 'knapsack' ? 'flex' : 'none';
    lcsInputs.style.display = algo === 'lcs' ? 'flex' : 'none';
    matrixInputs.style.display = algo === 'matrix-chain' ? 'flex' : 'none';
  };

  // Update UI based on selected algorithm
  const updateAlgorithmUI = () => {
    const algo = algoSelect.value;
    const lang = localStorage.getItem('app-lang') || 'en';
    const config = algorithms[lang][algo] || algorithms.en[algo];
    
    descDiv.textContent = config.desc;
    codeDiv.textContent = config.python;
    timeComplexityDiv.textContent = config.time;
    spaceComplexityDiv.textContent = config.space;
    bestForDiv.textContent = config.bestFor;
    updateInputFields();
  };

  // Render DP table visualization
  const renderDPTable = (table, headers = null, highlights = {}) => {
    if (!table || table.length === 0) {
      canvasContainer.innerHTML = '<div style="text-align:center; color:#888; padding:50px;">No table to display</div>';
      return;
    }
    
    let html = '<div style="overflow:auto; max-height:500px;">';
    html += '<table style="border-collapse:collapse; margin:0 auto; background:#1a1a2e;">';
    
    // Add header row if provided
    if (headers && headers.row) {
      html += '<thead><tr><th style="border:1px solid #444; padding:8px; background:#2a2a3a;"></th>';
      headers.row.forEach(header => {
        html += `<th style="border:1px solid #444; padding:8px; background:#2a2a3a;">${header}</th>`;
      });
      html += '</tr></thead>';
    }
    
    // Add table body
    html += '<tbody>';
    table.forEach((row, i) => {
      html += '<tr>';
      
      // Add column header if provided
      if (headers && headers.col && headers.col[i] !== undefined) {
        html += `<td style="border:1px solid #444; padding:8px; background:#2a2a3a; font-weight:bold;">${headers.col[i]}</td>`;
      }
      
      row.forEach((cell, j) => {
        let bgColor = '#1a1a2e';
        let color = 'white';
        
        // Highlight optimal path
        if (highlights.path && highlights.path.some(([x, y]) => x === i && y === j)) {
          bgColor = '#00c853'; // Green for optimal path
          color = 'black';
        }
        // Highlight current cell being computed
        else if (highlights.current && highlights.current[0] === i && highlights.current[1] === j) {
          bgColor = '#4fc3f7'; // Blue for current computation
          color = 'black';
        }
        
        html += `<td style="border:1px solid #444; padding:8px; background:${bgColor}; color:${color}; min-width:40px; text-align:center;">${cell}</td>`;
      });
      html += '</tr>';
    });
    html += '</tbody></table></div>';
    
    canvasContainer.innerHTML = html;
  };

  // Sleep helper
  const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  // Knapsack simulation
  const simulateKnapsack = async (weights, values, capacity) => {
    const n = weights.length;
    const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));
    
    // Initialize base cases (already 0)
    
    // Fill DP table with visualization
    for (let i = 1; i <= n; i++) {
      for (let w = 0; w <= capacity; w++) {
        if (weights[i-1] <= w) {
          dp[i][w] = Math.max(
            values[i-1] + dp[i-1][w - weights[i-1]],
            dp[i-1][w]
          );
        } else {
          dp[i][w] = dp[i-1][w];
        }
        
        // Visualize current state
        const headers = {
          row: Array.from({length: capacity + 1}, (_, i) => i),
          col: Array.from({length: n + 1}, (_, i) => i === 0 ? '0' : `Item ${i}`)
        };
        const highlights = {
          current: [i, w]
        };
        renderDPTable(dp, headers, highlights);
        await sleep(animationSpeed / 2);
      }
    }
    
    // Backtrack to find selected items
    const selected = [];
    let w = capacity;
    const path = [];
    
    for (let i = n; i > 0; i--) {
      if (dp[i][w] !== dp[i-1][w]) {
        selected.push(i-1);
        path.push([i, w]);
        w -= weights[i-1];
      }
      path.push([i-1, w]);
    }
    
    // Final visualization with optimal path
    const finalHighlights = { path };
    renderDPTable(dp, headers, finalHighlights);
    await sleep(animationSpeed);
    
    return { maxValue: dp[n][capacity], selectedItems: selected.reverse(), dpTable: dp };
  };

  // LCS simulation
  const simulateLCS = async (str1, str2) => {
    const m = str1.length;
    const n = str2.length;
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // Fill DP table with visualization
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        if (str1[i-1] === str2[j-1]) {
          dp[i][j] = dp[i-1][j-1] + 1;
        } else {
          dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
        }
        
        // Visualize current state
        const headers = {
          row: [''].concat(str2.split('')),
          col: [''].concat(str1.split(''))
        };
        const highlights = {
          current: [i, j]
        };
        renderDPTable(dp, headers, highlights);
        await sleep(animationSpeed / 2);
      }
    }
    
    // Backtrack to construct LCS string
    const lcs = [];
    const path = [];
    let i = m, j = n;
    
    while (i > 0 && j > 0) {
      path.push([i, j]);
      if (str1[i-1] === str2[j-1]) {
        lcs.push(str1[i-1]);
        i--;
        j--;
      } else if (dp[i-1][j] > dp[i][j-1]) {
        i--;
      } else {
        j--;
      }
    }
    path.push([i, j]);
    
    // Final visualization with optimal path
    const finalHighlights = { path };
    renderDPTable(dp, headers, finalHighlights);
    await sleep(animationSpeed);
    
    return { lcsLength: dp[m][n], lcsString: lcs.reverse().join(''), dpTable: dp };
  };

  // Matrix Chain simulation
  const simulateMatrixChain = async (dimensions) => {
    const n = dimensions.length - 1; // Number of matrices
    const m = Array(n).fill().map(() => Array(n).fill(0));
    const s = Array(n).fill().map(() => Array(n).fill(0));
    
    // Fill DP table for chain lengths 2 to n
    for (let L = 2; L <= n; L++) {
      for (let i = 0; i <= n - L; i++) {
        const j = i + L - 1;
        m[i][j] = Infinity;
        
        for (let k = i; k < j; k++) {
          const cost = m[i][k] + m[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1];
          
          if (cost < m[i][j]) {
            m[i][j] = cost;
            s[i][j] = k;
          }
          
          // Visualize current state
          const headers = {
            row: Array.from({length: n}, (_, i) => `A${i+1}`),
            col: Array.from({length: n}, (_, i) => `A${i+1}`)
          };
          const highlights = {
            current: [i, j]
          };
          renderDPTable(m, headers, highlights);
          await sleep(animationSpeed / 3);
        }
      }
    }
    
    // Construct optimal parenthesization
    const constructParens = (s, i, j) => {
      if (i === j) {
        return `A${i+1}`;
      } else {
        const k = s[i][j];
        const left = constructParens(s, i, k);
        const right = constructParens(s, k+1, j);
        return `(${left} √ó ${right})`;
      }
    };
    
    const optimalParens = constructParens(s, 0, n-1);
    
    // Final visualization
    renderDPTable(m, headers);
    await sleep(animationSpeed);
    
    return { minCost: m[0][n-1], optimalParens, costTable: m, splitTable: s };
  };

  // Run DP algorithm
  const runDPAlgorithm = async () => {
    if (isAnimating) return;
    isAnimating = true;
    runBtn.disabled = true;
    
    try {
      const algo = algoSelect.value;
      let result;
      
      if (algo === 'knapsack') {
        const weights = weightsInput.value.split(',').map(w => parseInt(w.trim())).filter(w => !isNaN(w));
        const values = valuesInput.value.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));
        const capacity = parseInt(capacityInput.value);
        
        if (weights.length === 0 || values.length === 0 || isNaN(capacity) || capacity <= 0) {
          throw new Error("Invalid inputs for Knapsack");
        }
        
        if (weights.length !== values.length) {
          throw new Error("Weights and values must have same length");
        }
        
        result = await simulateKnapsack(weights, values, capacity);
        resultDiv.innerHTML = `
          <div>Maximum Value: <span style="color:#00c853">${result.maxValue}</span></div>
          <div>Selected Items (0-indexed): <span style="color:#ffab00">[${result.selectedItems.join(', ')}]</span></div>
          <div>Weights: [${weights.join(', ')}]</div>
          <div>Values: [${values.join(', ')}]</div>
        `;
        
      } else if (algo === 'lcs') {
        const str1 = string1Input.value.trim();
        const str2 = string2Input.value.trim();
        
        if (!str1 || !str2) {
          throw new Error("Both strings must be non-empty");
        }
        
        result = await simulateLCS(str1, str2);
        resultDiv.innerHTML = `
          <div>LCS Length: <span style="color:#00c853">${result.lcsLength}</span></div>
          <div>LCS String: <span style="color:#ffab00">"${result.lcsString}"</span></div>
          <div>String 1: "${str1}"</div>
          <div>String 2: "${str2}"</div>
        `;
        
      } else if (algo === 'matrix-chain') {
        const dimensions = dimensionsInput.value.split(',').map(d => parseInt(d.trim())).filter(d => !isNaN(d));
        
        if (dimensions.length < 2) {
          throw new Error("At least 2 dimensions required");
        }
        
        if (dimensions.some(d => d <= 0)) {
          throw new Error("All dimensions must be positive");
        }
        
        result = await simulateMatrixChain(dimensions);
        resultDiv.innerHTML = `
          <div>Minimum Scalar Multiplications: <span style="color:#00c853">${result.minCost}</span></div>
          <div>Optimal Parenthesization: <span style="color:#ffab00">${result.optimalParens}</span></div>
          <div>Dimensions: [${dimensions.join(', ')}]</div>
        `;
      }
      
      statusDiv.textContent = '‚úÖ Algorithm completed successfully!';
      statusDiv.style.backgroundColor = 'rgba(0, 200, 83, 0.2)';
      
    } catch (error) {
      statusDiv.textContent = '‚ùå Error during execution';
      statusDiv.style.backgroundColor = 'rgba(255, 82, 82, 0.2)';
      resultDiv.innerHTML = `<span style="color:#ff5252">${error.message}</span>`;
    }
    
    isAnimating = false;
    runBtn.disabled = false;
  };

  // Generate random data
  const generateRandomData = () => {
    const algo = algoSelect.value;
    
    if (algo === 'knapsack') {
      const n = Math.floor(Math.random() * 5) + 3; // 3-7 items
      const weights = Array.from({length: n}, () => Math.floor(Math.random() * 30) + 10);
      const values = Array.from({length: n}, () => Math.floor(Math.random() * 100) + 50);
      const capacity = Math.floor(Math.random() * 100) + 50;
      
      weightsInput.value = weights.join(', ');
      valuesInput.value = values.join(', ');
      capacityInput.value = capacity.toString();
      
    } else if (algo === 'lcs') {
      const strings = [
        ["ABCDGH", "AEDFHR"],
        ["AGGTAB", "GXTXAYB"],
        ["ABCBDAB", "BDCABA"],
        ["XMJYAUZ", "MZJAWXU"],
        ["BANANA", "ATANA"]
      ];
      const randomPair = strings[Math.floor(Math.random() * strings.length)];
      string1Input.value = randomPair[0];
      string2Input.value = randomPair[1];
      
    } else if (algo === 'matrix-chain') {
      const n = Math.floor(Math.random() * 4) + 3; // 3-6 matrices
      const dimensions = Array.from({length: n + 1}, () => Math.floor(Math.random() * 30) + 10);
      dimensionsInput.value = dimensions.join(', ');
    }
  };

  // Event Listeners
  algoSelect.addEventListener('change', updateAlgorithmUI);
  runBtn.addEventListener('click', runDPAlgorithm);
  randomBtn.addEventListener('click', generateRandomData);

  // Initialize
  updateAlgorithmUI();

  // Listen for language changes
  window.addEventListener('storage', (e) => {
    if (e.key === 'app-lang') updateAlgorithmUI();
  });
})();
</script>

<!-- =============== STRING ALGORITHMS SECTION =============== -->
<div id="string-algos" class="section">
  <h2 data-i18n="string_algos_title">String Matching Algorithms</h2>
  
 
  <!-- ===== DETAILS & PYTHON CODE ===== -->
  <div class="details">
    <h3 data-i18n="details_heading">Algorithm Details</h3>
    <p id="string-desc">
      <!-- Dynamically updated based on selected algorithm -->
    </p>
    
    <div class="python-code" style="margin-top:15px;">
      <div class="code-header" data-i18n="py_heading">Python Implementation</div>
      <pre id="string-python-code"></pre>
    </div>
    
    <div class="row" style="margin-top:15px; padding:12px; background:#1a1a2e; border-radius:8px;">
      <div style="display:flex; flex-wrap:wrap; gap:20px; flex:1;">
        <div>
          <strong data-i18n="time_complexity_label">Time Complexity:</strong>
          <div id="time-complexity-str" style="margin-top:5px; font-family:monospace;"></div>
        </div>
        <div>
          <strong data-i18n="space_complexity_label">Space Complexity:</strong>
          <div id="space-complexity-str" style="margin-top:5px; font-family:monospace;"></div>
        </div>
        <div>
          <strong data-i18n="best_for">Best For:</strong>
          <div id="best-for-str" style="margin-top:5px; font-family:monospace;"></div>
        </div>
      </div>
    </div>
  </div>
 <!-- ===== ALGORITHM SELECTION & INPUTS ===== -->
  <div class="panel" style="margin-bottom:20px;">
    <div class="row" style="flex-wrap:wrap; gap:15px;">
      <label><strong data-i18n="select_algorithm">Select Algorithm:</strong></label>
      <select id="string-algo" style="flex:1; min-width:200px;">
        <option value="kmp">Knuth-Morris-Pratt (KMP)</option>
        <option value="rabin-karp">Rabin-Karp</option>
        <option value="z-algo">Z-Algorithm</option>
      </select>
      
      <button id="run-string-algo" class="accent" style="padding:10px 24px; font-size:16px;">
        <span data-i18n="btn_run_search">Run Search</span>
      </button>
      <button id="random-string" style="padding:10px 24px; background:#6a5acd; border-color:#7a6add;">
        <span data-i18n="btn_random_text">Random Text</span>
      </button>
    </div>
    
    <div class="row" style="margin-top:15px; flex-wrap:wrap; gap:15px;">
      <div style="flex:2; min-width:300px;">
        <label><strong data-i18n="text_input">Text:</strong></label>
        <input type="text" id="text-input" placeholder="e.g., ABABDABACDABABCABCABCABD" style="width:100%; padding:10px; font-size:16px;">
      </div>
      <div style="flex:1; min-width:200px;">
        <label><strong data-i18n="pattern_input">Pattern:</strong></label>
        <input type="text" id="pattern-input" placeholder="e.g., ABABCABAB" style="width:100%; padding:10px; font-size:16px;">
      </div>
    </div>
  </div>

  <!-- ===== VISUALIZATION CANVAS ===== -->
  <div class="panel" style="margin-top:20px;">
    <div id="string-canvas-container" style="overflow:auto; background:#0b1021; border-radius:12px; padding:15px; min-height:200px;">
      <!-- Visualization will be rendered here -->
    </div>
  </div>

  <!-- ===== RESULTS & FEEDBACK ===== -->
  <div class="panel" style="margin-top:20px;">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <h3 style="margin:0;" data-i18n="result_heading">Result</h3>
      <div id="string-status" style="font-weight:bold; padding:8px 16px; border-radius:8px;"></div>
    </div>
    <div id="string-result" style="margin-top:15px; padding:15px; background:#1a1a2e; border-radius:8px; min-height:60px; font-size:18px; font-family:monospace;"></div>
  </div>

  <!-- ===== INSTRUCTIONS ===== -->
  <div class="panel" style="margin-top:20px; background:#16213e; border-left:4px solid #f5d06f;">
    <h3 style="margin:0 0 15px 0; color:#f5d06f;" data-i18n="instructions">How to Use</h3>
    <ol style="padding-left:20px; line-height:1.6;">
      <li data-i18n="str_instr1">Enter text and pattern or use "Random Text"</li>
      <li data-i18n="str_instr2">Select an algorithm from the dropdown</li>
      <li data-i18n="str_instr3">Click "Run Search" to see step-by-step matching process</li>
      <li data-i18n="str_instr4">Green = match found, Yellow = current comparison, Red = mismatch</li>
    </ol>
  </div>
</div>

<script>
// ====================== STRING ALGORITHMS SANDBOX ======================
(() => {
  const container = document.getElementById('string-algos');
  if (!container) return;

  // State
  let isAnimating = false;
  let animationSpeed = 300;

  // DOM Elements
  const algoSelect = container.querySelector('#string-algo');
  const textInput = container.querySelector('#text-input');
  const patternInput = container.querySelector('#pattern-input');
  const runBtn = container.querySelector('#run-string-algo');
  const randomBtn = container.querySelector('#random-string');
  const canvasContainer = container.querySelector('#string-canvas-container');
  const descDiv = container.querySelector('#string-desc');
  const codeDiv = container.querySelector('#string-python-code');
  const timeComplexityDiv = container.querySelector('#time-complexity-str');
  const spaceComplexityDiv = container.querySelector('#space-complexity-str');
  const bestForDiv = container.querySelector('#best-for-str');
  const statusDiv = container.querySelector('#string-status');
  const resultDiv = container.querySelector('#string-result');

  // Algorithm configurations
  const algorithms = {
    en: {
      kmp: {
        name: "Knuth-Morris-Pratt (KMP)",
        desc: "KMP is a linear-time string matching algorithm that avoids unnecessary comparisons by using a prefix function (LPS array). When a mismatch occurs, it uses the LPS array to determine how much to shift the pattern, skipping previously matched characters. This makes it optimal for cases where the pattern has repeating substrings.",
        python: `def compute_lps(pattern):
    m = len(pattern)
    lps = [0] * m
    length = 0
    i = 1
    
    while i < m:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(text, pattern):
    n = len(text)
    m = len(pattern)
    
    if m == 0:
        return []
    
    lps = compute_lps(pattern)
    i = 0  # index for text
    j = 0  # index for pattern
    matches = []
    
    while i < n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
        
        if j == m:
            matches.append(i - j)
            j = lps[j - 1]
        elif i < n and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return matches`,
        time: "O(n + m)",
        space: "O(m)",
        bestFor: "Patterns with repeating prefixes/suffixes"
      },
      'rabin-karp': {
        name: "Rabin-Karp",
        desc: "Rabin-Karp uses hashing to find patterns in text. It computes hash values for the pattern and each substring of the text of the same length. When hash values match, it performs a character-by-character comparison to confirm. It's efficient for multiple pattern searches and can handle large alphabets, but may have false positives due to hash collisions.",
        python: `def rabin_karp_search(text, pattern, prime=101):
    n = len(text)
    m = len(pattern)
    
    if m == 0 or n < m:
        return []
    
    # Calculate hash values
    pattern_hash = 0
    text_hash = 0
    h = 1
    
    # Calculate h = pow(d, m-1) % prime
    d = 256  # number of characters in alphabet
    for i in range(m - 1):
        h = (h * d) % prime
    
    # Calculate hash for pattern and first window of text
    for i in range(m):
        pattern_hash = (d * pattern_hash + ord(pattern[i])) % prime
        text_hash = (d * text_hash + ord(text[i])) % prime
    
    matches = []
    for i in range(n - m + 1):
        # Check if hash values match
        if pattern_hash == text_hash:
            # Verify character by character
            if text[i:i + m] == pattern:
                matches.append(i)
        
        # Calculate hash for next window
        if i < n - m:
            text_hash = (d * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime
            # Handle negative hash
            if text_hash < 0:
                text_hash += prime
    
    return matches`,
        time: "O(n + m) average, O(nm) worst",
        space: "O(1)",
        bestFor: "Multiple pattern searches, plagiarism detection"
      },
      'z-algo': {
        name: "Z-Algorithm",
        desc: "The Z-algorithm constructs a Z-array where Z[i] represents the length of the longest substring starting from i that matches the prefix of the string. For pattern matching, we concatenate pattern + '$' + text and compute the Z-array. Positions where Z[i] equals the pattern length indicate matches. It's simple to implement and has linear time complexity.",
        python: `def compute_z_array(s):
    n = len(s)
    z = [0] * n
    l, r = 0, 0
    
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    
    return z

def z_algorithm_search(text, pattern):
    if not pattern:
        return []
    
    combined = pattern + '$' + text
    z = compute_z_array(combined)
    m = len(pattern)
    matches = []
    
    for i in range(m + 1, len(z)):
        if z[i] == m:
            matches.append(i - m - 1)
    
    return matches`,
        time: "O(n + m)",
        space: "O(n + m)",
        bestFor: "Finding all occurrences, string periodicity"
      }
    },
    uz: {
      kmp: {
        name: "Knuth-Morris-Pratt (KMP)",
        desc: "KMP ‚Äî chiqishlarni keraksiz taqqoslashlardan saqlash uchun prefiks funksiyasidan (LPS massivi) foydalanadigan chiziqli vaqtli satr moslash algoritmidir. Mos kelmaslik sodir bo'lganda, u LPS massividan foydalanib, namunani qanchalik siljishini aniqlaydi va oldinroq mos kelgan belgilarni o'tkazib yuboradi. Bu takrorlanuvchi ostki satrlarga ega namunalar uchun optimaldir.",
        python: `def compute_lps(pattern):
    m = len(pattern)
    lps = [0] * m
    length = 0
    i = 1
    
    while i < m:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(text, pattern):
    n = len(text)
    m = len(pattern)
    
    if m == 0:
        return []
    
    lps = compute_lps(pattern)
    i = 0  # matn uchun indeks
    j = 0  # namuna uchun indeks
    matches = []
    
    while i < n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
        
        if j == m:
            matches.append(i - j)
            j = lps[j - 1]
        elif i < n and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return matches`,
        time: "O(n + m)",
        space: "O(m)",
        bestFor: "Takrorlanuvchi prefikslar/sufikslarga ega namunalar"
      },
      'rabin-karp': {
        name: "Rabin-Karp",
        desc: "Rabin-Karp matndagi namunalarni topish uchun xeshdan foydalanadi. U namuna va matndagi bir xil uzunlikdagi har bir ostki satr uchun xesh qiymatlarini hisoblaydi. Xesh qiymatlari mos kelganda, mosligini tasdiqlash uchun belgidan belgiga taqqoslashni amalga oshiradi. Bu ko'p namuna qidiruvlari va katta alifbolar uchun samarali, lekin xesh to'qnashuvlari tufayli noto'g'ri ijobiy natijalarga sabab bo'lishi mumkin.",
        python: `def rabin_karp_search(text, pattern, prime=101):
    n = len(text)
    m = len(pattern)
    
    if m == 0 or n < m:
        return []
    
    # Xesh qiymatlarini hisoblash
    pattern_hash = 0
    text_hash = 0
    h = 1
    
    # h = pow(d, m-1) % prime ni hisoblash
    d = 256  # alifbodagi belgilar soni
    for i in range(m - 1):
        h = (h * d) % prime
    
    # Namuna va matnning birinchi oynasi uchun xeshni hisoblash
    for i in range(m):
        pattern_hash = (d * pattern_hash + ord(pattern[i])) % prime
        text_hash = (d * text_hash + ord(text[i])) % prime
    
    matches = []
    for i in range(n - m + 1):
        # Xesh qiymatlari mos kelishini tekshiring
        if pattern_hash == text_hash:
            # Belgilarni bittadan tekshiring
            if text[i:i + m] == pattern:
                matches.append(i)
        
        # Keyingi oyna uchun xeshni hisoblang
        if i < n - m:
            text_hash = (d * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime
            # Salbiy xeshni boshqarish
            if text_hash < 0:
                text_hash += prime
    
    return matches`,
        time: "O(n + m) o'rtacha, O(nm) eng yomon",
        space: "O(1)",
        bestFor: "Ko'p namuna qidiruvlari, plagiatni aniqlash"
      },
      'z-algo': {
        name: "Z-algoritmi",
        desc: "Z-algoritmi Z-massivini quradi, bu yerda Z[i] i dan boshlanadigan va satr prefiksiga mos keladigan eng uzun ostki satr uzunligini ifodalaydi. Namuna moslash uchun biz namuna + '$' + matn ni birlashtiramiz va Z-massivini hisoblaymiz. Z[i] namuna uzunligiga teng bo'lgan pozitsiyalar mosliklarni ko'rsatadi. Uni amalga oshirish oddiy va chiziqli vaqt murakkabligiga ega.",
        python: `def compute_z_array(s):
    n = len(s)
    z = [0] * n
    l, r = 0, 0
    
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    
    return z

def z_algorithm_search(text, pattern):
    if not pattern:
        return []
    
    combined = pattern + '$' + text
    z = compute_z_array(combined)
    m = len(pattern)
    matches = []
    
    for i in range(m + 1, len(z)):
        if z[i] == m:
            matches.append(i - m - 1)
    
    return matches`,
        time: "O(n + m)",
        space: "O(n + m)",
        bestFor: "Barcha hodisalarni topish, satr davriyligi"
      }
    }
  };

  // Update UI based on selected algorithm
  const updateAlgorithmUI = () => {
    const algo = algoSelect.value;
    const lang = localStorage.getItem('app-lang') || 'en';
    const config = algorithms[lang][algo] || algorithms.en[algo];
    
    descDiv.textContent = config.desc;
    codeDiv.textContent = config.python;
    timeComplexityDiv.textContent = config.time;
    spaceComplexityDiv.textContent = config.space;
    bestForDiv.textContent = config.bestFor;
  };

  // Render text visualization
  const renderTextVisualization = (text, pattern, highlights = {}) => {
    let html = '<div style="font-family:monospace; font-size:16px; line-height:1.8;">';
    
    // Render text with highlights
    html += '<div><strong>Text:</strong></div>';
    html += '<div style="margin:10px 0; padding:10px; background:#1a1a2e; border-radius:8px;">';
    for (let i = 0; i < text.length; i++) {
      let bgColor = '#1a1a2e';
      let color = 'white';
      
      if (highlights.match && highlights.match.includes(i)) {
        bgColor = '#00c853'; // Green for matches
        color = 'black';
      } else if (highlights.current === i) {
        bgColor = '#ffab00'; // Amber for current
        color = 'black';
      } else if (highlights.mismatch === i) {
        bgColor = '#ff5252'; // Red for mismatch
        color = 'white';
      }
      
      html += `<span style="display:inline-block; width:24px; height:24px; text-align:center; line-height:24px; background:${bgColor}; color:${color}; margin:2px; border-radius:4px;">${text[i]}</span>`;
    }
    html += '</div>';
    
    // Render pattern with alignment
    if (highlights.patternStart !== undefined) {
      html += '<div><strong>Pattern:</strong></div>';
      html += '<div style="margin:10px 0; padding:10px; background:#1a1a2e; border-radius:8px;">';
      
      // Add spacing for alignment
      for (let i = 0; i < highlights.patternStart; i++) {
        html += '<span style="display:inline-block; width:24px; height:24px; margin:2px;"></span>';
      }
      
      for (let i = 0; i < pattern.length; i++) {
        let bgColor = '#667eea';
        let color = 'white';
        
        if (highlights.patternMatch && i < highlights.patternMatch.length && highlights.patternMatch[i]) {
          bgColor = '#00c853';
          color = 'black';
        } else if (highlights.patternCurrent === i) {
          bgColor = '#ffab00';
          color = 'black';
        } else if (highlights.patternMismatch === i) {
          bgColor = '#ff5252';
          color = 'white';
        }
        
        html += `<span style="display:inline-block; width:24px; height:24px; text-align:center; line-height:24px; background:${bgColor}; color:${color}; margin:2px; border-radius:4px;">${pattern[i]}</span>`;
      }
      html += '</div>';
    }
    
    html += '</div>';
    canvasContainer.innerHTML = html;
  };

  // Sleep helper
  const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  // KMP simulation
  const simulateKMP = async (text, pattern) => {
    const n = text.length;
    const m = pattern.length;
    if (m === 0) return [];
    
    // Compute LPS array with visualization
    const lps = Array(m).fill(0);
    let length = 0;
    let i = 1;
    
    while (i < m) {
      if (pattern[i] === pattern[length]) {
        length++;
        lps[i] = length;
        i++;
      } else {
        if (length !== 0) {
          length = lps[length - 1];
        } else {
          lps[i] = 0;
          i++;
        }
      }
    }
    
    // Search phase
    let textIdx = 0;
    let patternIdx = 0;
    const matches = [];
    
    while (textIdx < n) {
      // Visualize current comparison
      const highlights = {
        current: textIdx,
        patternCurrent: patternIdx,
        patternStart: textIdx - patternIdx
      };
      
      if (patternIdx < m && pattern[patternIdx] === text[textIdx]) {
        patternIdx++;
        textIdx++;
        highlights.patternMatch = Array(patternIdx).fill(true);
      } else {
        if (patternIdx === m) {
          matches.push(textIdx - patternIdx);
          patternIdx = lps[patternIdx - 1];
          // Highlight match
          const matchHighlights = {
            match: Array.from({length: m}, (_, j) => textIdx - m + j),
            patternStart: textIdx - m
          };
          renderTextVisualization(text, pattern, matchHighlights);
          await sleep(animationSpeed * 2);
        } else if (textIdx < n && patternIdx < m && pattern[patternIdx] !== text[textIdx]) {
          highlights.mismatch = textIdx;
          highlights.patternMismatch = patternIdx;
          renderTextVisualization(text, pattern, highlights);
          await sleep(animationSpeed);
          
          if (patternIdx !== 0) {
            patternIdx = lps[patternIdx - 1];
          } else {
            textIdx++;
          }
        }
      }
      
      renderTextVisualization(text, pattern, highlights);
      await sleep(animationSpeed);
    }
    
    // Final check for match at end
    if (patternIdx === m) {
      matches.push(textIdx - patternIdx);
      const matchHighlights = {
        match: Array.from({length: m}, (_, j) => textIdx - m + j),
        patternStart: textIdx - m
      };
      renderTextVisualization(text, pattern, matchHighlights);
      await sleep(animationSpeed * 2);
    }
    
    return matches;
  };

  // Rabin-Karp simulation
  const simulateRabinKarp = async (text, pattern) => {
    const n = text.length;
    const m = pattern.length;
    if (m === 0 || n < m) return [];
    
    const prime = 101;
    const d = 256;
    
    // Calculate h = pow(d, m-1) % prime
    let h = 1;
    for (let i = 0; i < m - 1; i++) {
      h = (h * d) % prime;
    }
    
    // Calculate initial hash values
    let patternHash = 0;
    let textHash = 0;
    for (let i = 0; i < m; i++) {
      patternHash = (d * patternHash + pattern.charCodeAt(i)) % prime;
      textHash = (d * textHash + text.charCodeAt(i)) % prime;
    }
    
    const matches = [];
    
    for (let i = 0; i <= n - m; i++) {
      // Visualize current window
      const highlights = {
        current: i,
        patternStart: i
      };
      
      // Check hash match
      if (patternHash === textHash) {
        // Verify character by character
        let isMatch = true;
        const patternMatch = [];
        
        for (let j = 0; j < m; j++) {
          if (text[i + j] !== pattern[j]) {
            isMatch = false;
            highlights.mismatch = i + j;
            highlights.patternMismatch = j;
            patternMatch.push(false);
          } else {
            patternMatch.push(true);
          }
        }
        
        highlights.patternMatch = patternMatch;
        renderTextVisualization(text, pattern, highlights);
        await sleep(animationSpeed);
        
        if (isMatch) {
          matches.push(i);
          // Highlight full match
          const matchHighlights = {
            match: Array.from({length: m}, (_, j) => i + j),
            patternStart: i
          };
          renderTextVisualization(text, pattern, matchHighlights);
          await sleep(animationSpeed * 2);
        }
      } else {
        // Hash mismatch
        highlights.mismatch = i;
        renderTextVisualization(text, pattern, highlights);
        await sleep(animationSpeed / 2);
      }
      
      // Calculate hash for next window (except last iteration)
      if (i < n - m) {
        textHash = (d * (textHash - text.charCodeAt(i) * h) + text.charCodeAt(i + m)) % prime;
        if (textHash < 0) textHash += prime;
      }
    }
    
    return matches;
  };

  // Z-algorithm simulation
  const simulateZAlgorithm = async (text, pattern) => {
    if (!pattern) return [];
    
    const combined = pattern + '$' + text;
    const n = combined.length;
    const z = Array(n).fill(0);
    let l = 0, r = 0;
    
    // Compute Z-array
    for (let i = 1; i < n; i++) {
      if (i <= r) {
        z[i] = Math.min(r - i + 1, z[i - l]);
      }
      
      // Expand while characters match
      while (i + z[i] < n && combined[z[i]] === combined[i + z[i]]) {
        z[i]++;
        
        // Visualize Z-array computation
        const tempCombined = combined.split('');
        const highlights = {
          current: i + z[i] - 1,
          patternStart: 0
        };
        
        // Highlight prefix comparison
        renderTextVisualization(tempCombined.join(''), pattern, highlights);
        await sleep(animationSpeed / 3);
      }
      
      if (i + z[i] - 1 > r) {
        l = i;
        r = i + z[i] - 1;
      }
    }
    
    // Find matches
    const m = pattern.length;
    const matches = [];
    
    for (let i = m + 1; i < n; i++) {
      if (z[i] === m) {
        const matchPos = i - m - 1;
        matches.push(matchPos);
        
        // Highlight match in original text
        const matchHighlights = {
          match: Array.from({length: m}, (_, j) => matchPos + j),
          patternStart: matchPos
        };
        renderTextVisualization(text, pattern, matchHighlights);
        await sleep(animationSpeed * 2);
      }
    }
    
    return matches;
  };

  // Run string matching algorithm
  const runStringAlgorithm = async () => {
    if (isAnimating) return;
    isAnimating = true;
    runBtn.disabled = true;
    
    const text = textInput.value;
    const pattern = patternInput.value;
    
    if (!text || !pattern) {
      statusDiv.textContent = '‚ùå Please enter both text and pattern';
      statusDiv.style.backgroundColor = 'rgba(255, 82, 82, 0.2)';
      resultDiv.innerHTML = '<span style="color:#ff5252">Text and pattern cannot be empty</span>';
      isAnimating = false;
      runBtn.disabled = false;
      return;
    }
    
    if (pattern.length > text.length) {
      statusDiv.textContent = '‚ùå Pattern longer than text';
      statusDiv.style.backgroundColor = 'rgba(255, 82, 82, 0.2)';
      resultDiv.innerHTML = '<span style="color:#ff5252">Pattern cannot be longer than text</span>';
      isAnimating = false;
      runBtn.disabled = false;
      return;
    }
    
    try {
      let matches;
      const algo = algoSelect.value;
      
      if (algo === 'kmp') {
        matches = await simulateKMP(text, pattern);
      } else if (algo === 'rabin-karp') {
        matches = await simulateRabinKarp(text, pattern);
      } else if (algo === 'z-algo') {
        matches = await simulateZAlgorithm(text, pattern);
      }
      
      if (matches.length > 0) {
        statusDiv.textContent = `‚úÖ Found ${matches.length} match(es)!`;
        statusDiv.style.backgroundColor = 'rgba(0, 200, 83, 0.2)';
        resultDiv.innerHTML = `<span style="color:#00c853">Matches at positions: [${matches.join(', ')}]</span>`;
      } else {
        statusDiv.textContent = '‚ùå No matches found';
        statusDiv.style.backgroundColor = 'rgba(255, 82, 82, 0.2)';
        resultDiv.innerHTML = '<span style="color:#ff5252">Pattern not found in text</span>';
      }
    } catch (error) {
      statusDiv.textContent = '‚ùå Error during execution';
      statusDiv.style.backgroundColor = 'rgba(255, 82, 82, 0.2)';
      resultDiv.innerHTML = `<span style="color:#ff5252">${error.message}</span>`;
    }
    
    isAnimating = false;
    runBtn.disabled = false;
  };

  // Generate random text and pattern
  const generateRandomText = () => {
    const texts = [
      "ABABDABACDABABCABCABCABD",
      "THIS IS A SAMPLE TEXT FOR STRING MATCHING",
      "ABCDEFGABCDEABCDABCABABA",
      "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
      "AAAAAABAAAAAABAAAAAAB"
    ];
    const patterns = [
      "ABABCABAB",
      "SAMPLE",
      "ABCDE",
      "FOX",
      "AAAAAAB"
    ];
    
    const randomText = texts[Math.floor(Math.random() * texts.length)];
    const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
    
    textInput.value = randomText;
    patternInput.value = randomPattern;
    renderTextVisualization(randomText, randomPattern);
  };

  // Event Listeners
  algoSelect.addEventListener('change', updateAlgorithmUI);
  runBtn.addEventListener('click', runStringAlgorithm);
  randomBtn.addEventListener('click', generateRandomText);

  // Initialize
  updateAlgorithmUI();
  renderTextVisualization("ABABDABACDABABCABCABCABD", "ABABCABAB");

  // Listen for language changes
  window.addEventListener('storage', (e) => {
    if (e.key === 'app-lang') updateAlgorithmUI();
  });
})();
</script>

<!-- =============== ADVANCED SORTING SECTION =============== -->
<div id="advanced-sorting" class="section">
  <h2 data-i18n="advanced_sorting_title">Advanced Sorting Algorithms</h2>

  <!-- ===== DETAILS & PYTHON CODE ===== -->
  <div class="details">
    <h3 data-i18n="details_heading">Algorithm Details</h3>
    <p id="advanced-desc">
      <!-- Dynamically updated based on selected algorithm -->
    </p>
    
    <div class="python-code" style="margin-top:15px;">
      <div class="code-header" data-i18n="py_heading">Python Implementation</div>
      <pre id="advanced-python-code"></pre>
    </div>
    
    <div class="row" style="margin-top:15px; padding:12px; background:#1a1a2e; border-radius:8px;">
      <div style="display:flex; flex-wrap:wrap; gap:20px; flex:1;">
        <div>
          <strong data-i18n="time_complexity_label">Time Complexity:</strong>
          <div id="time-complexity-adv" style="margin-top:5px; font-family:monospace;"></div>
        </div>
        <div>
          <strong data-i18n="space_complexity_label">Space Complexity:</strong>
          <div id="space-complexity-adv" style="margin-top:5px; font-family:monospace;"></div>
        </div>
        <div>
          <strong data-i18n="best_for">Best For:</strong>
          <div id="best-for-adv" style="margin-top:5px; font-family:monospace;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ===== ALGORITHM SELECTION ===== -->
  <div class="panel" style="margin-bottom:20px;">
    <div class="row" style="flex-wrap:wrap; gap:15px;">
      <label><strong data-i18n="select_algorithm">Select Algorithm:</strong></label>
      <select id="sorting-algo" style="flex:1; min-width:200px;">
        <option value="timsort">Timsort</option>
        <option value="radix">Radix Sort</option>
        <option value="counting">Counting Sort</option>
      </select>
      
      <button id="run-advanced-sort" class="accent" style="padding:10px 24px; font-size:16px;">
        <span data-i18n="btn_run_sort">Run Sorting</span>
      </button>
      <button id="random-advanced" style="padding:10px 24px; background:#6a5acd; border-color:#7a6add;">
        <span data-i18n="btn_random_data">Random Data</span>
      </button>
      <button id="clear-advanced" class="bad" style="padding:10px 24px;">
        <span data-i18n="btn_clear">Clear</span>
      </button>
    </div>
    
    <div class="row" style="margin-top:15px;">
      <input type="text" id="advanced-input" placeholder="e.g., 64,34,25,12,22,11,90" style="flex:1; padding:10px; font-size:16px;">
    </div>
  </div>

  <!-- ===== VISUALIZATION CANVAS ===== -->
  <div class="panel" style="margin-top:20px;">
    <canvas id="advanced-canvas" width="1100" height="450" style="background:#0b1021; border-radius:12px;"></canvas>
  </div>

  <!-- ===== RESULTS & FEEDBACK ===== -->
  <div class="panel" style="margin-top:20px;">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <h3 style="margin:0;" data-i18n="result_heading">Result</h3>
      <div id="advanced-status" style="font-weight:bold; padding:8px 16px; border-radius:8px;"></div>
    </div>
    <div id="advanced-result" style="margin-top:15px; padding:15px; background:#1a1a2e; border-radius:8px; min-height:60px; font-size:18px; font-family:monospace;"></div>
  </div>

  <!-- ===== INSTRUCTIONS ===== -->
  <div class="panel" style="margin-top:20px; background:#16213e; border-left:4px solid #f5d06f;">
    <h3 style="margin:0 0 15px 0; color:#f5d06f;" data-i18n="instructions">How to Use</h3>
    <ol style="padding-left:20px; line-height:1.6;">
      <li data-i18n="adv_instr1">Enter comma-separated numbers or use "Random Data"</li>
      <li data-i18n="adv_instr2">Select an algorithm from the dropdown</li>
      <li data-i18n="adv_instr3">Click "Run Sorting" to see step-by-step visualization</li>
      <li data-i18n="adv_instr4">Green bars = sorted, Yellow = current processing, Red = comparison</li>
    </ol>
  </div>
</div>

<script>
// ====================== ADVANCED SORTING SANDBOX ======================
(() => {
  const container = document.getElementById('advanced-sorting');
  if (!container) return;

  // State
  let currentArray = [];
  let isAnimating = false;
  let animationSpeed = 200;

  // DOM Elements
  const algoSelect = container.querySelector('#sorting-algo');
  const inputField = container.querySelector('#advanced-input');
  const runBtn = container.querySelector('#run-advanced-sort');
  const randomBtn = container.querySelector('#random-advanced');
  const clearBtn = container.querySelector('#clear-advanced');
  const canvas = container.querySelector('#advanced-canvas');
  const ctx = canvas.getContext('2d');
  const descDiv = container.querySelector('#advanced-desc');
  const codeDiv = container.querySelector('#advanced-python-code');
  const timeComplexityDiv = container.querySelector('#time-complexity-adv');
  const spaceComplexityDiv = container.querySelector('#space-complexity-adv');
  const bestForDiv = container.querySelector('#best-for-adv');
  const statusDiv = container.querySelector('#advanced-status');
  const resultDiv = container.querySelector('#advanced-result');

  // Algorithm configurations
  const algorithms = {
    en: {
      timsort: {
        name: "Timsort",
        desc: "Timsort is a hybrid stable sorting algorithm derived from merge sort and insertion sort. It's designed to perform well on many kinds of real-world data and is the default sorting algorithm in Python and Java (for objects). It identifies already sorted runs and merges them efficiently.",
        python: `def timsort(arr):
    # Python's built-in sort uses Timsort
    return sorted(arr)
    
# Manual implementation is complex, but here's the concept:
def insertion_sort(arr, left, right):
    for i in range(left + 1, right + 1):
        key = arr[i]
        j = i - 1
        while j >= left and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def merge(arr, l, m, r):
    len1, len2 = m - l + 1, r - m
    left, right = [], []
    for i in range(len1):
        left.append(arr[l + i])
    for i in range(len2):
        right.append(arr[m + 1 + i])
    
    i = j = 0
    k = l
    while i < len1 and j < len2:
        if left[i] <= right[j]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1
    
    while i < len1:
        arr[k] = left[i]
        k += 1
        i += 1
    while j < len2:
        arr[k] = right[j]
        k += 1
        j += 1

def timsort_manual(arr):
    n = len(arr)
    MIN_MERGE = 32
    
    def calc_min_run(n):
        r = 0
        while n >= MIN_MERGE:
            r |= n & 1
            n >>= 1
        return n + r
    
    min_run = calc_min_run(n)
    
    # Sort individual subarrays of size min_run
    for start in range(0, n, min_run):
        end = min(start + min_run - 1, n - 1)
        insertion_sort(arr, start, end)
    
    # Merge subarrays
    size = min_run
    while size < n:
        for left in range(0, n, 2 * size):
            mid = min(n - 1, left + size - 1)
            right = min((left + 2 * size - 1), (n - 1))
            if mid < right:
                merge(arr, left, mid, right)
        size *= 2
    
    return arr`,
        time: "O(n log n)",
        space: "O(n)",
        bestFor: "Real-world data with partially sorted sequences"
      },
      radix: {
        name: "Radix Sort",
        desc: "Radix Sort is a non-comparative integer sorting algorithm that sorts numbers by processing individual digits. It processes digits from least significant digit (LSD) to most significant digit (MSD) or vice versa. It uses counting sort as a subroutine to sort digits at each position.",
        python: `def counting_sort_for_radix(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10
    
    # Store count of occurrences
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1
    
    # Change count[i] to actual position
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    # Build output array
    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1
    
    # Copy output to arr
    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr):
    # Find maximum number to know number of digits
    max_num = max(arr)
    
    # Do counting sort for every digit
    exp = 1
    while max_num // exp > 0:
        counting_sort_for_radix(arr, exp)
        exp *= 10
    
    return arr`,
        time: "O(d √ó (n + k))",
        space: "O(n + k)",
        bestFor: "Integers with fixed number of digits (d)"
      },
      counting: {
        name: "Counting Sort",
        desc: "Counting Sort is a non-comparative sorting algorithm that works by counting the number of objects having distinct key values. It creates a count array to store the count of each unique object, then calculates the positions of each element in the output sequence. It's efficient when the range of input data (k) is not significantly greater than the number of elements (n).",
        python: `def counting_sort(arr):
    if not arr:
        return arr
        
    # Find range of elements
    max_val = max(arr)
    min_val = min(arr)
    range_val = max_val - min_val + 1
    
    # Initialize count array
    count = [0] * range_val
    output = [0] * len(arr)
    
    # Store count of each element
    for num in arr:
        count[num - min_val] += 1
    
    # Change count[i] to actual position
    for i in range(1, range_val):
        count[i] += count[i - 1]
    
    # Build output array
    for i in range(len(arr) - 1, -1, -1):
        output[count[arr[i] - min_val] - 1] = arr[i]
        count[arr[i] - min_val] -= 1
    
    return output`,
        time: "O(n + k)",
        space: "O(k)",
        bestFor: "Small range of integers (k ‚âà n)"
      }
    },
    uz: {
      timsort: {
        name: "Timsort",
        desc: "Timsort ‚Äî birlashtirish saralash va qo'shish saralashdan olingan gibrid barqaror saralash algoritmidir. U turli xil haqiqiy ma'lumotlarda yaxshi ishlash uchun mo'ljallangan bo'lib, Python va Java (obyektlar uchun) da standart saralash algoritmi sifatida ishlatiladi. Oldindan saralangan ketma-ketliklarni aniqlaydi va ularni samarali birlashtiradi.",
        python: `def timsort(arr):
    # Pythonning o'rnatilgan saralash funksiyasi Timsortdan foydalanadi
    return sorted(arr)
    
# Qo'lda amalga oshirish murakkab, lekin konsepsiya shunday:
def insertion_sort(arr, left, right):
    for i in range(left + 1, right + 1):
        key = arr[i]
        j = i - 1
        while j >= left and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def merge(arr, l, m, r):
    len1, len2 = m - l + 1, r - m
    left, right = [], []
    for i in range(len1):
        left.append(arr[l + i])
    for i in range(len2):
        right.append(arr[m + 1 + i])
    
    i = j = 0
    k = l
    while i < len1 and j < len2:
        if left[i] <= right[j]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1
    
    while i < len1:
        arr[k] = left[i]
        k += 1
        i += 1
    while j < len2:
        arr[k] = right[j]
        k += 1
        j += 1

def timsort_manual(arr):
    n = len(arr)
    MIN_MERGE = 32
    
    def calc_min_run(n):
        r = 0
        while n >= MIN_MERGE:
            r |= n & 1
            n >>= 1
        return n + r
    
    min_run = calc_min_run(n)
    
    # min_run hajmidagi alohida massivlarni saralash
    for start in range(0, n, min_run):
        end = min(start + min_run - 1, n - 1)
        insertion_sort(arr, start, end)
    
    # Ostki massivlarni birlashtirish
    size = min_run
    while size < n:
        for left in range(0, n, 2 * size):
            mid = min(n - 1, left + size - 1)
            right = min((left + 2 * size - 1), (n - 1))
            if mid < right:
                merge(arr, left, mid, right)
        size *= 2
    
    return arr`,
        time: "O(n log n)",
        space: "O(n)",
        bestFor: "Qisman saralangan ketma-ketliklarga ega haqiqiy ma'lumotlar"
      },
      radix: {
        name: "Radix Sort",
        desc: "Radix Sort ‚Äî raqamlarni alohida qayta ishlab, sonlarni saralovchi taqqoslamaydigan butun sonlar saralash algoritmidir. U eng kam ahamiyatli raqamdan (LSD) eng ko'p ahamiyatli raqamgacha (MSD) yoki aksincha raqamlarni qayta ishlaydi. Har bir pozitsiyadagi raqamlarni saralash uchun hisoblash saralashidan foydalanadi.",
        python: `def counting_sort_for_radix(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10
    
    # Hodisalar sonini saqlash
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1
    
    # count[i] ni haqiqiy pozitsiyaga o'zgartirish
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    # Chiqish massivini yaratish
    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1
    
    # Chiqishni arr ga nusxalash
    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr):
    # Raqamlar sonini bilish uchun maksimal sonni topish
    max_num = max(arr)
    
    # Har bir raqam uchun hisoblash saralashini bajaring
    exp = 1
    while max_num // exp > 0:
        counting_sort_for_radix(arr, exp)
        exp *= 10
    
    return arr`,
        time: "O(d √ó (n + k))",
        space: "O(n + k)",
        bestFor: "Belgilangan raqamlar soniga ega butun sonlar (d)"
      },
      counting: {
        name: "Counting Sort",
        desc: "Hisoblash saralashi ‚Äî har xil kalit qiymatlariga ega obyektlar sonini sanash orqali ishlovchi taqqoslamaydigan saralash algoritmidir. U har bir noyob obyektning sonini saqlash uchun hisoblash massivini yaratadi, so'ngra chiqish ketma-ketligidagi har bir elementning pozitsiyasini hisoblaydi. Kirish ma'lumotlarining diapazoni (k) elementlar sonidan (n) ancha katta bo'lmaganda samarali ishlaydi.",
        python: `def counting_sort(arr):
    if not arr:
        return arr
        
    # Elementlarning diapazonini topish
    max_val = max(arr)
    min_val = min(arr)
    range_val = max_val - min_val + 1
    
    # Hisoblash massivini ishga tushirish
    count = [0] * range_val
    output = [0] * len(arr)
    
    # Har bir elementning sonini saqlash
    for num in arr:
        count[num - min_val] += 1
    
    # count[i] ni haqiqiy pozitsiyaga o'zgartirish
    for i in range(1, range_val):
        count[i] += count[i - 1]
    
    # Chiqish massivini yaratish
    for i in range(len(arr) - 1, -1, -1):
        output[count[arr[i] - min_val] - 1] = arr[i]
        count[arr[i] - min_val] -= 1
    
    return output`,
        time: "O(n + k)",
        space: "O(k)",
        bestFor: "Kichik diapazonli butun sonlar (k ‚âà n)"
      }
    }
  };

  // Update UI based on selected algorithm
  const updateAlgorithmUI = () => {
    const algo = algoSelect.value;
    const lang = localStorage.getItem('app-lang') || 'en';
    const config = algorithms[lang][algo] || algorithms.en[algo];
    
    descDiv.textContent = config.desc;
    codeDiv.textContent = config.python;
    timeComplexityDiv.textContent = config.time;
    spaceComplexityDiv.textContent = config.space;
    bestForDiv.textContent = config.bestFor;
  };

  // Initialize array
  const initArray = () => {
    const input = inputField.value.trim();
    if (input) {
      currentArray = input.split(',').map(s => {
        const num = parseFloat(s.trim());
        return isNaN(num) ? 0 : num;
      }).filter(n => !isNaN(n));
    } else {
      currentArray = [64, 34, 25, 12, 22, 11, 90, 88, 76, 50, 42];
    }
    drawArray(currentArray);
    resultDiv.innerHTML = '';
    statusDiv.textContent = '';
    statusDiv.style.backgroundColor = '';
  };

  // Draw array visualization
  const drawArray = (arr, highlightIndices = {}, sortedIndices = new Set()) => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (arr.length === 0) return;
    
    const maxVal = Math.max(...arr, 1);
    const barWidth = Math.min(60, (canvas.width - 100) / arr.length);
    const barSpacing = 10;
    const totalWidth = arr.length * (barWidth + barSpacing) - barSpacing;
    const startX = (canvas.width - totalWidth) / 2;
    const baseY = canvas.height - 50;
    
    arr.forEach((val, i) => {
      const x = startX + i * (barWidth + barSpacing);
      const h = (val / maxVal) * 300;
      
      // Determine color
      let color = '#667eea'; // Default blue
      if (sortedIndices.has(i)) color = '#00c853'; // Green for sorted
      else if (highlightIndices.current === i) color = '#ffab00'; // Amber for current
      else if (highlightIndices.comparison === i) color = '#ff5252'; // Red for comparison
      
      ctx.fillStyle = color;
      ctx.fillRect(x, baseY - h, barWidth, h);
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, baseY - h, barWidth, h);
      
      ctx.fillStyle = 'white';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(Math.round(val), x + barWidth / 2, baseY - h - 10);
      ctx.fillText(i, x + barWidth / 2, baseY + 20);
    });
  };

  // Sleep helper
  const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  // Timsort simulation (simplified visualization)
  const simulateTimsort = async (arr) => {
    const sorted = [...arr].sort((a, b) => a - b);
    const steps = Math.min(20, arr.length);
    
    for (let i = 1; i <= steps; i++) {
      const progress = Math.floor((i / steps) * arr.length);
      const currentSlice = [...arr].slice(0, progress).sort((a, b) => a - b);
      const merged = [...currentSlice, ...arr.slice(progress)];
      
      const sortedIndices = new Set();
      for (let j = 0; j < progress; j++) {
        sortedIndices.add(j);
      }
      
      drawArray(merged, {}, sortedIndices);
      await sleep(animationSpeed);
    }
    
    drawArray(sorted, {}, new Set(Array.from({length: arr.length}, (_, i) => i)));
    return sorted;
  };

  // Radix sort simulation
  const simulateRadixSort = async (arr) => {
    if (arr.length === 0) return arr;
    
    // Handle negative numbers by offsetting
    const minVal = Math.min(...arr);
    const offset = minVal < 0 ? -minVal : 0;
    const adjustedArr = arr.map(x => x + offset);
    
    const maxNum = Math.max(...adjustedArr);
    let exp = 1;
    let currentArr = [...adjustedArr];
    
    while (Math.floor(maxNum / exp) > 0) {
      // Counting sort for current digit
      const output = new Array(currentArr.length);
      const count = new Array(10).fill(0);
      
      // Count occurrences
      for (let i = 0; i < currentArr.length; i++) {
        const digit = Math.floor(currentArr[i] / exp) % 10;
        count[digit]++;
      }
      
      // Calculate positions
      for (let i = 1; i < 10; i++) {
        count[i] += count[i - 1];
      }
      
      // Build output array (stable sort)
      for (let i = currentArr.length - 1; i >= 0; i--) {
        const digit = Math.floor(currentArr[i] / exp) % 10;
        output[count[digit] - 1] = currentArr[i];
        count[digit]--;
      }
      
      currentArr = [...output];
      
      // Visualize current state
      const originalArr = currentArr.map(x => x - offset);
      drawArray(originalArr, { current: -1 }, new Set());
      await sleep(animationSpeed * 2);
      
      exp *= 10;
    }
    
    return currentArr.map(x => x - offset);
  };

  // Counting sort simulation
  const simulateCountingSort = async (arr) => {
    if (arr.length === 0) return arr;
    
    const minVal = Math.min(...arr);
    const maxVal = Math.max(...arr);
    const range = maxVal - minVal + 1;
    
    // Create count array
    const count = new Array(range).fill(0);
    for (const num of arr) {
      count[num - minVal]++;
    }
    
    // Visualize count array creation
    drawArray(arr, { current: -1 }, new Set());
    await sleep(animationSpeed);
    
    // Build output array
    const output = [];
    for (let i = 0; i < range; i++) {
      while (count[i] > 0) {
        output.push(i + minVal);
        count[i]--;
        
        // Visualize progressive building
        const tempOutput = [...output, ...arr.slice(output.length)];
        drawArray(tempOutput, { current: output.length - 1 }, new Set());
        await sleep(animationSpeed / 2);
      }
    }
    
    return output;
  };

  // Run sorting algorithm
  const runSorting = async () => {
    if (isAnimating) return;
    isAnimating = true;
    runBtn.disabled = true;
    
    initArray();
    const algo = algoSelect.value;
    let sortedArray;
    
    try {
      if (algo === 'timsort') {
        sortedArray = await simulateTimsort([...currentArray]);
      } else if (algo === 'radix') {
        // Check if all numbers are integers
        const hasNonInteger = currentArray.some(x => !Number.isInteger(x));
        if (hasNonInteger) {
          throw new Error("Radix Sort requires integers");
        }
        sortedArray = await simulateRadixSort([...currentArray]);
      } else if (algo === 'counting') {
        // Check if numbers are within reasonable range
        const range = Math.max(...currentArray) - Math.min(...currentArray);
        if (range > 1000) {
          throw new Error("Counting Sort works best with small ranges");
        }
        sortedArray = await simulateCountingSort([...currentArray]);
      }
      
      statusDiv.textContent = '‚úÖ Sorting completed!';
      statusDiv.style.backgroundColor = 'rgba(0, 200, 83, 0.2)';
      resultDiv.innerHTML = `<span style="color:#00c853">Sorted: [${sortedArray.join(', ')}]</span>`;
    } catch (error) {
      statusDiv.textContent = '‚ùå Error!';
      statusDiv.style.backgroundColor = 'rgba(255, 82, 82, 0.2)';
      resultDiv.innerHTML = `<span style="color:#ff5252">${error.message}</span>`;
    }
    
    isAnimating = false;
    runBtn.disabled = false;
  };

  // Generate random data
  const generateRandomData = () => {
    const algo = algoSelect.value;
    let arr;
    
    if (algo === 'radix' || algo === 'counting') {
      // Generate integers for radix/counting sort
      arr = Array.from({length: 12}, () => Math.floor(Math.random() * 100));
    } else {
      // Generate floats for timsort
      arr = Array.from({length: 12}, () => Math.floor(Math.random() * 100) + Math.random().toFixed(1));
    }
    
    inputField.value = arr.join(', ');
    initArray();
  };

  // Event Listeners
  algoSelect.addEventListener('change', updateAlgorithmUI);
  runBtn.addEventListener('click', runSorting);
  randomBtn.addEventListener('click', generateRandomData);
  clearBtn.addEventListener('click', () => {
    inputField.value = '';
    currentArray = [];
    drawArray([]);
    resultDiv.innerHTML = '';
    statusDiv.textContent = '';
    statusDiv.style.backgroundColor = '';
  });

  // Initialize
  updateAlgorithmUI();
  initArray();

  // Listen for language changes
  window.addEventListener('storage', (e) => {
    if (e.key === 'app-lang') updateAlgorithmUI();
  });
})();
</script>

    <!-- ====================== TIME COMPLEXITY ====================== -->
    <div id="time-complexity" class="section">
      <h2 data-i18n="time_complexity_title">Time Complexity Sandbox</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p><strong data-i18n="time_complexity">Time Complexity</strong> <span data-i18n="time_complexity_desc">describes how an algorithm's runtime grows as the input size increases. It uses</span> <strong data-i18n="big_o">Big-O notation</strong> <span data-i18n="big_o_desc">to express the worst-case growth rate, ignoring constants and lower-order terms.</span></p>
        <p><strong data-i18n="key_classes">Key Classes:</strong></p>
        <ul style="margin-top:10px; padding-left:20px;">
          <li><span style="color:#00ff88">O(1)</span>: <span data-i18n="o1_desc">Constant ‚Äî independent of input size.</span></li>
          <li><span style="color:#00ccff">O(log n)</span>: <span data-i18n="ologn_desc">Logarithmic ‚Äî halves problem each step (e.g., binary search).</span></li>
          <li><span style="color:#ffeb3b">O(n)</span>: <span data-i18n="on_desc">Linear ‚Äî scales directly with input (e.g., simple loop).</span></li>
          <li><span style="color:#ff9800">O(n log n)</span>: <span data-i18n="onlogn_desc">Linearithmic ‚Äî divide-and-conquer sorts (e.g., merge sort).</span></li>
          <li><span style="color:#ff5252">O(n¬≤)</span>: <span data-i18n="on2_desc">Quadratic ‚Äî nested loops (e.g., bubble sort).</span></li>
          <li><span style="color:#e040fb">O(2‚Åø)</span>: <span data-i18n="o2n_desc">Exponential ‚Äî recursive branching (e.g., naive Fibonacci).</span></li>
        </ul>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
# O(1) - Constant Time
def check_first(arr):
    return arr[0] if arr else None
# O(n) - Linear Time
def print_all(arr):
    for val in arr:
        print(val)
# O(n¬≤) - Quadratic Time
def print_pairs(arr):
    for i in arr:
        for j in arr:
            print(i, j)
</pre>
      </div>
      <div class="controls">
        <label data-i18n="input_size">Input Size (n):</label>
        <input type="number" id="time-n" value="50" min="1" max="200">
        <button onclick="animateTimeGrowth()" data-i18n="btn_animate_growth">Animate Growth</button>
        <button onclick="resetTimeCanvas()" data-i18n="btn_reset">Reset</button>
      </div>
      <canvas id="time-canvas" width="1100" height="500"></canvas>
      <div class="info" id="time-info" data-i18n="time_info">Adjust n and click "Animate Growth" to see how operations scale</div>
    </div>

    <!-- ====================== SPACE COMPLEXITY ====================== -->
    <div id="space-complexity" class="section">
      <h2 data-i18n="space_complexity_title">Space Complexity Sandbox</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p><strong data-i18n="space_complexity">Space Complexity</strong> <span data-i18n="space_complexity_desc">measures the total memory an algorithm uses relative to input size. It includes:</span></p>
        <ul style="margin-top:10px; padding-left:20px;">
          <li><strong data-i18n="input_space">Input space</strong>: <span data-i18n="input_space_desc">Memory to store the input data.</span></li>
          <li><strong data-i18n="auxiliary_space">Auxiliary space</strong>: <span data-i18n="auxiliary_space_desc">Extra memory used during execution (e.g., recursion stack, temp arrays).</span></li>
        </ul>
        <p data-i18n="space_example">Example: Merge Sort uses O(n) auxiliary space for merging; Quick Sort uses O(log n) for recursion depth (in-place).</p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="space_comparison">Space Comparison: Fibonacci</div>
        <pre>
# O(n) space: Recursive (call stack)
def fib_rec(n):
    if n <= 1:
        return n
    return fib_rec(n-1) + fib_rec(n-2)
# O(1) space: Iterative
def fib_iter(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a
</pre>
      </div>
      <div class="controls">
        <label>n = </label>
        <input type="number" id="space-n" value="10" min="1" max="30">
        <button onclick="animateSpaceUsage()" data-i18n="btn_visualize_memory">Visualize Memory</button>
      </div>
      <canvas id="space-canvas" width="1100" height="400"></canvas>
      <div class="info" id="space-info" data-i18n="space_info">Compare memory usage for different approaches</div>
    </div>

    <!-- ====================== COMPLEXITY RACE ====================== -->
    <div id="complexity" class="section">
      <h2 data-i18n="complexity_race_title">Time & Space Complexity Race</h2>
      <div class="details">
        <h3 data-i18n="how_it_works">How It Works</h3>
        <p data-i18n="race_desc">Select two algorithms to compare. The race visualizes how their time complexity scales as input size increases. The vertical axis shows "operations" (simulated), and the horizontal axis shows input size (n). Lower curve = more efficient.</p>
      </div>
      <div class="controls">
        <label data-i18n="algo_a">Algorithm A:</label>
        <select id="algo-a">
          <option value="bubble" data-i18n="bubble_sort">Bubble Sort</option>
          <option value="quick" data-i18n="quick_sort">Quick Sort</option>
          <option value="merge" data-i18n="merge_sort">Merge Sort</option>
          <option value="insertion" data-i18n="insertion_sort">Insertion Sort</option>
          <option value="selection" data-i18n="selection_sort">Selection Sort</option>
          <option value="heap" data-i18n="heap_sort">Heap Sort</option>
          <option value="radix">Radix Sort</option>
          <option value="linear" data-i18n="linear_search">Linear Search</option>
          <option value="binary" data-i18n="binary_search">Binary Search</option>
          <option value="bst">BST Search</option>
          <option value="hashtable">Hash Table Search</option>
          <option value="access" data-i18n="array_access">Array Access O(1)</option>
          <option value="fib-recursive" data-i18n="fib_recursive">Fibonacci (Recursive)</option>
          <option value="fib-dp" data-i18n="fib_dp">Fibonacci (DP)</option>
        </select>
        <label data-i18n="algo_b">Algorithm B:</label>
        <select id="algo-b">
          <option value="bubble" data-i18n="bubble_sort">Bubble Sort</option>
          <option value="quick" data-i18n="quick_sort">Quick Sort</option>
          <option value="merge" selected data-i18n="merge_sort">Merge Sort</option>
          <option value="insertion" data-i18n="insertion_sort">Insertion Sort</option>
          <option value="selection" data-i18n="selection_sort">Selection Sort</option>
          <option value="heap" data-i18n="heap_sort">Heap Sort</option>
          <option value="radix">Radix Sort</option>
          <option value="linear" data-i18n="linear_search">Linear Search</option>
          <option value="binary" data-i18n="binary_search">Binary Search</option>
          <option value="bst">BST Search</option>
          <option value="hashtable">Hash Table Search</option>
          <option value="access" data-i18n="array_access">Array Access O(1)</option>
          <option value="fib-recursive" data-i18n="fib_recursive">Fibonacci (Recursive)</option>
          <option value="fib-dp" data-i18n="fib_dp">Fibonacci (DP)</option>
        </select>
        <button onclick="runComplexityRace()" data-i18n="btn_start_race">Start Race</button>
        <button onclick="resetComplexity()" data-i18n="btn_reset">Reset</button>
      </div>
      <canvas id="complexity-canvas" width="1100" height="500"></canvas>
      <div class="info" id="complexity-info" data-i18n="complexity_info">Select algorithms and click "Start Race"</div>
      <div id="complexity-explanation" style="display:none; margin-top:20px; padding:20px; background:#1a1a2e; border-radius:12px;">
        <h3 id="complexity-title"></h3>
        <div class="python-code">
          <div class="code-header" data-i18n="py_heading">Python Implementation</div>
          <pre id="complexity-code"></pre>
        </div>
        <p id="complexity-desc"></p>
        <p><strong data-i18n="time_complexity_label">Time Complexity:</strong> <span id="time-complexity"></span></p>
        <p><strong data-i18n="space_complexity_label">Space Complexity:</strong> <span id="space-complexity"></span></p>
        <p style="margin-top:10px; border-top:1px solid #444; padding-top:10px;"><strong>Verdict:</strong> <span id="complexity-verdict"></span></p>
      </div>
    </div>

    <!-- ====================== ARRAYS ====================== -->
    <div id="arrays" class="section active">
      <h2 data-i18n="arrays_title">Dynamic Array Operations</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="arrays_desc">Dynamic arrays are resizable arrays that provide efficient random access and dynamic sizing. They automatically double in capacity when full to maintain amortized O(1) append operations. Key operations include access (O(1)), append/push (amortized O(1)), insert/delete at index (O(n) due to shifting), and search (O(n)). They are ideal for lists where size is unknown in advance, but frequent inserts/deletes in the middle can be costly due to element shifting.</p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
class DynamicArray:
    def __init__(self):
        self.array = []
        self.capacity = 4
        self.size = 0
    def push(self, value):
        if self.size == self.capacity:
            self._resize(self.capacity * 2)
        self.array.append(value)
        self.size += 1
    def pop(self):
        if self.size == 0:
            raise IndexError("Array is empty")
        value = self.array.pop()
        self.size -= 1
        return value
    def insert(self, index, value):
        if index < 0 or index > self.size:
            raise IndexError("Invalid index")
        if self.size == self.capacity:
            self._resize(self.capacity * 2)
        self.array.insert(index, value)
        self.size += 1
    def delete(self, index):
        if index < 0 or index >= self.size:
            raise IndexError("Invalid index")
        del self.array[index]
        self.size -= 1
    def unshift(self, value):
        self.insert(0, value)
    def shift(self):
        return self.delete(0)
    def search(self, value):
        try:
            return self.array.index(value)
        except ValueError:
            return -1
    def _resize(self, new_capacity):
        new_array = [None] * new_capacity
        for i in range(self.size):
            new_array[i] = self.array[i]
        self.array = new_array
        self.capacity = new_capacity
# Example usage
da = DynamicArray()
da.push(10)
da.push(20)
print(da.array)  # [10, 20]
da.insert(1, 15)
print(da.array)  # [10, 15, 20]
print(da.search(15))  # 1
</pre>
      </div>
      <div class="controls">
        <input type="text" id="array-input" value="10,5,8,3,9,1,15,7" style="flex:1" data-i18n-ph="ph_array_vals">
        <button onclick="loadArrayFromInput()" data-i18n="btn_load">Load</button>
        <button onclick="visualizeArray()" data-i18n="btn_refresh">Refresh</button>
      </div>
      <div class="controls">
        <input type="number" id="insert-val" data-i18n-ph="ph_value">
        <input type="number" id="insert-idx" data-i18n-ph="ph_index">
        <button onclick="insertAt()" data-i18n="btn_insert">Insert</button>
        <input type="number" id="delete-idx" data-i18n-ph="ph_index">
        <button onclick="deleteAt()" data-i18n="btn_delete">Delete</button>
        <input type="number" id="push-val" data-i18n-ph="ph_value">
        <button onclick="pushValue()" data-i18n="btn_push">Push</button>
        <button onclick="popValue()" data-i18n="btn_pop">Pop</button>
        <input type="number" id="unshift-val" data-i18n-ph="ph_value">
        <button onclick="unshiftValue()" data-i18n="btn_unshift">Unshift</button>
        <button onclick="shiftValue()" data-i18n="btn_shift">Shift</button>
        <input type="number" id="search-val" data-i18n-ph="ph_find">
        <button onclick="searchArraySearch()" data-i18n="btn_search">Search</button>
        <button onclick="clearArray()" data-i18n="btn_clear">Clear</button>
      </div>
      <canvas id="array-canvas" width="1100" height="380"></canvas>
      <div class="info" id="array-status" data-i18n="array_status">Array: [] | Length: 0</div>
    </div>

    <!-- ====================== SORTING ====================== -->
    <div id="sorting" class="section">
      <h2 data-i18n="sorting_title">Sorting Algorithms</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="sorting_desc">Sorting algorithms rearrange elements in ascending or descending order. <strong>Bubble Sort</strong> (O(n¬≤)) swaps adjacent elements repeatedly. <strong>Quick Sort</strong> (average O(n log n), worst O(n¬≤)) uses partitioning around a pivot. <strong>Merge Sort</strong> (O(n log n)) divides the array and merges sorted halves. These are fundamental for data organization, with trade-offs in stability, space, and time.
        </p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    merged = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged
# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(arr.copy()))  # [11, 12, 22, 25, 34, 64, 90]
print(quick_sort(arr.copy()))   # [11, 12, 22, 25, 34, 64, 90]
print(merge_sort(arr.copy()))   # [11, 12, 22, 25, 34, 64, 90]
</pre>
      </div>
      <div class="controls">
        <input type="text" id="sort-input" value="64,34,25,12,22,11,90,88,55" data-i18n-ph="ph_sort_vals">
        <select id="sort-algo">
          <option value="bubble" data-i18n="bubble_sort">Bubble Sort</option>
          <option value="quick" data-i18n="quick_sort">Quick Sort</option>
          <option value="merge" data-i18n="merge_sort">Merge Sort</option>
        </select>
        <button onclick="startSorting()" data-i18n="btn_start">Start</button>
        <button onclick="resetSorting()" data-i18n="btn_reset">Reset</button>
      </div>
      <canvas id="sort-canvas" width="1100" height="450"></canvas>
      <div class="info" id="sort-info" data-i18n="sort_steps">Steps: 0</div>
    </div>

    <!-- ====================== SEARCHING ====================== -->
    <div id="searching" class="section">
      <h2 data-i18n="searching_title">Search Algorithms</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="searching_desc">Search algorithms locate a target in a collection. <strong>Linear Search</strong> (O(n)) checks each element sequentially, suitable for unsorted data. <strong>Binary Search</strong> (O(log n)) halves the search interval on sorted data. <strong>Jump Search</strong> (O(‚àön)) skips blocks of size ‚àön, then performs linear search, offering a middle ground. <strong>Exponential Search</strong> (O(log n)) finds a range where the target exists using exponential steps, then performs Binary Search in that range. Both Jump and Exponential Search require the array to be sorted for efficient (sub-linear) operation.</p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
def linear_search(arr, target):
    for i, val in enumerate(arr):
        if val == target:
            return i
    return -1
def binary_search(arr, target):
    arr.sort()  # Prerequisite: array must be sorted
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
def jump_search(arr, target):
    arr.sort()  # Prerequisite: array must be sorted
    n = len(arr)
    step = int(n**0.5)
    prev = 0
    while arr[min(step, n)-1] < target:
        prev = step
        step += int(n**0.5)
        if prev >= n:
            return -1
    while arr[prev] < target:
        prev += 1
        if prev == min(step, n):
            return -1
    if arr[prev] == target:
        return prev
    return -1
# Helper for Exponential Search
def binary_search_recursive(arr, target, left, right):
    if left > right:
        return -1
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)
def exponential_search(arr, target):
    arr.sort()  # Prerequisite: array must be sorted
    if arr[0] == target:
        return 0
    i = 1
    while i < len(arr) and arr[i] <= target:
        i *= 2
    return binary_search_recursive(arr, target, i//2, min(i, len(arr)-1))
# Example usage
arr = [12, 5, 23, 8, 45, 3, 67, 19, 34, 91]
print(f"Linear search (34): {linear_search(arr, 34)}")
sorted_arr = sorted(arr)
print(f"Binary search (34): {binary_search(sorted_arr, 34)}")
print(f"Jump search (34): {jump_search(arr, 34)}")
print(f"Exponential search (34): {exponential_search(arr, 34)}")
</pre>
      </div>
      <div class="controls">
        <input type="text" id="search-input" value="12,5,23,8,45,3,67,19,34,91" data-i18n-ph="ph_search_vals">
        <button onclick="loadSearchArray()" data-i18n="btn_load">Load Array</button>
      </div>
      <div class="controls">
        <input type="number" id="target-val" value="34" data-i18n-ph="ph_target">
        <select id="search-algo">
          <option value="linear" data-i18n="linear_search">Linear Search</option>
          <option value="binary" data-i18n="binary_search">Binary Search</option>
          <option value="jump" data-i18n="jump_search">Jump Search</option>
          <option value="exponential" data-i18n="exponential_search">Exponential Search</option>
        </select>
        <button onclick="startSearch()" data-i18n="btn_start_search">Start Search</button>
        <button onclick="resetSearch()" data-i18n="btn_reset">Reset</button>
      </div>
      <div class="info" id="search-steps" data-i18n="search_steps">Steps: 0</div>
      <div class="info" id="search-result"></div>
      <canvas id="search-canvas" width="1100" height="380"></canvas>
    </div>

    <!-- ====================== BINARY TREE (BT) ====================== -->
    <div id="bt" class="section">
      <h2 data-i18n="bt_title">Binary Tree (Complete BT)</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="bt_desc">A <strong>Binary Tree</strong> is a tree data structure where each node has at most two children (left and right). This implementation uses <strong>level-order insertion</strong> to create a <strong>Complete Binary Tree</strong> (all levels filled left to right). Traversals include <strong>In-order</strong>, <strong>Pre-order</strong>, and <strong>Post-order</strong>.
        </p>
        <p><strong data-i18n="time_complexity_label">Time Complexity:</strong> <span data-i18n="bt_time">Insert: O(1), Traversal: O(n)</span></p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation (Array Representation)</div>
        <pre>
class BinaryTree:
    def __init__(self):
        self.tree = []
    def insert(self, value):
        # Level-order insertion for Complete BT
        self.tree.append(value)
    def get_parent(self, i):
        return self.tree[(i - 1) // 2] if i > 0 else None
    def get_children(self, i):
        left_idx = 2 * i + 1
        right_idx = 2 * i + 2
        left = self.tree[left_idx] if left_idx < len(self.tree) else None
        right = self.tree[right_idx] if right_idx < len(self.tree) else None
        return left, right
# Example usage
bt = BinaryTree()
for val in [10, 5, 15, 3, 7, 12, 18]:
    bt.insert(val)
print(bt.tree)  # [10, 5, 15, 3, 7, 12, 18]
</pre>
      </div>
      <div class="controls">
        <input type="text" id="bt-input" value="10,5,15,3,7,12,18,1,9" data-i18n-ph="ph_bt_vals">
        <button onclick="buildBT()" data-i18n="btn_build_tree">Build Tree</button>
        <button onclick="traverseBT('inorder')" data-i18n="btn_inorder">In-order</button>
        <button onclick="traverseBT('preorder')" data-i18n="btn_preorder">Pre-order</button>
        <button onclick="traverseBT('postorder')" data-i18n="btn_postorder">Post-order</button>
        <button onclick="clearBT()" data-i18n="btn_clear">Clear</button>
      </div>
      <canvas id="bt-canvas" width="1100" height="600"></canvas>
      <div class="info" id="bt-traversal-output"></div>
    </div>

    <!-- ====================== BST ====================== -->
    <div id="bst" class="section">
      <h2 data-i18n="bst_title">Binary Search Tree (BST)</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="bst_desc">A <strong>Binary Search Tree (BST)</strong> is a binary tree where each node's left subtree has values less than the node, and right has greater. It supports efficient search, insert, and delete (average O(log n), worst O(n) if unbalanced). Traversals include <strong>in-order</strong> (sorted), <strong>pre-order</strong>, and <strong>post-order</strong>.
        </p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
class BST:
    def __init__(self):
        self.root = None
    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert(self.root, val)
    def _insert(self, node, val):
        if val < node.val:
            if node.left is None:
                node.left = TreeNode(val)
            else:
                self._insert(node.left, val)
        elif val > node.val:
            if node.right is None:
                node.right = TreeNode(val)
            else:
                self._insert(node.right, val)
    # Inorder traversal (returns sorted array)
    def inorder(self, node):
        res = []
        if node:
            res.extend(self.inorder(node.left))
            res.append(node.val)
            res.extend(self.inorder(node.right))
        return res
# Example usage
bst = BST()
for val in [50, 30, 70, 20, 40, 60, 80]:
    bst.insert(val)
print(bst.inorder(bst.root))  # [20, 30, 40, 50, 60, 70, 80]
</pre>
      </div>
      <div class="controls">
        <input type="text" id="bst-input" value="50,30,70,20,40,60,80,90,10" data-i18n-ph="ph_bst_vals">
        <button onclick="buildBST()" data-i18n="btn_build_bst">Build BST</button>
        <button onclick="traverseBST('inorder')" data-i18n="btn_inorder">In-order</button>
        <button onclick="traverseBST('preorder')" data-i18n="btn_preorder">Pre-order</button>
        <button onclick="traverseBST('postorder')" data-i18n="btn_postorder">Post-order</button>
      </div>
      <canvas id="bst-canvas" width="1100" height="600"></canvas>
      <div class="info" id="bst-traversal-output"></div>
    </div>

    <!-- ====================== AVL TREE ====================== -->
    <div id="avl" class="section">
      <h2 data-i18n="avl_title">AVL Tree (Self-Balancing BST)</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="avl_desc">An <strong>AVL Tree</strong> is a self-balancing Binary Search Tree where the height difference (balance factor) between the left and right subtrees of any node is at most 1. This strict balance ensures that search, insert, and delete operations maintain an optimal time complexity of O(log n) even in the worst-case scenario, unlike a regular BST which can degenerate to O(n).</p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation (Simplified)</div>
        <pre>
class AVLNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1
class AVLTree:
    def get_height(self, node):
        return node.height if node else 0
    def get_balance(self, node):
        if not node:
            return 0
        return self.get_height(node.left) - self.get_height(node.right)
    def right_rotate(self, y):
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        # Update heights
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        return x  # new root
    def left_rotate(self, x):
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        # Update heights
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        return y  # new root
    def insert(self, root, val):
        if not root:
            return AVLNode(val)
        if val < root.val:
            root.left = self.insert(root.left, val)
        elif val > root.val:
            root.right = self.insert(root.right, val)
        else:
            return root
        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))
        balance = self.get_balance(root)
        # Left Left Case
        if balance > 1 and val < root.left.val:
            return self.right_rotate(root)
        # Right Right Case
        if balance < -1 and val > root.right.val:
            return self.left_rotate(root)
        # Left Right Case
        if balance > 1 and val > root.left.val:
            root.left = self.left_rotate(root.left)
            return self.right_rotate(root)
        # Right Left Case
        if balance < -1 and val < root.right.val:
            root.right = self.right_rotate(root.right)
            return self.left_rotate(root)
        return root
</pre>
      </div>
      <div class="controls">
        <input type="number" id="avl-insert-val" data-i18n-ph="ph_avl_val">
        <button onclick="insertAVL()" data-i18n="btn_insert_value">Insert Value</button>
        <input type="text" id="avl-input" value="10,20,30,40,50,25" data-i18n-ph="ph_avl_vals">
        <button onclick="buildAVL()" data-i18n="btn_build">Build Tree</button>
        <button onclick="clearAVL()" data-i18n="btn_clear">Clear</button>
      </div>
      <canvas id="avl-canvas" width="1100" height="600"></canvas>
    </div>

    <!-- ====================== TRIE ====================== -->
    <div id="trie" class="section">
      <h2 data-i18n="trie_title">Trie (Prefix Tree)</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="trie_desc">A <strong>Trie</strong>, or Prefix Tree, is an efficient data structure for storing and searching a dynamic set of strings. It organizes strings based on shared prefixes. Search and insertion are typically O(L), where L is the length of the string, making it much faster than BSTs for strings. Tries are used for auto-complete, spell checkers, and IP routing. Each node stores a map to its children (characters), and a boolean flag marks the end of a word.</p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False
class Trie:
    def __init__(self):
        self.root = TrieNode()
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True
    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word
    def starts_with(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
# Example usage
trie = Trie()
trie.insert("apple")
trie.insert("apply")
trie.insert("app")
print(trie.search("apple"))   # True
print(trie.starts_with("app"))  # True
print(trie.search("banana"))  # False
</pre>
      </div>
      <div class="controls">
        <input type="text" id="trie-insert-word" data-i18n-ph="ph_trie_insert">
        <button onclick="insertTrieWord()" data-i18n="btn_insert">Insert Word</button>
        <input type="text" id="trie-input" value="car,cat,cab,dog,dot" data-i18n-ph="ph_trie_vals">
        <button onclick="buildTrie()" data-i18n="btn_build">Build Trie</button>
        <input type="text" id="trie-search-word" data-i18n-ph="ph_trie_search">
        <button onclick="searchTrieWord()" data-i18n="btn_search_prefix">Search/Prefix</button>
        <button onclick="clearTrie()" data-i18n="btn_clear">Clear</button>
      </div>
      <canvas id="trie-canvas" width="1100" height="500"></canvas>
      <div class="info" id="trie-status" data-i18n="trie_status">Trie is empty.</div>
    </div>

    <!-- ====================== HEAPS & HEAP SORT ====================== -->
    <div id="heaps" class="section">
      <h2 data-i18n="heaps_title">Heaps & Heap Sort</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="heaps_desc"><strong>Heaps</strong> are complete binary trees satisfying the heap property:</p>
        <ul style="margin-top:10px; padding-left:20px;">
          <li><strong data-i18n="min_heap">Min-Heap</strong>: <span data-i18n="min_heap_desc">Parent ‚â§ children (smallest at root)</span></li>
          <li><strong data-i18n="max_heap">Max-Heap</strong>: <span data-i18n="max_heap_desc">Parent ‚â• children (largest at root)</span></li>
        </ul>
        <p><strong data-i18n="heap_sort">Heap Sort</strong> <span data-i18n="heap_sort_desc">uses a max-heap to sort an array in O(n log n) time:</span></p>
        <ol style="margin-top:10px; padding-left:20px;">
          <li data-i18n="heap_step1">Build a max-heap from the array</li>
          <li data-i18n="heap_step2">Repeatedly extract the max element and place it at the end</li>
          <li data-i18n="heap_step3">Reduce heap size and heapify the root</li>
        </ol>
        <p><strong data-i18n="time_complexity_label">Time Complexity:</strong> <span data-i18n="heap_time">Heapify: O(log n), Build Heap: O(n), Heap Sort: O(n log n)</span></p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
import heapq
# Min-Heap
min_heap = [3, 1, 4]
heapq.heapify(min_heap)  # [1, 3, 4]
# Max-Heap (using negatives)
max_heap = [-x for x in [3, 1, 4]]
heapq.heapify(max_heap)  # [-4, -1, -3]
# Heap Sort
def heap_sort(arr):
    # Build max-heap
    heapq._heapify_max(arr)
    # Extract elements
    for i in range(len(arr)-1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]  # Move max to end
        heapq._siftdown_max(arr, 0, i)   # Restore heap (size = i)
    return arr
# Example
arr = [3, 1, 4, 1, 5]
print(heap_sort(arr.copy()))  # [1, 1, 3, 4, 5]
</pre>
      </div>
      <div class="controls">
        <select id="heap-type" onchange="updateHeapType(this.value)">
          <option value="min" data-i18n="min_heap">Min-Heap</option>
          <option value="max" data-i18n="max_heap">Max-Heap</option>
          <option value="sort" data-i18n="heap_sort">Heap Sort</option>
        </select>
        <input type="text" id="heap-input" data-i18n-ph="ph_heap_vals" value="3,1,4,1,5">
        <button onclick="loadHeap()" data-i18n="btn_load">Load Data</button>
        <input type="number" id="heap-size" value="10" data-i18n-ph="ph_heap_size">
        <button onclick="randomHeap()" data-i18n="btn_random">Random Data</button>
        <button onclick="runHeapSort()" data-i18n="btn_run">Run Heap Sort</button>
        <button onclick="resetHeap()" data-i18n="btn_reset">Reset</button>
      </div>
      <canvas id="heap-canvas" width="1100" height="500"></canvas>
      <div class="info" id="heap-info" data-i18n="heap_info">Select heap type and load data</div>
    </div>

    <!-- ====================== GRAPHS ====================== -->
    <div id="graphs" class="section">
      <h2 data-i18n="graphs_title">Graph Traversal</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="graphs_desc">Graphs consist of nodes and edges. <strong>BFS</strong> (Breadth-First Search) explores level-by-level using a queue (O(V+E)), good for shortest paths in unweighted graphs. <strong>DFS</strong> (Depth-First Search) explores deeply using recursion (O(V+E)), useful for cycles or topological sort.
        </p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
from collections import deque
graph = {
    0: [1, 3],
    1: [0, 2, 4],
    2: [1, 5],
    3: [0, 4],
    4: [1, 3, 5],
    5: [2, 4]
}
def bfs(start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    while queue:
        node = queue.popleft()
        print(node, end=' ')
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
def dfs(node, visited=None):
    if visited is None:
        visited = set()
    visited.add(node)
    print(node, end=' ')
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(neighbor, visited)
# Example usage
print("BFS:", end=' ')
bfs(0)  # 0 1 3 2 4 5
print("
DFS:", end=' ')
dfs(0)  # 0 1 2 5 4 3
</pre>
      </div>
      <div class="controls">
        <button onclick="runBFS()" data-i18n="btn_bfs">BFS</button>
        <button onclick="runDFS()" data-i18n="btn_dfs">DFS</button>
      </div>
      <canvas id="graph-canvas" width="1100" height="500"></canvas>
    </div>

    <!-- ====================== BELLMAN-FORD ====================== -->
    <div id="bellman" class="section">
      <h2 data-i18n="bellman_title">Bellman-Ford Algorithm</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="bellman_desc"><strong>Bellman-Ford</strong> computes shortest paths from a source in graphs with negative weights (O(VE)). It relaxes all edges V-1 times and detects negative cycles. Unlike Dijkstra, it handles negatives but is slower.</p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
def bellman_ford(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    for _ in range(len(graph) - 1):
        for u in graph:
            for v, weight in graph[u].items():
                if dist[u] + weight < dist[v]:
                    dist[v] = dist[u] + weight
    # Check for negative cycles
    for u in graph:
        for v, weight in graph[u].items():
            if dist[u] + weight < dist[v]:
                raise ValueError("Negative cycle detected")
    return dist
# Example graph (dict of dicts)
graph = {
    0: {1: 4, 3: 5},
    1: {2: 3},
    3: {1: -6, 2: 2},
    2: {}
}
print(bellman_ford(graph, 0))  # {0: 0, 1: -1, 2: 1, 3: 5}
</pre>
      </div>
      <button onclick="runBellmanFord()" data-i18n="btn_run">Run</button>
      <canvas id="bellman-canvas" width="1100" height="500"></canvas>
      <div class="info" id="bellman-output"></div>
    </div>

    <!-- ====================== DIJKSTRA ====================== -->
    <div id="dijkstra" class="section">
      <h2 data-i18n="dijkstra_title">Dijkstra's Algorithm</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="dijkstra_desc"><strong>Dijkstra</strong> finds shortest paths from a source in graphs with non-negative weights (O((V+E) log V) with priority queue). It uses a greedy approach, selecting the closest unvisited node each time.</p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
import heapq
def dijkstra(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]
    while pq:
        current_dist, u = heapq.heappop(pq)
        if current_dist > dist[u]:
            continue
        for v, weight in graph[u].items():
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(pq, (dist[v], v))
    return dist
# Example graph
graph = {
    0: {1: 4, 3: 2},
    1: {2: 3},
    3: {1: 1, 2: 5},
    2: {}
}
print(dijkstra(graph, 0))  # {0: 0, 1: 3, 2: 6, 3: 2}
</pre>
      </div>
      <div class="controls">
        <select id="graph-dir">
          <option value="directed" data-i18n="directed">Directed</option>
          <option value="undirected" data-i18n="undirected">Undirected</option>
        </select>
        <input type="text" id="graph-edges" value="0-1:4,0-3:2,1-2:3,3-1:1,3-2:5" style="flex:1" data-i18n-ph="ph_graph_edges">
        <input type="number" id="dijkstra-start" value="0" data-i18n-ph="ph_start">
        <input type="number" id="dijkstra-end" value="2" data-i18n-ph="ph_end">
        <button onclick="loadDijkstraGraph(); runDijkstra();" data-i18n="btn_load_run">Load & Run</button>
      </div>
      <canvas id="dijkstra-canvas" width="1100" height="500"></canvas>
      <div class="info" id="dijkstra-output"></div>
    </div>

    <!-- ====================== A* ====================== -->
    <div id="astar" class="section">
      <h2 data-i18n="astar_title">A* Pathfinding</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="astar_desc"><strong>A*</strong> is an informed search algorithm for pathfinding, combining Dijkstra's shortest path with greedy best-first search using heuristics (e.g., Manhattan distance). It's optimal with admissible heuristics, efficient for grids/maps (time varies, worst exponential).</p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
import heapq
def a_star(grid, start, goal):
    def heuristic(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal)}
    while open_set:
        _, current = heapq.heappop(open_set)
        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = (current[0] + dx, current[1] + dy)
            if (0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0])
                and grid[neighbor[0]][neighbor[1]] != 1):  # Not wall
                tentative_g = g_score[current] + 1
                if tentative_g < g_score.get(neighbor, float('inf')):
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + heuristic(neighbor, goal)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
    return None  # No path
# Example grid (0: open, 1: wall)
grid = [[0, 0, 0], [1, 0, 1], [0, 0, 0]]
print(a_star(grid, (0, 0), (2, 2)))  # Path like [(0,0), (0,1), (1,1), (2,1), (2,2)]
</pre>
      </div>
      <div class="controls">
        <button onclick="runAstar()" data-i18n="btn_find_path">Find Path</button>
        <button onclick="clearGrid()" data-i18n="btn_clear_walls">Clear Walls</button>
        <span data-i18n="speed_label">Speed:</span> <input type="range" id="astar-speed" min="1" max="100" value="50">
      </div>
      <canvas id="astar-canvas" width="900" height="540"></canvas>
    </div>

    <!-- ====================== RECURSION ====================== -->
    <div id="recursion" class="section">
      <h2 data-i18n="recursion_title">Towers of Hanoi (Recursion)</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="recursion_desc"><strong>Towers of Hanoi</strong> is a classic recursion problem: move n disks from peg A to C using B as auxiliary, without placing larger disks on smaller. It demonstrates divide-and-conquer, with 2^n - 1 moves. Recursion depth is n, time O(2^n).</p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
def hanoi(n, from_peg, to_peg, aux_peg):
    if n == 1:
        print(f"Move disk 1 from {from_peg} to {to_peg}")
        return
    hanoi(n-1, from_peg, aux_peg, to_peg)
    print(f"Move disk {n} from {from_peg} to {to_peg}")
    hanoi(n-1, aux_peg, to_peg, from_peg)
# Example usage
hanoi(3, 'A', 'C', 'B')
# Output:
# Move disk 1 from A to C
# Move disk 2 from A to B
# Move disk 1 from C to B
# Move disk 3 from A to C
# Move disk 1 from B to A
# Move disk 2 from B to C
# Move disk 1 from A to C
</pre>
      </div>
      <div class="controls">
        <span data-i18n="disks_label">Disks:</span> <input type="range" id="hanoi-disks" min="3" max="8" value="4">
        <button onclick="solveHanoi()" data-i18n="btn_solve">Solve</button>
      </div>
      <canvas id="hanoi-canvas" width="1100" height="450"></canvas>
    </div>

    <!-- ====================== LINKED LIST (SANDBOX MODE) ====================== -->
    <div id="linkedlist" class="section">
      <h2 data-i18n="linkedlist_title">Linked List Sandbox Mode</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="linkedlist_desc">A <strong>Linked List</strong> is a linear data structure where each element (node) contains data and a pointer to the next node. Unlike arrays, it doesn't require contiguous memory allocation, allowing dynamic size adjustment. This sandbox supports <strong>Singly</strong>, <strong>Doubly</strong>, and <strong>Circular</strong> variants with animated traversal and step-by-step debugging.</p>
        
        <div id="mode-explanation" style="margin-top:16px; padding:16px; background:#1a1a2e; border-radius:10px; border-left:4px solid #82d8ff;">
          <!-- Dynamically updated based on selected mode -->
        </div>

        <div class="python-code" id="mode-python-code" style="margin-top:16px;">
          <div class="code-header" data-i18n="py_heading">Python Implementation</div>
          <pre id="python-code-content"></pre>
        </div>

        <p><strong data-i18n="time_complexity_label">Time Complexity:</strong> <span data-i18n="linkedlist_time">Access: O(n), Search: O(n), Insertion: O(1) at head / O(n) elsewhere, Deletion: O(1) at head / O(n) elsewhere.</span></p>
      </div>

      <div class="wrap">
        <div class="panel">
          <div class="row">
            <label>Mode:</label>
            <select id="mode">
              <option value="singly">Singly Linked List</option>
              <option value="doubly">Doubly Linked List</option>
              <option value="circular">Circular Singly Linked List</option>
            </select>

            <span class="pill" id="stats">Size: 0</span>
            <span class="pill" id="headTail">Head: - | Tail: -</span>

            <label style="margin-left:6px;">Execution:</label>
            <select id="execMode">
              <option value="instant">Instant Mode</option>
              <option value="step">Step Mode</option>
            </select>

            <span class="pill" id="stepPill">Steps: 0</span>
          </div>

          <div class="row">
            <label>Build (CSV):</label>
            <input id="buildInput" placeholder="e.g. 10, 20, 30" />
            <button id="buildBtn" class="good">Build</button>
            <button id="clearBtn" class="bad">Clear List</button>
            <button id="validateBtn" class="accent">Validate</button>
          </div>

          <div class="row">
            <label>Value:</label>
            <input id="valueInput" placeholder="e.g. 99" />
            <label>Index:</label>
            <input id="indexInput" type="number" min="0" placeholder="e.g. 2" />

            <button id="insHead">Insert Head</button>
            <button id="insTail">Insert Tail</button>
            <button id="insIndex">Insert @Index</button>

            <button id="delVal" class="bad">Delete Value</button>
            <button id="delIndex" class="bad">Delete @Index</button>

            <button id="searchVal" class="warn">Search (Animated)</button>
            <button id="stopAnim" class="bad" disabled>Stop</button>
          </div>

          <div class="row">
            <div class="rangeWrap">
              <label class="mono">Speed:</label>
              <input id="speed" type="range" min="200" max="1200" step="50" value="600" />
              <span class="pill mono" id="speedLabel">600ms</span>
            </div>

            <button id="nextStep" class="accent" disabled>Next Step</button>
            <button id="resetSteps" class="bad" disabled>Reset Steps</button>

            <div class="status" id="statusLine">Ready.</div>
          </div>

          <div class="hint">
            ‚Ä¢ <b>Search</b> traverses from <span class="mono">head</span> following <span class="mono">next</span> pointers.  
            ‚Ä¢ Circular stops when it returns to head (or after size steps).  
            ‚Ä¢ In <b>Step Mode</b>, operations generate steps ‚Üí use ‚ÄúNext Step‚Äù.
          </div>
        </div>

        <div class="panel">
          <div class="canvas">
            <div class="list" id="listView"></div>
          </div>
        </div>

        <div class="panel split">
          <div>
            <div class="row" style="justify-content:space-between;">
              <h3 style="margin:0;">Operation Log</h3>
              <button id="clearLog">Clear Log</button>
            </div>
            <div class="log" id="logBox" style="margin-top:10px;"></div>
          </div>
          <div>
            <div class="row" style="justify-content:space-between;">
              <h3 style="margin:0;">Integrity Check</h3>
              <span class="pill mono" id="integrityPill">OK</span>
            </div>
            <div class="log" id="integrityBox" style="margin-top:10px; max-height:170px;"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- ====================== HASH TABLE ====================== -->
    <div id="hashtable" class="section">
      <h2 data-i18n="hashtable_title">Hash Table (Chaining)</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="hashtable_desc">A <strong>Hash Table</strong> maps keys to values using a hash function. Collisions (when two keys hash to the same index) are resolved via chaining‚Äîeach bucket holds a linked list of key-value pairs. Average-case time complexity for insert, search, and delete is O(1); worst-case is O(n) if all keys collide. Used in dictionaries, caches, database indexing, and more.</p>
        <p><strong data-i18n="time_complexity_label">Time Complexity:</strong> <span data-i18n="hashtable_time">Average: O(1), Worst: O(n). Space: O(n).</span></p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]
    def _hash(self, key):
        return hash(key) % self.size
    def put(self, key, value):
        idx = self._hash(key)
        bucket = self.table[idx]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        bucket.append((key, value))
    def get(self, key):
        idx = self._hash(key)
        bucket = self.table[idx]
        for k, v in bucket:
            if k == key:
                return v
        raise KeyError(key)
    def remove(self, key):
        idx = self._hash(key)
        bucket = self.table[idx]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                return
        raise KeyError(key)
# Example usage
ht = HashTable()
ht.put("apple", 5)
ht.put("banana", 10)
print(ht.get("apple"))  # 5
ht.put("apple", 7)
print(ht.get("apple"))  # 7
ht.remove("banana")
</pre>
      </div>
      <div class="controls">
        <input type="text" id="ht-key" data-i18n-ph="ph_ht_key">
        <input type="text" id="ht-value" data-i18n-ph="ph_ht_value">
        <button onclick="htPut()" data-i18n="btn_insert_update">Insert/Update</button>
        <button onclick="htGet()" data-i18n="btn_get">Get</button>
        <button onclick="htRemove()" data-i18n="btn_remove">Remove</button>
        <button onclick="htClear()" data-i18n="btn_clear_table">Clear Table</button>
      </div>
      <canvas id="ht-canvas" width="1100" height="400"></canvas>
      <div class="info" id="ht-status" data-i18n="ht_status">Table empty</div>
    </div>

    <!-- ====================== TOPOLOGICAL SORT (ENHANCED) ====================== -->
    <div id="toposort" class="section">
      <h2 data-i18n="toposort_title">Topological Sort Sandbox</h2>
      
      <div class="details">
        <h3 data-i18n="details_heading">What is Topological Sort?</h3>
        <p id="topo-desc">
          <!-- Dynamically updated based on language -->
        </p>
        
        <div class="python-code" style="margin-top:15px;">
          <div class="code-header" data-i18n="py_heading">Python Implementation (Kahn's Algorithm)</div>
          <pre id="topo-python-code">
from collections import deque

def topological_sort(edges, n):
    # Build adjacency list and in-degree array
    graph = [[] for _ in range(n)]
    in_degree = [0] * n
    
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    # Initialize queue with nodes having in-degree 0
    queue = deque()
    for i in range(n):
        if in_degree[i] == 0:
            queue.append(i)
    
    result = []
    while queue:
        u = queue.popleft()
        result.append(u)
        
        # Reduce in-degree of neighbors
        for v in graph[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
    
    # If result doesn't contain all nodes ‚Üí cycle exists
    return result if len(result) == n else []
          </pre>
        </div>
      </div>

      <div class="panel" style="margin-top:20px;">
        <div class="row" style="flex-wrap:wrap; gap:12px;">
          <div style="flex:1; min-width:200px;">
            <label><strong data-i18n="num_nodes">Number of Nodes:</strong></label>
            <input type="number" id="topo-nodes" value="5" min="1" max="10" style="width:100%; padding:10px; font-size:16px;">
          </div>
          
          <div style="flex:2; min-width:300px;">
            <label><strong data-i18n="edges_label">Add Edges (u‚Üív):</strong></label>
            <div style="display:flex; gap:8px;">
              <input type="number" id="edge-from" placeholder="From" min="0" style="flex:1; padding:10px;">
              <span style="align-self:center; font-size:24px;">‚Üí</span>
              <input type="number" id="edge-to" placeholder="To" min="0" style="flex:1; padding:10px;">
              <button id="add-edge" class="good" style="padding:10px 16px;">+</button>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:15px; flex-wrap:wrap; gap:12px;">
          <button id="run-topo" class="accent" style="padding:12px 24px; font-size:16px;">
            <span data-i18n="btn_run_topo">Run Topological Sort</span>
          </button>
          <button id="clear-edges" class="bad" style="padding:12px 24px; font-size:16px;">
            <span data-i18n="btn_clear_edges">Clear Edges</span>
          </button>
          <button id="random-graph" style="padding:12px 24px; font-size:16px; background:#6a5acd; border-color:#7a6add;">
            <span data-i18n="btn_random_graph">Random DAG</span>
          </button>
        </div>

        <div class="row" style="margin-top:15px; padding:12px; background:#1a1a2e; border-radius:8px;">
          <div style="display:flex; flex-wrap:wrap; gap:15px; flex:1;">
            <div>
              <strong data-i18n="current_edges">Current Edges:</strong>
              <div id="edge-list" style="margin-top:5px; min-height:24px; font-family:monospace;"></div>
            </div>
            <div>
              <strong data-i18n="in_degree">In-Degree:</strong>
              <div id="in-degree-display" style="margin-top:5px; min-height:24px; font-family:monospace;"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel" style="margin-top:20px;">
        <canvas id="topo-canvas" width="1100" height="500" style="background:#0b1021; border-radius:12px;"></canvas>
      </div>

      <div class="panel" style="margin-top:20px;">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <h3 style="margin:0;" data-i18n="result_heading">Result</h3>
          <div id="topo-status" style="font-weight:bold; padding:8px 16px; border-radius:8px;"></div>
        </div>
        <div id="topo-result" style="margin-top:15px; padding:15px; background:#1a1a2e; border-radius:8px; min-height:60px; font-size:18px; font-family:monospace;"></div>
      </div>

      <div class="panel" style="margin-top:20px; background:#16213e; border-left:4px solid #f5d06f;">
        <h3 style="margin:0 0 15px 0; color:#f5d06f;" data-i18n="instructions">How to Use</h3>
        <ol style="padding-left:20px; line-height:1.6;">
          <li data-i18n="instr1">Set the number of nodes (1-10)</li>
          <li data-i18n="instr2">Add directed edges using "From ‚Üí To"</li>
          <li data-i18n="instr3">Click "Run Topological Sort" to see step-by-step execution</li>
          <li data-i18n="instr4">Green nodes = processed, Yellow = in queue, Red = cycle detected</li>
          <li data-i18n="instr5">Use "Random DAG" for a valid example or "Clear Edges" to reset</li>
        </ol>
      </div>
    </div>

    <!-- ====================== KRUSKAL'S MST (ENHANCED) ====================== -->
    <div id="kruskal" class="section">
      <h2 data-i18n="kruskal_title">Kruskal's Minimum Spanning Tree</h2>
      
      <div class="details">
        <h3 data-i18n="details_heading">What is Kruskal's Algorithm?</h3>
        <p id="kruskal-desc">
          <!-- Dynamically updated based on language -->
        </p>
        
        <div class="python-code" style="margin-top:15px;">
          <div class="code-header" data-i18n="py_heading">Python Implementation</div>
          <pre id="kruskal-python-code">
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]
    
    def union(self, x, y):
        rootX, rootY = self.find(x), self.find(y)
        if rootX == rootY:
            return False  # Cycle detected!
        # Union by rank
        if self.rank[rootX] < self.rank[rootY]:
            self.parent[rootX] = rootY
        elif self.rank[rootX] > self.rank[rootY]:
            self.parent[rootY] = rootX
        else:
            self.parent[rootY] = rootX
            self.rank[rootX] += 1
        return True

def kruskal(edges, n):
    # Sort edges by weight
    edges.sort(key=lambda x: x[2])
    uf = UnionFind(n)
    mst = []
    for u, v, w in edges:
        if uf.union(u, v):  # Only add if no cycle
            mst.append((u, v, w))
        if len(mst) == n - 1:
            break
    return mst if len(mst) == n - 1 else []  # Empty if disconnected
          </pre>
        </div>
      </div>

      <div class="panel" style="margin-top:20px;">
        <div class="row" style="flex-wrap:wrap; gap:12px;">
          <div style="flex:1; min-width:200px;">
            <label><strong data-i18n="num_nodes">Number of Nodes:</strong></label>
            <input type="number" id="kruskal-nodes" value="4" min="2" max="10" style="width:100%; padding:10px; font-size:16px;">
          </div>
          
          <div style="flex:2; min-width:300px;">
            <label><strong data-i18n="add_edge_label">Add Edge (u‚Äìv : weight):</strong></label>
            <div style="display:flex; gap:8px;">
              <input type="number" id="edge-u" placeholder="u" min="0" style="flex:1; padding:10px;">
              <span style="align-self:center;">‚Äì</span>
              <input type="number" id="edge-v" placeholder="v" min="0" style="flex:1; padding:10px;">
              <span style="align-self:center;">:</span>
              <input type="number" id="edge-w" placeholder="w" min="1" step="0.1" style="flex:1; padding:10px;">
              <button id="add-kruskal-edge" class="good" style="padding:10px 16px;">+</button>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:15px; flex-wrap:wrap; gap:12px;">
          <button id="run-kruskal" class="accent" style="padding:12px 24px; font-size:16px;">
            <span data-i18n="btn_run_kruskal">Run Kruskal's Algorithm</span>
          </button>
          <button id="clear-kruskal-edges" class="bad" style="padding:12px 24px; font-size:16px;">
            <span data-i18n="btn_clear_edges">Clear Edges</span>
          </button>
          <button id="random-mst" style="padding:12px 24px; font-size:16px; background:#6a5acd; border-color:#7a6add;">
            <span data-i18n="btn_random_graph">Random Connected Graph</span>
          </button>
        </div>

        <div class="row" style="margin-top:15px; padding:12px; background:#1a1a2e; border-radius:8px;">
          <div style="display:flex; flex-wrap:wrap; gap:15px; flex:1;">
            <div>
              <strong data-i18n="current_edges">Current Edges:</strong>
              <div id="kruskal-edge-list" style="margin-top:5px; min-height:24px; font-family:monospace;"></div>
            </div>
            <div>
              <strong data-i18n="mst_status">MST Status:</strong>
              <div id="mst-status" style="margin-top:5px; min-height:24px; font-family:monospace; color:#0f0;"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel" style="margin-top:20px;">
        <canvas id="kruskal-canvas" width="1100" height="500" style="background:#0b1021; border-radius:12px;"></canvas>
      </div>

      <div class="panel" style="margin-top:20px;">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <h3 style="margin:0;" data-i18n="result_heading">Result</h3>
          <div id="kruskal-status" style="font-weight:bold; padding:8px 16px; border-radius:8px;"></div>
        </div>
        <div id="kruskal-result" style="margin-top:15px; padding:15px; background:#1a1a2e; border-radius:8px; min-height:60px; font-size:18px; font-family:monospace;"></div>
      </div>

      <div class="panel" style="margin-top:20px; background:#16213e; border-left:4px solid #f5d06f;">
        <h3 style="margin:0 0 15px 0; color:#f5d06f;" data-i18n="instructions">How to Use</h3>
        <ol style="padding-left:20px; line-height:1.6;">
          <li data-i18n="kruskal_instr1">Set number of nodes (2‚Äì10)</li>
          <li data-i18n="kruskal_instr2">Add weighted edges using "u ‚Äì v : weight"</li>
          <li data-i18n="kruskal_instr3">Click "Run Kruskal's" to see step-by-step MST construction</li>
          <li data-i18n="kruskal_instr4">Green edges = in MST, Gray = skipped (would form cycle)</li>
          <li data-i18n="kruskal_instr5">Use "Random Connected Graph" for a valid example</li>
        </ol>
      </div>
    </div>

    <!-- ====================== FLOYD-WARSHALL ====================== -->
    <div id="floyd" class="section">
      <h2 data-i18n="floyd_title">Floyd-Warshall (All-Pairs Shortest Path)</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="floyd_desc"><strong>Floyd-Warshall</strong> computes shortest paths between all pairs of vertices in a weighted graph (including negative weights, but not negative cycles). It uses dynamic programming with three nested loops. Time: O(V¬≥). Useful when you need all shortest paths, not just from one source.</p>
        <p><strong data-i18n="time_complexity_label">Time Complexity:</strong> <span data-i18n="floyd_time">O(V¬≥). <strong data-i18n="space_label">Space:</strong> O(V¬≤).</span></p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="py_heading">Python Implementation</div>
        <pre>
def floyd_warshall(graph):
    n = len(graph)
    dist = [[float('inf')] * n for _ in range(n)]
    for i in range(n):
        dist[i][i] = 0
    for u in graph:
        for v, w in graph[u].items():
            dist[u][v] = w
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    return dist
# Example usage
graph = {
    0: {1: 3, 2: 8},
    1: {2: -4},
    2: {3: 1},
    3: {0: 2}
}
print(floyd_warshall(graph))
</pre>
      </div>
      <div class="controls">
        <input type="text" id="floyd-edges" value="0-1:3,0-2:8,1-2:-4,2-3:1,3-0:2" data-i18n-ph="ph_floyd_edges">
        <input type="number" id="floyd-nodes" value="4" data-i18n-ph="ph_floyd_nodes">
        <button onclick="runFloyd()" data-i18n="btn_run_floyd">Run Floyd-Warshall</button>
      </div>
      <canvas id="floyd-canvas" width="1100" height="300"></canvas>
      <div class="info" id="floyd-result"></div>
    </div>

    <!-- ====================== SLIDING WINDOW ====================== -->
    <div id="sliding" class="section">
      <h2 data-i18n="sliding_title">Sliding Window Technique</h2>
      <div class="details">
        <h3 data-i18n="details_heading">Details</h3>
        <p data-i18n="sliding_desc">The <strong>Sliding Window</strong> technique optimizes array/string problems by maintaining a "window" (subarray) that satisfies given constraints. Instead of recalculating everything for each subarray, it adjusts the window by moving the start/end pointers. Common applications: max sum of subarray of size k, longest substring without repeating characters. Time: O(n).</p>
        <p><strong data-i18n="time_complexity_label">Time Complexity:</strong> <span data-i18n="sliding_time">O(n). <strong data-i18n="space_label">Space:</strong> O(1) or O(k) depending on problem.</span></p>
      </div>
      <div class="python-code">
        <div class="code-header" data-i18n="max_sum_subarray">Max Sum Subarray of Size K</div>
        <pre>
def max_sum_subarray(arr, k):
    if len(arr) < k:
        return 0
    window_sum = sum(arr[:k])
    max_sum = window_sum
    for i in range(k, len(arr)):
        window_sum = window_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, window_sum)
    return max_sum
# Example usage
arr = [2, 1, 5, 1, 3, 2]
print(max_sum_subarray(arr, 3))  # 9 (subarray [5, 1, 3])
</pre>
      </div>
      <div class="controls">
        <input type="text" id="sw-array" value="2,1,5,1,3,2" data-i18n-ph="ph_sw_array">
        <input type="number" id="sw-k" value="3" data-i18n-ph="ph_sw_k">
        <button onclick="runSlidingWindow()" data-i18n="btn_run">Run</button>
      </div>
      <canvas id="sw-canvas" width="1100" height="200"></canvas>
      <div class="info" id="sw-result"></div>
    </div>

<!-- =============== ROTTING ORANGES SECTION =============== -->
<div id="rotting" class="section">
  <h2 data-i18n="rotting_title">Rotting Oranges Sandbox</h2>
  
  
  <!-- ===== DETAILS WITH EXPLANATIONS ===== -->
  <div class="details">
    <h3 data-i18n="details_heading">What is the Rotting Oranges Problem?</h3>
    <p id="rotting-desc">
      <!-- Dynamically updated based on language -->
    </p>
    
    <div class="python-code" style="margin-top:15px;">
      <div class="code-header" data-i18n="py_heading">Python Implementation (BFS)</div>
      <pre id="rotting-python-code">
from collections import deque

def oranges_rotting(grid):
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0
    
    # Initialize queue with rotten oranges and count fresh ones
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c))
            elif grid[r][c] == 1:
                fresh_count += 1
    
    # If no fresh oranges, return 0
    if fresh_count == 0:
        return 0
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    minutes = 0
    
    while queue and fresh_count > 0:
        minutes += 1
        for _ in range(len(queue)):
            r, c = queue.popleft()
            
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if (0 <= nr < rows and 0 <= nc < cols and 
                    grid[nr][nc] == 1):
                    grid[nr][nc] = 2
                    fresh_count -= 1
                    queue.append((nr, nc))
    
    return minutes if fresh_count == 0 else -1
      </pre>
    </div>
  </div>

  <!-- ===== INTERACTIVE CONTROLS ===== -->
  <div class="panel" style="margin-top:20px;">
    <div class="row" style="flex-wrap:wrap; gap:12px; justify-content:space-between;">
      <div style="display:flex; gap:12px; flex-wrap:wrap;">
        <button id="add-fresh" class="good" style="padding:10px 16px;">
          <span data-i18n="btn_add_fresh">Add Fresh üçä</span>
        </button>
        <button id="add-rotten" class="bad" style="padding:10px 16px;">
          <span data-i18n="btn_add_rotten">Add Rotten üçä</span>
        </button>
        <button id="clear-grid" style="padding:10px 16px; background:#6a5acd; border-color:#7a6add;">
          <span data-i18n="btn_clear_grid">Clear Grid</span>
        </button>
        <button id="random-grid" style="padding:10px 16px; background:#4caf50; border-color:#5cbf60;">
          <span data-i18n="btn_random_grid">Random Grid</span>
        </button>
      </div>
      
      <button id="run-rotting" class="accent" style="padding:10px 24px; font-size:16px;">
        <span data-i18n="btn_run_rotting">Run Simulation</span>
      </button>
    </div>

    <div class="row" style="margin-top:15px; padding:12px; background:#1a1a2e; border-radius:8px;">
      <div style="display:flex; flex-wrap:wrap; gap:20px; flex:1;">
        <div>
          <strong data-i18n="grid_status">Grid Status:</strong>
          <div id="grid-stats" style="margin-top:5px; font-family:monospace;"></div>
        </div>
        <div>
          <strong data-i18n="simulation_speed">Simulation Speed:</strong>
          <input type="range" id="rotting-speed" min="100" max="1000" value="400" style="width:150px;">
        </div>
      </div>
    </div>
  </div>

  <!-- ===== VISUALIZATION CANVAS ===== -->
  <div class="panel" style="margin-top:20px;">
    <div id="rotting-canvas-container" style="overflow:auto; background:#0b1021; border-radius:12px; padding:10px;"></div>
  </div>

  <!-- ===== RESULTS & FEEDBACK ===== -->
  <div class="panel" style="margin-top:20px;">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <h3 style="margin:0;" data-i18n="result_heading">Result</h3>
      <div id="rotting-status" style="font-weight:bold; padding:8px 16px; border-radius:8px;"></div>
    </div>
    <div id="rotting-result" style="margin-top:15px; padding:15px; background:#1a1a2e; border-radius:8px; min-height:60px; font-size:18px; font-family:monospace;"></div>
  </div>

  <!-- ===== INSTRUCTIONS ===== -->
  <div class="panel" style="margin-top:20px; background:#16213e; border-left:4px solid #f5d06f;">
    <h3 style="margin:0 0 15px 0; color:#f5d06f;" data-i18n="instructions">How to Use</h3>
    <ol style="padding-left:20px; line-height:1.6;">
      <li data-i18n="rotting_instr1">Click cells to toggle between Empty (‚¨õ), Fresh (üçä), and Rotten (ü¶†)</li>
      <li data-i18n="rotting_instr2">Use "Add Fresh/Rotten" buttons to quickly place oranges</li>
      <li data-i18n="rotting_instr3">Click "Run Simulation" to see minute-by-minute rotting process</li>
      <li data-i18n="rotting_instr4">Green = Fresh, Red = Rotten, Black = Empty</li>
      <li data-i18n="rotting_instr5">Result shows minutes needed or -1 if impossible</li>
    </ol>
  </div>
</div>

<script>
// ====================== ROTTING ORANGES SANDBOX ======================
(() => {
  const container = document.getElementById('rotting');
  if (!container) return;

  // Constants
  const EMPTY = 0;
  const FRESH = 1;
  const ROTTEN = 2;
  
  // State
  const ROWS = 8;
  const COLS = 10;
  let grid = [];
  let isAnimating = false;
  let currentMinute = 0;

  // DOM Elements
  const canvasContainer = container.querySelector('#rotting-canvas-container');
  const statsDiv = container.querySelector('#grid-stats');
  const statusDiv = container.querySelector('#rotting-status');
  const resultDiv = container.querySelector('#rotting-result');
  const speedInput = container.querySelector('#rotting-speed');

  // Initialize grid
  const initGrid = () => {
    grid = Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));
    updateStats();
    renderGrid();
  };

  // Update statistics
  const updateStats = () => {
    let fresh = 0, rotten = 0, empty = 0;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (grid[r][c] === FRESH) fresh++;
        else if (grid[r][c] === ROTTEN) rotten++;
        else empty++;
      }
    }
    statsDiv.innerHTML = `
      <div>Empty: ${empty} | Fresh: ${fresh} | Rotten: ${rotten}</div>
      <div>Size: ${ROWS}√ó${COLS}</div>
    `;
  };

  // Render grid as HTML table
  const renderGrid = () => {
    let html = '<table style="border-collapse:collapse; margin:0 auto;">';
    for (let r = 0; r < ROWS; r++) {
      html += '<tr>';
      for (let c = 0; c < COLS; c++) {
        const cellClass = getCellClass(grid[r][c]);
        html += `<td data-row="${r}" data-col="${c}" class="${cellClass}" style="width:50px;height:50px;border:1px solid #333;cursor:pointer;text-align:center;vertical-align:middle;font-size:24px;"></td>`;
      }
      html += '</tr>';
    }
    html += '</table>';
    canvasContainer.innerHTML = html;
    
    // Add click handlers
    canvasContainer.querySelectorAll('td').forEach(cell => {
      cell.addEventListener('click', () => {
        if (isAnimating) return;
        const r = parseInt(cell.getAttribute('data-row'));
        const c = parseInt(cell.getAttribute('data-col'));
        // Cycle: EMPTY ‚Üí FRESH ‚Üí ROTTEN ‚Üí EMPTY
        if (grid[r][c] === EMPTY) grid[r][c] = FRESH;
        else if (grid[r][c] === FRESH) grid[r][c] = ROTTEN;
        else grid[r][c] = EMPTY;
        updateStats();
        renderGrid();
      });
    });
  };

  const getCellClass = (value) => {
    if (value === EMPTY) return 'rotting-empty';
    if (value === FRESH) return 'rotting-fresh';
    return 'rotting-rotten';
  };

  // Event Listeners
  container.querySelector('#add-fresh').addEventListener('click', () => {
    if (isAnimating) return;
    // Find first empty cell and make it fresh
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (grid[r][c] === EMPTY) {
          grid[r][c] = FRESH;
          updateStats();
          renderGrid();
          return;
        }
      }
    }
  });

  container.querySelector('#add-rotten').addEventListener('click', () => {
    if (isAnimating) return;
    // Find first empty/fresh cell and make it rotten
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (grid[r][c] !== ROTTEN) {
          grid[r][c] = ROTTEN;
          updateStats();
          renderGrid();
          return;
        }
      }
    }
  });

  container.querySelector('#clear-grid').addEventListener('click', () => {
    if (isAnimating) return;
    initGrid();
    resultDiv.innerHTML = '';
    statusDiv.textContent = '';
    statusDiv.style.backgroundColor = '';
  });

  container.querySelector('#random-grid').addEventListener('click', () => {
    if (isAnimating) return;
    // Generate random grid with ~30% empty, ~50% fresh, ~20% rotten
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const rand = Math.random();
        if (rand < 0.3) grid[r][c] = EMPTY;
        else if (rand < 0.8) grid[r][c] = FRESH;
        else grid[r][c] = ROTTEN;
      }
    }
    updateStats();
    renderGrid();
  });

  container.querySelector('#run-rotting').addEventListener('click', async () => {
    if (isAnimating) return;
    isAnimating = true;
    container.querySelector('#run-rotting').disabled = true;
    
    // Create a deep copy for simulation
    const simGrid = grid.map(row => [...row]);
    const directions = [[0,1], [1,0], [0,-1], [-1,0]];
    let freshCount = 0;
    const queue = [];
    
    // Count fresh oranges and initialize queue with rotten ones
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (simGrid[r][c] === FRESH) freshCount++;
        else if (simGrid[r][c] === ROTTEN) {
          queue.push([r, c]);
        }
      }
    }
    
    // If no fresh oranges, simulation ends immediately
    if (freshCount === 0) {
      statusDiv.textContent = '‚úÖ All oranges already rotten!';
      statusDiv.style.backgroundColor = 'rgba(0, 200, 83, 0.2)';
      resultDiv.innerHTML = '<span style="color:#00c853">Minutes: 0</span>';
      isAnimating = false;
      container.querySelector('#run-rotting').disabled = false;
      return;
    }
    
    currentMinute = 0;
    let hasRotted = true;
    
    // Step-by-step simulation
    while (queue.length > 0 && freshCount > 0 && hasRotted) {
      currentMinute++;
      hasRotted = false;
      const currentSize = queue.length;
      
      // Process all oranges that are rotten at the start of this minute
      for (let i = 0; i < currentSize; i++) {
        const [r, c] = queue.shift();
        
        for (const [dr, dc] of directions) {
          const nr = r + dr;
          const nc = c + dc;
          
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && simGrid[nr][nc] === FRESH) {
            simGrid[nr][nc] = ROTTEN;
            freshCount--;
            queue.push([nr, nc]);
            hasRotted = true;
          }
        }
      }
      
      // Update visual grid
      grid = simGrid.map(row => [...row]);
      renderGrid();
      
      // Update result
      resultDiv.innerHTML = `<span style="color:#ffab00">Simulating... Minute: ${currentMinute}</span>`;
      
      await sleep(parseInt(speedInput.value));
    }
    
    // Final result
    if (freshCount === 0) {
      statusDiv.textContent = '‚úÖ All oranges rotted successfully!';
      statusDiv.style.backgroundColor = 'rgba(0, 200, 83, 0.2)';
      resultDiv.innerHTML = `<span style="color:#00c853">Total Minutes: ${currentMinute}</span>`;
    } else {
      statusDiv.textContent = '‚ùå Some oranges remain fresh!';
      statusDiv.style.backgroundColor = 'rgba(255, 82, 82, 0.2)';
      resultDiv.innerHTML = `<span style="color:#ff5252">Result: -1 (Impossible)</span>`;
    }
    
    isAnimating = false;
    container.querySelector('#run-rotting').disabled = false;
  });

  // Helper
  const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  // Bilingual content
  const updateLanguage = () => {
    const lang = localStorage.getItem('app-lang') || 'en';
    const desc = lang === 'uz' ? 
      'Rotting Oranges muammosi ‚Äî to\'ldirilgan matritsada (grid) xar bir katakda bo\'sh (0), yangi apelsin (1) yoki chirgan apelsin (2) mavjud. Har bir daqiqa, chirgan apelsinlar barcha to\'g\'ri chiqishdagi (yuqori, past, chap, o\'ng) yangi apelsinlarni chirgatadi. Barcha yangi apelsinlar chirgacha ketadigan minimal daqiqalarni toping. Agar barchasini chirgatib bo\'lmasa, -1 qaytaring.' :
      'The Rotting Oranges problem involves a grid where each cell contains an empty cell (0), a fresh orange (1), or a rotten orange (2). Every minute, any fresh orange adjacent (up, down, left, right) to a rotten orange becomes rotten. Find the minimum number of minutes until all oranges are rotten. Return -1 if impossible.';
    
    container.querySelector('#rotting-desc').textContent = desc;
    applyI18nToContainer(container);
  };

  function applyI18nToContainer(el) {
    el.querySelectorAll('[data-i18n]').forEach(node => {
      const key = node.getAttribute('data-i18n');
      node.textContent = T(key);
    });
  }



  // Initialize
  initGrid();
  updateLanguage();
  
  // Listen for language changes
  window.addEventListener('storage', (e) => {
    if (e.key === 'app-lang') updateLanguage();
  });
})();
</script>

<style>
.rotting-empty { background-color: #1a1a2e; }
.rotting-fresh { background-color: #4caf50; color: white; }
.rotting-rotten { background-color: #f44336; color: white; }
</style>
  </div> <!-- .container -->

  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
  <script>
    // ====================== LANGUAGE SYSTEM ======================
    let currentLang = 'en';
    const I18N = {
      en: {
        title: "DSA Sandbox Pro",
        subtitle: "Interactive ‚Ä¢ Beautiful ‚Ä¢ Fully Visual Algorithm Playground",
        ph_search: "üîç Search DSA topics (e.g., 'tree', 'sort', 'graph')...",
        nav_arrays: "Arrays",
        nav_sorting: "Sorting",
        nav_searching: "Searching",
        nav_bt: "Binary Tree",
        nav_bst: "BST",
        nav_avl: "AVL Tree",
        nav_trie: "Trie",
        nav_heaps: "Heaps & Heap Sort",
        nav_graphs: "Graphs",
        nav_bellman: "Bellman-Ford",
        nav_dijkstra: "Dijkstra",
        nav_astar: "A*",
        nav_recursion: "Recursion",
        nav_linkedlist: "Linked List",
        nav_hashtable: "Hash Table",
        nav_toposort: "Topo Sort",
        nav_kruskal: "Kruskal's",
        nav_floyd: "Floyd-Warshall",
        nav_sliding: "Sliding Window",
        nav_time_complexity: "Time Complexity",
        nav_space_complexity: "Space Complexity",
        nav_complexity: "Complexity Race",
        btn_reset_all: "Reset All",
        confirm_reset: "Reset all data structures?",
        details_heading: "Details",
        py_heading: "Python Implementation",
        time_complexity_title: "Time Complexity Sandbox",
        space_complexity_title: "Space Complexity Sandbox",
        complexity_race_title: "Time & Space Complexity Race",
        arrays_title: "Dynamic Array Operations",
        sorting_title: "Sorting Algorithms",
        searching_title: "Search Algorithms",
        bt_title: "Binary Tree (Complete BT)",
        bst_title: "Binary Search Tree (BST)",
        avl_title: "AVL Tree (Self-Balancing BST)",
        trie_title: "Trie (Prefix Tree)",
        heaps_title: "Heaps & Heap Sort",
        graphs_title: "Graph Traversal",
        bellman_title: "Bellman-Ford Algorithm",
        dijkstra_title: "Dijkstra's Algorithm",
        astar_title: "A* Pathfinding",
        recursion_title: "Towers of Hanoi (Recursion)",
        linkedlist_title: "Linked List Sandbox Mode",
        hashtable_title: "Hash Table (Chaining)",
        toposort_title: "Topological Sort Sandbox",
        kruskal_title: "Kruskal's Minimum Spanning Tree",
        floyd_title: "Floyd-Warshall (All-Pairs Shortest Path)",
        sliding_title: "Sliding Window Technique",
        time_complexity: "Time Complexity",
        time_complexity_desc: "describes how an algorithm's runtime grows as the input size increases. It uses",
        big_o: "Big-O notation",
        big_o_desc: "to express the worst-case growth rate, ignoring constants and lower-order terms.",
        key_classes: "Key Classes:",
        o1_desc: "Constant ‚Äî independent of input size.",
        ologn_desc: "Logarithmic ‚Äî halves problem each step (e.g., binary search).",
        on_desc: "Linear ‚Äî scales directly with input (e.g., simple loop).",
        onlogn_desc: "Linearithmic ‚Äî divide-and-conquer sorts (e.g., merge sort).",
        on2_desc: "Quadratic ‚Äî nested loops (e.g., bubble sort).",
        o2n_desc: "Exponential ‚Äî recursive branching (e.g., naive Fibonacci).",
        input_size: "Input Size (n):",
        btn_animate_growth: "Animate Growth",
        time_info: "Adjust n and click \"Animate Growth\" to see how operations scale",
        space_complexity: "Space Complexity",
        space_complexity_desc: "measures the total memory an algorithm uses relative to input size. It includes:",
        input_space: "Input space",
        input_space_desc: "Memory to store the input data.",
        auxiliary_space: "Auxiliary space",
        auxiliary_space_desc: "Extra memory used during execution (e.g., recursion stack, temp arrays).",
        space_example: "Example: Merge Sort uses O(n) auxiliary space for merging; Quick Sort uses O(log n) for recursion depth (in-place).",
        btn_visualize_memory: "Visualize Memory",
        space_info: "Compare memory usage for different approaches",
        how_it_works: "How It Works",
        race_desc: "Select two algorithms to compare. The race visualizes how their time complexity scales as input size increases. The vertical axis shows \"operations\" (simulated), and the horizontal axis shows input size (n). Lower curve = more efficient.",
        algo_a: "Algorithm A:",
        algo_b: "Algorithm B:",
        bubble_sort: "Bubble Sort",
        quick_sort: "Quick Sort",
        merge_sort: "Merge Sort",
        linear_search: "Linear Search",
        binary_search: "Binary Search",
        fib_recursive: "Fibonacci (Recursive)",
        fib_dp: "Fibonacci (DP)",
        btn_start_race: "Start Race",
        complexity_info: "Select algorithms and click \"Start Race\"",
        time_complexity_label: "Time Complexity:",
        space_complexity_label: "Space Complexity:",
        arrays_desc: "Dynamic arrays are resizable arrays that provide efficient random access and dynamic sizing. They automatically double in capacity when full to maintain amortized O(1) append operations. Key operations include access (O(1)), append/push (amortized O(1)), insert/delete at index (O(n) due to shifting), and search (O(n)). They are ideal for lists where size is unknown in advance, but frequent inserts/deletes in the middle can be costly due to element shifting.",
        ph_array_vals: "Comma-separated values",
        ph_value: "Value",
        ph_index: "Index",
        ph_find: "Find",
        btn_load: "Load",
        btn_refresh: "Refresh",
        btn_insert: "Insert",
        btn_delete: "Delete",
        btn_push: "Push",
        btn_pop: "Pop",
        btn_unshift: "Unshift",
        btn_shift: "Shift",
        btn_search: "Search",
        btn_clear: "Clear",
        array_status: "Array: [] | Length: 0",
        sorting_desc: "Sorting algorithms rearrange elements in ascending or descending order. Bubble Sort (O(n¬≤)) swaps adjacent elements repeatedly. Quick Sort (average O(n log n), worst O(n¬≤)) uses partitioning around a pivot. Merge Sort (O(n log n)) divides the array and merges sorted halves. These are fundamental for data organization, with trade-offs in stability, space, and time.",
        ph_sort_vals: "Values: 64,34,25,...",
        btn_start: "Start",
        sort_steps: "Steps: 0",
        searching_desc: "Search algorithms locate a target in a collection. Linear Search (O(n)) checks each element sequentially, suitable for unsorted data. Binary Search (O(log n)) halves the search interval on sorted data. Jump Search (O(‚àön)) skips blocks of size ‚àön, then performs linear search, offering a middle ground. Exponential Search (O(log n)) finds a range where the target exists using exponential steps, then performs Binary Search in that range. Both Jump and Exponential Search require the array to be sorted for efficient (sub-linear) operation.",
        ph_search_vals: "Array values",
        ph_target: "Target",
        linear_search: "Linear Search",
        binary_search: "Binary Search",
        jump_search: "Jump Search",
        exponential_search: "Exponential Search",
        btn_start_search: "Start Search",
        search_steps: "Steps: 0",
        bt_desc: "A Binary Tree is a tree data structure where each node has at most two children (left and right). This implementation uses level-order insertion to create a Complete Binary Tree (all levels filled left to right). Traversals include In-order, Pre-order, and Post-order.",
        bt_time: "Insert: O(1), Traversal: O(n)",
        ph_bt_vals: "Comma-separated values",
        btn_build_tree: "Build Tree",
        btn_inorder: "In-order",
        btn_preorder: "Pre-order",
        btn_postorder: "Post-order",
        bst_desc: "A Binary Search Tree (BST) is a binary tree where each node's left subtree has values less than the node, and right has greater. It supports efficient search, insert, and delete (average O(log n), worst O(n) if unbalanced). Traversals include in-order (sorted), pre-order, and post-order.",
        ph_bst_vals: "Comma-separated values",
        btn_build_bst: "Build BST",
        avl_desc: "An AVL Tree is a self-balancing Binary Search Tree where the height difference (balance factor) between the left and right subtrees of any node is at most 1. This strict balance ensures that search, insert, and delete operations maintain an optimal time complexity of O(log n) even in the worst-case scenario, unlike a regular BST which can degenerate to O(n).",
        ph_avl_val: "Value to Insert",
        ph_avl_vals: "Comma-separated values",
        btn_insert_value: "Insert Value",
        btn_build: "Build",
        trie_desc: "A Trie, or Prefix Tree, is an efficient data structure for storing and searching a dynamic set of strings. It organizes strings based on shared prefixes. Search and insertion are typically O(L), where L is the length of the string, making it much faster than BSTs for strings. Tries are used for auto-complete, spell checkers, and IP routing. Each node stores a map to its children (characters), and a boolean flag marks the end of a word.",
        ph_trie_insert: "Word to Insert (e.g., car)",
        ph_trie_vals: "Comma-separated words",
        ph_trie_search: "Search/Prefix (e.g., ca)",
        btn_search_prefix: "Search/Prefix",
        trie_status: "Trie is empty.",
        heaps_desc: "Heaps are complete binary trees satisfying the heap property:",
        min_heap: "Min-Heap",
        min_heap_desc: "Parent ‚â§ children (smallest at root)",
        max_heap: "Max-Heap",
        max_heap_desc: "Parent ‚â• children (largest at root)",
        heap_sort: "Heap Sort",
        heap_sort_desc: "uses a max-heap to sort an array in O(n log n) time:",
        heap_step1: "Build a max-heap from the array",
        heap_step2: "Repeatedly extract the max element and place it at the end",
        heap_step3: "Reduce heap size and heapify the root",
        heap_time: "Heapify: O(log n), Build Heap: O(n), Heap Sort: O(n log n)",
        ph_heap_vals: "Values: 3,1,4,1,5",
        ph_heap_size: "Random Size",
        btn_random: "Random Data",
        btn_run: "Run",
        heap_info: "Select heap type and load data",
        graphs_desc: "Graphs consist of nodes and edges. BFS (Breadth-First Search) explores level-by-level using a queue (O(V+E)), good for shortest paths in unweighted graphs. DFS (Depth-First Search) explores deeply using recursion (O(V+E)), useful for cycles or topological sort.",
        btn_bfs: "BFS",
        btn_dfs: "DFS",
        bellman_desc: "Bellman-Ford computes shortest paths from a source in graphs with negative weights (O(VE)). It relaxes all edges V-1 times and detects negative cycles. Unlike Dijkstra, it handles negatives but is slower.",
        dijkstra_desc: "Dijkstra finds shortest paths from a source in graphs with non-negative weights (O((V+E) log V) with priority queue). It uses a greedy approach, selecting the closest unvisited node each time.",
        directed: "Directed",
        undirected: "Undirected",
        ph_graph_edges: "Edges: a-b:w,...",
        ph_start: "Start",
        ph_end: "End",
        btn_load_run: "Load & Run",
        astar_desc: "A* is an informed search algorithm for pathfinding, combining Dijkstra's shortest path with greedy best-first search using heuristics (e.g., Manhattan distance). It's optimal with admissible heuristics, efficient for grids/maps (time varies, worst exponential).",
        btn_find_path: "Find Path",
        btn_clear_walls: "Clear Walls",
        speed_label: "Speed:",
        recursion_desc: "Towers of Hanoi is a classic recursion problem: move n disks from peg A to C using B as auxiliary, without placing larger disks on smaller. It demonstrates divide-and-conquer, with 2^n - 1 moves. Recursion depth is n, time O(2^n).",
        disks_label: "Disks:",
        btn_solve: "Solve",
        linkedlist_desc: "A Linked List is a linear data structure where each element (node) contains data and a pointer to the next node. Unlike arrays, it doesn't require contiguous memory allocation, allowing dynamic size adjustment. This sandbox supports Singly, Doubly, and Circular variants with animated traversal and step-by-step debugging.",
        linkedlist_time: "Access: O(n), Search: O(n), Insertion: O(1) at head / O(n) elsewhere, Deletion: O(1) at head / O(n) elsewhere.",
        hashtable_desc: "A Hash Table maps keys to values using a hash function. Collisions (when two keys hash to the same index) are resolved via chaining‚Äîeach bucket holds a linked list of key-value pairs. Average-case time complexity for insert, search, and delete is O(1); worst-case is O(n) if all keys collide. Used in dictionaries, caches, database indexing, and more.",
        hashtable_time: "Average: O(1), Worst: O(n). Space: O(n).",
        ph_ht_key: "Key (string or number)",
        ph_ht_value: "Value",
        btn_insert_update: "Insert/Update",
        btn_get: "Get",
        btn_remove: "Remove",
        btn_clear_table: "Clear Table",
        ht_status: "Table empty",
        toposort_desc: "Topological Sort orders vertices in a Directed Acyclic Graph (DAG) so that for every directed edge u‚Üív, u comes before v. It's used in task scheduling, course prerequisites, and build systems. Kahn's algorithm uses in-degree counting and a queue: repeatedly remove nodes with zero in-degree. Time: O(V + E). If the graph has a cycle, no valid topological order exists.",
        toposort_time: "O(V + E).",
        space_label: "Space:",
        num_nodes: "Number of Nodes:",
        edges_label: "Add Edges (u‚Üív):",
        btn_run_topo: "Run Topological Sort",
        btn_clear_edges: "Clear Edges",
        btn_random_graph: "Random DAG",
        current_edges: "Current Edges:",
        in_degree: "In-Degree:",
        result_heading: "Result",
        instructions: "How to Use",
        instr1: "Set the number of nodes (1-10)",
        instr2: "Add directed edges using \"From ‚Üí To\"",
        instr3: "Click \"Run Topological Sort\" to see step-by-step execution",
        instr4: "Green nodes = processed, Yellow = in queue, Red = cycle detected",
        instr5: "Use \"Random DAG\" for a valid example or \"Clear Edges\" to reset",
        alert_valid_numbers: "Please enter valid numbers",
        alert_node_range: "Node indices must be between 0 and {max}",
        alert_no_self_loop: "Self-loops (u‚Üíu) are not allowed",
        alert_duplicate_edge: "This edge already exists",
        topo_order: "Topological Order",
        cycle_detected: "Cycle detected! Topological sort only works on DAGs (Directed Acyclic Graphs).",
        kruskal_desc: "Kruskal's Algorithm finds the Minimum Spanning Tree (MST) of a connected, undirected graph by greedily adding the smallest edge that doesn't form a cycle. It uses Union-Find (Disjoint Set Union) to detect cycles. Ideal for sparse graphs. Time: O(E log E) due to sorting.",
        kruskal_time: "O(E log E).",
        add_edge_label: "Add Edge (u‚Äìv : weight):",
        btn_run_kruskal: "Run Kruskal's Algorithm",
        mst_status: "MST Status:",
        kruskal_instr1: "Set number of nodes (2‚Äì10)",
        kruskal_instr2: "Add weighted edges using \"u ‚Äì v : weight\"",
        kruskal_instr3: "Click \"Run Kruskal's\" to see step-by-step MST construction",
        kruskal_instr4: "Green edges = in MST, Gray = skipped (would form cycle)",
        kruskal_instr5: "Use \"Random Connected Graph\" for a valid example",
        graph_disconnected: "Graph is disconnected! MST requires a connected graph.",
        floyd_desc: "Floyd-Warshall computes shortest paths between all pairs of vertices in a weighted graph (including negative weights, but not negative cycles). It uses dynamic programming with three nested loops. Time: O(V¬≥). Useful when you need all shortest paths, not just from one source.",
        floyd_time: "O(V¬≥).",
        ph_floyd_edges: "Directed edges: a-b:w,...",
        ph_floyd_nodes: "Nodes",
        btn_run_floyd: "Run Floyd-Warshall",
        sliding_desc: "The Sliding Window technique optimizes array/string problems by maintaining a \"window\" (subarray) that satisfies given constraints. Instead of recalculating everything for each subarray, it adjusts the window by moving the start/end pointers. Common applications: max sum of subarray of size k, longest substring without repeating characters. Time: O(n).",
        sliding_time: "O(n).",
        max_sum_subarray: "Max Sum Subarray of Size K",
        ph_sw_array: "Array",
        ph_sw_k: "Window size k",
        msg_array_empty: "Array is empty",
        msg_found_index: "Found at index {i}!",
        msg_not_found: "Not Found",
        msg_running: "Running...",
        msg_done_steps: "Done ‚Äì {steps} steps",
        msg_steps: "Steps: {steps}",
        msg_searching: "Searching...",
        msg_found_target: "Found {target} at index {i}!",
        msg_not_found_steps: "Not found after {steps} steps",
        msg_load_array_first: "Load array first",
        msg_enter_values_tree: "Enter values and click Build Tree",
        msg_enter_values_bst: "Enter values and click Build BST",
        msg_trie_empty: "Trie is empty.",
        msg_trie_built: "Trie Built with {count} words.",
        msg_trie_inserted: "Inserted word: {word}",
        msg_trie_searching: "Searching for: {word}",
        msg_prefix_not_found: "Prefix/Word not found: {word}",
        msg_prefix_found: "Prefix found, but not a full word: {word}",
        msg_word_found: "Found word: {word}",
        msg_heap_empty: "Heap is empty - Insert elements",
        msg_no_path: "No path found",
        msg_linear_range: "Linear search in range [{a}, {b}]",
        msg_binary_range: "Binary search in range [{a}, {b}]",
        nav_rotting: "Rotting Oranges",
        rotting_title: "Rotting Oranges Sandbox",
rotting_desc: "The Rotting Oranges problem involves a grid where each cell contains an empty cell (0), a fresh orange (1), or a rotten orange (2). Every minute, any fresh orange adjacent (up, down, left, right) to a rotten orange becomes rotten. Find the minimum number of minutes until all oranges are rotten. Return -1 if impossible.",
btn_add_fresh: "Add Fresh üçä",
btn_add_rotten: "Add Rotten üçä",
btn_clear_grid: "Clear Grid",
btn_random_grid: "Random Grid",
btn_run_rotting: "Run Simulation",
grid_status: "Grid Status:",
simulation_speed: "Simulation Speed:",
result_heading: "Result",
instructions: "How to Use",
rotting_instr1: "Click cells to toggle between Empty (‚¨õ), Fresh (üçä), and Rotten (ü¶†)",
rotting_instr2: "Use \"Add Fresh/Rotten\" buttons to quickly place oranges",
rotting_instr3: "Click \"Run Simulation\" to see minute-by-minute rotting process",
rotting_instr4: "Green = Fresh, Red = Rotten, Black = Empty",
rotting_instr5: "Result shows minutes needed or -1 if impossible",
nav_advanced_sorting: "Advanced Sorting",
advanced_sorting_title: "Advanced Sorting Algorithms",
select_algorithm: "Select Algorithm:",
btn_run_sort: "Run Sorting",
btn_random_data: "Random Data",
adv_instr1: "Enter comma-separated numbers or use \"Random Data\"",
adv_instr2: "Select an algorithm from the dropdown",
adv_instr3: "Click \"Run Sorting\" to see step-by-step visualization",
adv_instr4: "Green bars = sorted, Yellow = current processing, Red = comparison",

nav_string_algos: "String Matching",
string_algos_title: "String Matching Algorithms",
select_algorithm: "Select Algorithm:",
btn_run_search: "Run Search",
btn_random_text: "Random Text",
text_input: "Text:",
pattern_input: "Pattern:",
str_instr1: "Enter text and pattern or use \"Random Text\"",
str_instr2: "Select an algorithm from the dropdown",
str_instr3: "Click \"Run Search\" to see step-by-step matching process",
str_instr4: "Green = match found, Yellow = current comparison, Red = mismatch",

nav_dp_algos: "Dynamic Programming",
dp_algos_title: "Dynamic Programming Algorithms",
select_algorithm: "Select Algorithm:",
btn_run_dp: "Run Algorithm",
btn_random_data: "Random Data",
weights_input: "Weights:",
values_input: "Values:",
capacity_input: "Capacity:",
string1_input: "String 1:",
string2_input: "String 2:",
dimensions_input: "Matrix Dimensions:",
matrix_help: "For n matrices, provide n+1 dimensions",
dp_instr1: "Select an algorithm from the dropdown",
dp_instr2: "Enter required inputs or use \"Random Data\"",
dp_instr3: "Click \"Run Algorithm\" to see step-by-step DP table construction",
dp_instr4: "Green cells = optimal solution path, Blue = current computation",

      },
      uz: {
        title: "DSA Sandbox Pro",
        subtitle: "Interaktiv ‚Ä¢ Chiroyli ‚Ä¢ Vizual Algoritmlar Muhiti",
        ph_search: "üîç DSA mavzularini qidiring (masalan, 'daraxt', 'saralash', 'graf')...",
        nav_arrays: "Massivlar",
        nav_sorting: "Saralash",
        nav_searching: "Qidiruv",
        nav_bt: "Ikkilik daraxt",
        nav_bst: "BST",
        nav_avl: "AVL daraxt",
        nav_trie: "Trie",
        nav_heaps: "Heap va Heap Saralash",
        nav_graphs: "Graflar",
        nav_bellman: "Bellman‚ÄìFord",
        nav_dijkstra: "Dijkstra",
        nav_astar: "A*",
        nav_recursion: "Rekursiya",
        nav_linkedlist: "Bog'langan Ro'yxat",
        nav_hashtable: "Hesh Jadval",
        nav_toposort: "Topologik Saralash",
        nav_kruskal: "Kruskal algoritmi",
        nav_floyd: "Floyd-Vorshol",
        nav_sliding: "Sirpanuvchi Oyna",
        nav_time_complexity: "Vaqt Murakkabligi",
        nav_space_complexity: "Xotira Murakkabligi",
        nav_complexity: "Murakkablik Bahsi",
        btn_reset_all: "Hammasini Tiklash",
        confirm_reset: "Barcha ma'lumotlar strukturalari tiklansinmi?",
        details_heading: "Tafsilotlar",
        py_heading: "Python dasturlash tili",
        time_complexity_title: "Vaqt Murakkabligi Sandqog'i",
        space_complexity_title: "Xotira Murakkabligi Sandqog'i",
        complexity_race_title: "Vaqt va Xotira Murakkabligi Bahsi",
        arrays_title: "Dinamik Massiv Operatsiyalari",
        sorting_title: "Saralash algoritmlari",
        searching_title: "Qidiruv algoritmlari",
        bt_title: "Ikkilik daraxt (BT)",
        bst_title: "Ikkilik qidiruv daraxti (BST)",
        avl_title: "AVL daraxt (o'zini muvozanatlaydigan BST)",
        trie_title: "Trie (Prefiks daraxt)",
        heaps_title: "Heaplar va Heap Saralash",
        graphs_title: "Graf bo'ylab yurish",
        bellman_title: "Bellman‚ÄìFord algoritmi",
        dijkstra_title: "Dijkstra algoritmi",
        astar_title: "A* yo'l topish",
        recursion_title: "Hanoi minoralari (Rekursiya)",
        linkedlist_title: "Bog'langan ro'yxat (Sandbox rejimi)",
        hashtable_title: "Hesh jadval (Zanjir)",
        toposort_title: "Topologik saralash (Sandbox rejimi)",
        kruskal_title: "Kruskalning minimal uzunlikdagi bog'lovchi daraxti",
        floyd_title: "Floyd-Vorshol (Barcha juftliklar uchun eng qisqa yo'l)",
        sliding_title: "Sirpanuvchi oyna texnikasi",
        time_complexity: "Vaqt murakkabligi",
        time_complexity_desc: "kirish hajmi oshganda algoritm ishlash vaqti qanday o'sadi. U",
        big_o: "Big-O belgilash",
        big_o_desc: "eng yomon holatdagi o'sish tezligini ifodalash uchun, doimiy va past tartibli hadlarni hisobga olmaydi.",
        key_classes: "Asosiy sinflar:",
        o1_desc: "Doimiy ‚Äî kirish hajmidan mustaqil.",
        ologn_desc: "Logarifmik ‚Äî har bir qadamda muammoni ikkiga bo'ladi (masalan, binar qidiruv).",
        on_desc: "Chiziqli ‚Äî kirish bilan to'g'ridan-to'g'ri proportsional (masalan, oddiy sikl).",
        onlogn_desc: "Linearitmik ‚Äî bo'lib yechish saralashlari (masalan, birlashtirib saralash).",
        on2_desc: "Kvadratik ‚Äî ichma-ich sikllar (masalan, pufakcha saralash).",
        o2n_desc: "Eksponensial ‚Äî rekursiv shoxlanish (masalan, naiv Fibonachchi).",
        input_size: "Kirish hajmi (n):",
        btn_animate_growth: "O'sishni animatsiya qilish",
        time_info: "'n' ni sozlang va operatsiyalar qanday o'sishini ko'rish uchun 'O'sishni animatsiya qilish' tugmasini bosing",
        space_complexity: "Xotira murakkabligi",
        space_complexity_desc: "algoritm kirish hajmiga nisbatan foydalanadigan umumiy xotira hajmini o'lchaydi. Bunga kiradi:",
        input_space: "Kirish xotirasi",
        input_space_desc: "Kirish ma'lumotlarini saqlash uchun xotira.",
        auxiliary_space: "Yordamchi xotira",
        auxiliary_space_desc: "Bajarish paytida foydalaniladigan qo'shimcha xotira (masalan, rekursiya steki, vaqtinchalik massivlar).",
        space_example: "Misol: Birlashtirish saralash birlashtirish uchun O(n) yordamchi xotira ishlatadi; Tezkor saralash rekursiya chuqurligi uchun O(log n) xotira ishlatadi (joyda).",
        btn_visualize_memory: "Xotirani vizuallashtirish",
        space_info: "Turli yondashuvlar uchun xotira foydalanishini solishtiring",
        how_it_works: "Qanday ishlaydi",
        race_desc: "Taqqoslash uchun ikkita algoritmni tanlang. Bahs kirish hajmi oshganda ularning vaqt murakkabligi qanday o'sishini vizuallashtiradi. Vertikal o'q 'operatsiyalar'ni (simulyatsiya qilingan), gorizontal o'q esa kirish hajmini (n) ko'rsatadi. Pastki egri chiziq = samaraliroq.",
        algo_a: "Algoritm A:",
        algo_b: "Algoritm B:",
        bubble_sort: "Pufakcha saralash",
        quick_sort: "Tezkor saralash",
        merge_sort: "Birlashtirish saralash",
        linear_search: "Chiziqli qidiruv",
        binary_search: "Binar qidiruv",
        fib_recursive: "Fibonachchi (Rekursiv)",
        fib_dp: "Fibonachchi (DP)",
        btn_start_race: "Bahsni boshlash",
        complexity_info: "Algoritmlarni tanlang va 'Bahsni boshlash' tugmasini bosing",
        time_complexity_label: "Vaqt murakkabligi:",
        space_complexity_label: "Xotira murakkabligi:",
        arrays_desc: "Dinamik massivlar ‚Äî samarali tasodifiy kirish va dinamik hajmga ega bo'lgan kengaytiriladigan massivlardir. Ular amortizatsiyalangan O(1) qo'shish operatsiyalarini saqlash uchun to'ldirilganda avtomatik ravishda sig'imni ikki barobar oshiradi. Asosiy operatsiyalar: kirish (O(1)), qo'shish (amortizatsiyalangan O(1)), indeks bo'yicha qo'shish/o'chirish (O(n), siljitish tufayli), qidiruv (O(n)). Ular oldindan hajmi noaniq bo'lgan ro'yxatlar uchun ideal, lekin o'rtada tez-tez qo'shish/o'chirish elementlarni siljitish tufayli qimmatga tushadi.",
        ph_array_vals: "Vergul bilan ajratilgan qiymatlar",
        ph_value: "Qiymat",
        ph_index: "Indeks",
        ph_find: "Topish",
        btn_load: "Yuklash",
        btn_refresh: "Yangilash",
        btn_insert: "Qo'shish",
        btn_delete: "O'chirish",
        btn_push: "Push",
        btn_pop: "Pop",
        btn_unshift: "Unshift",
        btn_shift: "Shift",
        btn_search: "Qidirish",
        btn_clear: "Tozalash",
        array_status: "Massiv: [] | Uzunligi: 0",
        sorting_desc: "Saralash algoritmlari elementlarni kamayish yoki o'sish tartibida qayta joylashtiradi. Pufakcha saralash (O(n¬≤)) qo'shni elementlarni takroriy almashtiradi. Tezkor saralash (o'rtacha O(n log n), eng yomoni O(n¬≤)) markaz element atrofida bo'laklarga ajratadi. Birlashtirish saralash (O(n log n)) massivni ikkiga bo'lib, saralangan yarmi birlashtiriladi. Ma'lumotlarni tashkil qilish uchun asosiy ahamiyatga ega bo'lib, barqarorlik, xotira va vaqt jihatidan kompromissga kirishadi.",
        ph_sort_vals: "Qiymatlar: 64,34,25,...",
        btn_start: "Boshlash",
        sort_steps: "Qadamlar: 0",
        searching_desc: "Qidiruv algoritmlari to'plamdagi maqsadli elementni topadi. Chiziqli qidiruv (O(n)) har bir elementni ketma-ket tekshiradi, tartiblanmagan ma'lumotlar uchun mos keladi. Binar qidiruv (O(log n)) tartiblangan ma'lumotlarda qidiruv oralig'ini ikkiga bo'ladi. Sakrab qidiruv (O(‚àön)) ‚àön hajmli bloklarni sakrab o'tadi, keyin chiziqli qidiruvni amalga oshiradi, bu o'rta yo'l hisoblanadi. Eksponensial qidiruv (O(log n)) maqsad mavjud bo'lgan oralig'ni eksponensial qadamlar bilan topadi, so'ngra shu oralig'da binar qidiruvni amalga oshiradi. Sakrab va eksponensial qidiruv samarali (chiziqli bo'lmagan) ishlashi uchun massiv tartiblangan bo'lishi kerak.",
        ph_search_vals: "Massiv qiymatlari",
        ph_target: "Maqsad",
        linear_search: "Chiziqli qidiruv",
        binary_search: "Binar qidiruv",
        jump_search: "Sakrab qidiruv",
        exponential_search: "Eksponensial qidiruv",
        btn_start_search: "Qidiruvni boshlash",
        search_steps: "Qadamlar: 0",
        bt_desc: "Binar daraxt ‚Äî har bir tugunining eng ko'pi bilan ikkita farzandi (chap va o'ng) bo'lgan daraxt ma'lumotlar strukturasidir. Ushbu amalga oshirish to'liq binar daraxt (barcha darajalar chapdan o'ngga to'ldirilgan) yaratish uchun daraja tartibida qo'shishdan foydalanadi. Tashrif buyurish usullari: In-order, Pre-order va Post-order.",
        bt_time: "Qo'shish: O(1), Tashrif: O(n)",
        ph_bt_vals: "Vergul bilan ajratilgan qiymatlar",
        btn_build_tree: "Daraxtni Yaratish",
        btn_inorder: "In-order",
        btn_preorder: "Pre-order",
        btn_postorder: "Post-order",
        bst_desc: "Binar qidiruv daraxti (BST) ‚Äî har bir tugunining chap ostida tugundan kichik qiymatlar, o'ng ostida esa kattaroq qiymatlar bo'lgan binar daraxtdir. U samarali qidiruv, qo'shish va o'chirishni qo'llab-quvvatlaydi (o'rtacha O(log n), agar muvozanatsiz bo'lsa, eng yomoni O(n)). Tashrif buyurish usullari: in-order (saralangan), pre-order va post-order.",
        ph_bst_vals: "Vergul bilan ajratilgan qiymatlar",
        btn_build_bst: "BST Yaratish",
        avl_desc: "AVL daraxti ‚Äî istalgan tugunining chap va o'ng ostki daraxtlari balandligi farqi (muvozanat koeffitsienti) eng ko'pi bilan 1 bo'ladigan o'z-o'zini muvozanatlovchi binar qidiruv daraxtidir. Bu qat'iy muvozanat qidiruv, qo'shish va o'chirish operatsiyalari eng yomon holatda ham O(log n) vaqt murakkabligini saqlashiga kafolat beradi, oddiy BST esa O(n) gacha pasayishi mumkin.",
        ph_avl_val: "Qiymat qo'shish",
        ph_avl_vals: "Vergul bilan ajratilgan qiymatlar",
        btn_insert_value: "Qiymat Qo'shish",
        btn_build: "Yaratish",
        trie_desc: "Trie yoki prefiks daraxti ‚Äî satrlar to'plamini saqlash va qidirish uchun samarali ma'lumotlar strukturasidir. U satrlarni umumiy prefikslar asosida tashkil qiladi. Qidiruv va qo'shish odatda O(L) bo'ladi, bu yerda L ‚Äî satr uzunligi, bu uni satrlar uchun BSTlardan ancha tezroq qiladi. Trielar avtomatik to'ldirish, imlo tekshiruvi va IP marshrutlash uchun ishlatiladi. Har bir tugun farzandlari (belgilar) xaritasini saqlaydi va mantiqiy bayroq so'z oxirini belgilaydi.",
        ph_trie_insert: "So'z kiriting (masalan: car)",
        ph_trie_vals: "Vergul bilan ajratilgan so'zlar",
        ph_trie_search: "Qidiruv/prefiks (masalan: ca)",
        btn_search_prefix: "Qidiruv/Prefiks",
        trie_status: "Trie bo'sh.",
        heaps_desc: "Heaplar ‚Äî heap xususiyatini qanoatlantiruvchi to'liq binar daraxtlardir:",
        min_heap: "Min-Heap",
        min_heap_desc: "Ota ‚â• farzandlar (ildizda eng kichik)",
        max_heap: "Max-Heap",
        max_heap_desc: "Ota ‚â• farzandlar (ildizda eng katta)",
        heap_sort: "Heap saralash",
        heap_sort_desc: "massivni O(n log n) vaqtda saralash uchun max-heapdan foydalanadi:",
        heap_step1: "Massivdan max-heap yaratin",
        heap_step2: "Maksimal elementni takroriy olib, oxiriga qo'ying",
        heap_step3: "Heap hajmini kamaytiring va ildizni heapifikatsiya qiling",
        heap_time: "Heapifikatsiya: O(log n), Heap yaratish: O(n), Heap saralash: O(n log n)",
        ph_heap_vals: "Qiymatlar: 3,1,4,1,5",
        ph_heap_size: "Tasodifiy hajm",
        btn_random: "Tasodifiy ma'lumotlar",
        btn_run: "Ishga tushirish",
        heap_info: "Heap turini tanlang va ma'lumotlarni yuklang",
        graphs_desc: "Graflar tugunlar va qirralardan iborat. BFS (kenglik bo'yicha qidiruv) navbat yordamida daraja-daraja tekshiradi (O(V+E)), vaznsiz graflarda eng qisqa yo'lni topish uchun yaxshi. DFS (chuqurlik bo'yicha qidiruv) rekursiya yordamida chuqur tekshiradi (O(V+E)), sikllar yoki topologik saralash uchun foydalidir.",
        btn_bfs: "BFS",
        btn_dfs: "DFS",
        bellman_desc: "Bellman-Ford manfiy vaznli graflarda manbadan eng qisqa yo'lni hisoblaydi (O(VE)). U barcha qirralarni V-1 marta bo'shatadi va manfiy sikllarni aniqlaydi. Dijkstradan farqli o'laroq, manfiylarni qo'llab-quvvatlaydi, lekin sekinroq.",
        dijkstra_desc: "Dijkstra manfiy bo'lmagan vaznli graflarda manbadan eng qisqa yo'lni topadi (O((V+E) log V) ustuvorlik navbati bilan). U har safar eng yaqin tashrif buyurilmagan tugunni tanlaydigan ochko'z yondashuvdan foydalanadi.",
        directed: "Yo'naltirilgan",
        undirected: "Yo'naltirilmagan",
        ph_graph_edges: "Qirralar: a-b:w,...",
        ph_start: "Boshlanish",
        ph_end: "Tugash",
        btn_load_run: "Yukla va Ishga Tushir",
        astar_desc: "A* ‚Äî yo'l topish uchun axborotli qidiruv algoritmidir, u Dijkstra eng qisqa yo'lini evristik (masalan, Menxetten masofasi) yordamida ochko'z eng yaxshi birinchi qidiruv bilan birlashtiradi. Qabul qilinadigan evristikalar bilan optimal, panjara/xaritalar uchun samarali (vaqt turlicha, eng yomoni eksponensial).",
        btn_find_path: "Yo'lni Topish",
        btn_clear_walls: "Devorlarni Tozalash",
        speed_label: "Tezlik:",
        recursion_desc: "Hanoyni minorlari ‚Äî klassik rekursiya muammosidir: kattaroq diskni maydonga qo'masdan, yordamchi sifatida B minoradan foydalanib, n ta disklarni A minoridan C minoriga ko'chiring. U 2^n - 1 yurish bilan bo'lib yechishni namoyon qiladi. Rekursiya chuqurligi n, vaqt O(2^n).",
        disks_label: "Disklar:",
        btn_solve: "Yechish",
        linkedlist_desc: "Bog'langan ro'yxat ‚Äî har bir element (tugun) ma'lumot va keyingi tugunga ko'rsatkichni o'z ichiga olgan chiziqli ma'lumotlar strukturasidir. Massivlardan farqli o'laroq, u uzluksiz xotira ajratish talab qilmaydi, dinamik hajmni sozlashga imkon beradi. Ushbu sandbox Singly, Doubly va Circular variantlarini animatsiyali traversalka va qadam-qadam debagging bilan qo'llab-quvvatlaydi.",
        linkedlist_time: "Kirish: O(n), Qidiruv: O(n), Qo'shish: boshda O(1) / boshqa joylarda O(n), O'chirish: boshda O(1) / boshqa joylarda O(n).",
        hashtable_desc: "Hesh jadval kalitlarni qiymatlarga hesh funksiyasi yordamida bog'laydi. To'qnashuvlar (ikkita kalit bir xil indeksga heshlanganda) zanjir orqali hal qilinadi ‚Äî har bir segment kalit-qiymat juftliklarining bog'langan ro'yxatini saqlaydi. Qo'shish, qidiruv va o'chirish uchun o'rtacha vaqt murakkabligi O(1); eng yomon holat ‚Äî barcha kalitlar to'qnashsa, O(n). Lug'atlar, keshlar, ma'lumotlar bazasi indekslash va boshqalarda ishlatiladi.",
        hashtable_time: "O'rtacha: O(1), Eng yomon: O(n). Xotira: O(n).",
        ph_ht_key: "Kalit (satr yoki son)",
        ph_ht_value: "Qiymat",
        btn_insert_update: "Qo'shish/Yangilash",
        btn_get: "Olish",
        btn_remove: "O'chirish",
        btn_clear_table: "Jadvalni Tozalash",
        ht_status: "Jadval bo'sh",
        toposort_desc: "Topologik saralash yo'naltirilgan aylanmas graf (DAG) tugunlarini har bir yo'naltirilgan u‚Üív qirrasi uchun u v dan oldin keladigan tartibda saralaydi. U vazifa jadvalini tuzish, kurs old-shartlari va qurilish tizimlarida ishlatiladi. Kahn algoritmi kirish darajasini sanash va navbatdan foydalanadi: kirish darajasi nolga teng bo'lgan tugunlarni takroriy olib tashlang. Vaqt: O(V + E). Agar graf siklga ega bo'lsa, to'g'ri topologik tartib mavjud emas.",
        toposort_time: "O(V + E).",
        space_label: "Xotira:",
        num_nodes: "Tugunlar soni:",
        edges_label: "Qirralarni qo'shish (u‚Üív):",
        btn_run_topo: "Topologik Saralashni Ishga Tushirish",
        btn_clear_edges: "Qirralarni Tozalash",
        btn_random_graph: "Tasodifiy DAG",
        current_edges: "Joriy qirralar:",
        in_degree: "Kirish darajasi:",
        result_heading: "Natija",
        instructions: "Qanday foydalanish kerak",
        instr1: "Tugunlar sonini belgilang (1-10)",
        instr2: "\"Dan ‚Üí Ga\" yordamida yo'naltirilgan qirralarni qo'shing",
        instr3: "Qadam-qadam bajarilishini ko'rish uchun \"Topologik Saralashni Ishga Tushirish\" tugmasini bosing",
        instr4: "Yashil tugunlar = ishlangan, Sariq = navbatda, Qizil = sikl aniqlangan",
        instr5: "To'g'ri misol uchun \"Tasodifiy DAG\" yoki tozalash uchun \"Qirralarni Tozalash\"dan foydalaning",
        alert_valid_numbers: "Iltimos, to'g'ri raqamlarni kiriting",
        alert_node_range: "Tugun indekslari 0 dan {max} gacha bo'lishi kerak",
        alert_no_self_loop: "O'z-o'ziga qirralar (u‚Üíu) ruxsat etilmagan",
        alert_duplicate_edge: "Bu qirra allaqachon mavjud",
        topo_order: "Topologik tartib",
        cycle_detected: "Sikl aniqlangan! Topologik saralash faqat DAGlarda (Yo'naltirilgan Aylanmas Graflarda) ishlaydi.",
        kruskal_desc: "Kruskal algoritmi bog'langan, yo'naltirilmagan grafning minimal uzunlikdagi bog'lovchi daraxtini (MUD) sikl hosil qilmaydigan eng kichik qirrani ochko'z qo'shish orqali topadi. Sikllarni aniqlash uchun Union-Find (ajratilgan to'plamlar birlashmasi) dan foydalanadi. Siyrak graflar uchun ideal. Vaqt: saralash tufayli O(E log E).",
        kruskal_time: "O(E log E).",
        add_edge_label: "Qirrani qo'shish (u‚Äìv : vazn):",
        btn_run_kruskal: "Kruskal algoritmini ishga tushirish",
        mst_status: "MUD holati:",
        kruskal_instr1: "Tugunlar sonini belgilang (2‚Äì10)",
        kruskal_instr2: "\"u ‚Äì v : vazn\" yordamida vaznli qirralarni qo'shing",
        kruskal_instr3: "MUD ni qadam-qadam qurishni ko'rish uchun \"Kruskal algoritmini ishga tushirish\" tugmasini bosing",
        kruskal_instr4: "Yashil qirralar = MUD da, Kulrang = o'tkazib yuborildi (sikl hosil qilardi)",
        kruskal_instr5: "To'g'ri misol uchun \"Tasodifiy bog'langan graf\"dan foydalaning",
        graph_disconnected: "Graf bog'lanmagan! MUD bog'langan grafni talab qiladi.",
        floyd_desc: "Floyd-Vorshol vaznli grafning barcha tugun juftlari orasidagi eng qisqa yo'lni hisoblaydi (manfiy vaznlarni, lekin manfiy sikllarni emas). U uchta ichma-ich siklli dinamik dasturlashdan foydalanadi. Vaqt: O(V¬≥). Bitta manbadan emas, balki barcha eng qisqa yo'llar kerak bo'lganda foydalidir.",
        floyd_time: "O(V¬≥).",
        ph_floyd_edges: "Yo'naltirilgan qirralar: a-b:w,...",
        ph_floyd_nodes: "Tugunlar",
        btn_run_floyd: "Floyd-Vorsholni Ishga Tushirish",
        sliding_desc: "Sirpanuvchi oyna texnikasi berilgan cheklovlarga javob beradigan 'oyna' (ostki massiv) ni saqlab turish orqali massiv/satr muammolarini optimallashtiradi. Har bir ostki massiv uchun hamma narsani qayta hisoblamasdan, oynani bosh/oxir ko'rsatkichlarini siljitish orqali sozlaydi. Odatiy qo'llanish sohalari: k hajmdagi ostki massivning maksimal yig'indisi, takrorlanmaydigan belgilar bilan eng uzun ostki satr. Vaqt: O(n).",
        sliding_time: "O(n).",
        max_sum_subarray: "K Hajmdagi Ostki Massivning Maksimal Yig'indisi",
        ph_sw_array: "Massiv",
        ph_sw_k: "Oyna hajmi k",
        msg_array_empty: "Massiv bo'sh",
        msg_found_index: "{i}-indeksda topildi!",
        msg_not_found: "Topilmadi",
        msg_running: "Bajarilmoqda...",
        msg_done_steps: "Tugadi ‚Äì {steps} qadam",
        msg_steps: "Qadamlar: {steps}",
        msg_searching: "Qidirilmoqda...",
        msg_found_target: "{target} {i}-indeksda topildi!",
        msg_not_found_steps: "{steps} qadamdan keyin topilmadi",
        msg_load_array_first: "Avval massivni yuklang",
        msg_enter_values_tree: "Qiymat kiriting va 'Daraxtni qurish' ni bosing",
        msg_enter_values_bst: "Qiymat kiriting va 'BST qurish' ni bosing",
        msg_trie_empty: "Trie bo'sh.",
        msg_trie_built: "Trie {count} ta so'z bilan qurildi.",
        msg_trie_inserted: "So'z qo'shildi: {word}",
        msg_trie_searching: "Qidirilmoqda: {word}",
        msg_prefix_not_found: "Prefiks/so'z topilmadi: {word}",
        msg_prefix_found: "Prefiks bor, lekin to'liq so'z emas: {word}",
        msg_word_found: "So'z topildi: {word}",
        msg_heap_empty: "Heap bo'sh ‚Äî element kiriting",
        msg_no_path: "Yo'l topilmadi",
        msg_linear_range: "Oraliqda chiziqli qidiruv: [{a}, {b}]",
        msg_binary_range: "Oraliqda ikkilik qidiruv: [{a}, {b}]",
        nav_rotting: "Chirituvchi Apelsinlar",
        rotting_title: "Chirgatuvchi Apelsinlar Sandqog'i",
rotting_desc: "Rotting Oranges muammosi ‚Äî to'ldirilgan matritsada (grid) xar bir katakda bo'sh (0), yangi apelsin (1) yoki chirgan apelsin (2) mavjud. Har bir daqiqa, chirgan apelsinlar barcha to'g'ri chiqishdagi (yuqori, past, chap, o'ng) yangi apelsinlarni chirgatadi. Barcha yangi apelsinlar chirgacha ketadigan minimal daqiqalarni toping. Agar barchasini chirgatib bo'lmasa, -1 qaytaring.",
btn_add_fresh: "Yangi Qo'shish üçä",
btn_add_rotten: "Chirgatuvchi Qo'shish üçä",
btn_clear_grid: "Tozalash",
btn_random_grid: "Tasodifiy Matritsa",
btn_run_rotting: "Simulyatsiyani Ishga Tushirish",
grid_status: "Matritsa Holati:",
simulation_speed: "Simulyatsiya Tezligi:",
result_heading: "Natija",
instructions: "Qanday foydalanish kerak",
rotting_instr1: "Katakchalarni bosib Bo'sh (‚¨õ), Yangi (üçä) va Chirgatuvchi (ü¶†) orasida almashtiring",
rotting_instr2: "\"Yangi/Chirgatuvchi Qo'shish\" tugmalaridan foydalanib tezda apelsinlarni joylashtiring",
rotting_instr3: "Daqiqalar bo'yicha chirish jarayonini ko'rish uchun \"Simulyatsiyani Ishga Tushirish\" tugmasini bosing",
rotting_instr4: "Yashil = Yangi, Qizil = Chirgatuvchi, Qora = Bo'sh",
rotting_instr5: "Natija kerakli daqiqalarni yoki agar iloji bo'lmasa -1 ni ko'rsatadi",
nav_advanced_sorting: "Murakkab Saralash",
advanced_sorting_title: "Murakkab Saralash Algoritmlari",
select_algorithm: "Algoritmni tanlang:",
btn_run_sort: "Saralashni Ishga Tushirish",
btn_random_data: "Tasodifiy Ma'lumotlar",
adv_instr1: "Vergul bilan ajratilgan raqamlarni kiriting yoki \"Tasodifiy Ma'lumotlar\"dan foydalaning",
adv_instr2: "Pastdan algoritmni tanlang",
adv_instr3: "Qadam-qadam vizualizatsiyani ko'rish uchun \"Saralashni Ishga Tushirish\" tugmasini bosing",
adv_instr4: "Yashil ustunlar = saralangan, Sariq = joriy qayta ishlash, Qizil = taqqoslash",

nav_string_algos: "Satr Moslash",
string_algos_title: "Satr Moslash Algoritmlari",
select_algorithm: "Algoritmni tanlang:",
btn_run_search: "Qidiruvni Ishga Tushirish",
btn_random_text: "Tasodifiy Matn",
text_input: "Matn:",
pattern_input: "Namuna:",
str_instr1: "Matn va namunani kiriting yoki \"Tasodifiy Matn\"dan foydalaning",
str_instr2: "Pastdan algoritmni tanlang",
str_instr3: "Qadam-qadam moslash jarayonini ko'rish uchun \"Qidiruvni Ishga Tushirish\" tugmasini bosing",
str_instr4: "Yashil = moslik topildi, Sariq = joriy taqqoslash, Qizil = mos kelmaslik",

nav_dp_algos: "Dinamik Dasturlash",
dp_algos_title: "Dinamik Dasturlash Algoritmlari",
select_algorithm: "Algoritmni tanlang:",
btn_run_dp: "Algoritmni Ishga Tushirish",
btn_random_data: "Tasodifiy Ma'lumotlar",
weights_input: "Og'irliklar:",
values_input: "Qiymatlar:",
capacity_input: "Sig'im:",
string1_input: "Satr 1:",
string2_input: "Satr 2:",
dimensions_input: "Matritsa O'lchamlari:",
matrix_help: "n ta matritsa uchun n+1 ta o'lcham kiriting",
dp_instr1: "Pastdan algoritmni tanlang",
dp_instr2: "Kerakli ma'lumotlarni kiriting yoki \"Tasodifiy Ma'lumotlar\"dan foydalaning",
dp_instr3: "Qadam-qadam DP jadvalini qurishni ko'rish uchun \"Algoritmni Ishga Tushirish\" tugmasini bosing",
dp_instr4: "Yashil kataklar = optimal yechim yo'li, Ko'k = joriy hisoblash"
      }
    };

    function T(key, vars = {}) {
      const dict = I18N[currentLang] || I18N.en;
      let s = dict[key] ?? I18N.en[key] ?? key;
      Object.keys(vars).forEach(k => {
        s = s.replaceAll(`{${k}}`, String(vars[k]));
      });
      return s;
    }

    function applyI18n() {
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        const value = T(key);
        el.textContent = value;
      });
      document.querySelectorAll('[data-i18n-ph]').forEach(el => {
        const key = el.getAttribute('data-i18n-ph');
        el.setAttribute('placeholder', T(key));
      });
    }

    function setLang(lang) {
      currentLang = (lang === 'uz' || lang === 'en') ? lang : 'en';
      localStorage.setItem('app-lang', currentLang);
      applyI18n();
      if (typeof updateArrayStatus === 'function') updateArrayStatus();
      if (typeof visualizeArray === 'function') visualizeArray();
      // Update linked list explanations
      if (typeof updateLinkedListExplanation === 'function') updateLinkedListExplanation();
      // Update topo sort explanation
      if (typeof updateTopoExplanation === 'function') updateTopoExplanation();
      // Update kruskal explanation
      if (typeof updateKruskalExplanation === 'function') updateKruskalExplanation();
    }

    // ====================== UTILITY FUNCTIONS ======================
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ====================== NAVIGATION ======================
    function show(id) {
      document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
      document.getElementById(id).classList.add('active');
    }

    // ====================== GLOBAL SEARCH ======================
    const dsaIndex = [
      { id: 'arrays', title: T('nav_arrays'), keywords: 'array list dynamic resize push pop insert delete search' },
      { id: 'sorting', title: T('nav_sorting'), keywords: 'sort bubble quick merge heap insertion selection' },
      { id: 'searching', title: T('nav_searching'), keywords: 'search linear binary jump exponential find' },
      { id: 'bt', title: T('nav_bt'), keywords: 'tree binary complete node parent child' },
      { id: 'bst', title: T('nav_bst'), keywords: 'bst binary search tree ordered sorted' },
      { id: 'avl', title: T('nav_avl'), keywords: 'avl balanced rotation height factor' },
      { id: 'trie', title: T('nav_trie'), keywords: 'trie prefix string dictionary autocomplete' },
      { id: 'heaps', title: T('nav_heaps'), keywords: 'heap min max priority queue heap sort' },
      { id: 'graphs', title: T('nav_graphs'), keywords: 'graph bfs dfs breadth depth first' },
      { id: 'bellman', title: T('nav_bellman'), keywords: 'bellman ford shortest path negative weight' },
      { id: 'dijkstra', title: T('nav_dijkstra'), keywords: 'dijkstra shortest path non-negative' },
      { id: 'astar', title: T('nav_astar'), keywords: 'a star astar pathfinding heuristic grid' },
      { id: 'recursion', title: T('nav_recursion'), keywords: 'recursion hanoi tower divide conquer' },
      { id: 'linkedlist', title: T('nav_linkedlist'), keywords: 'linked list node pointer prepend append delete' },
      { id: 'hashtable', title: T('nav_hashtable'), keywords: 'hash table map dictionary key value collision' },
      { id: 'toposort', title: T('nav_toposort'), keywords: 'topo sort dag dependency ordering' },
      { id: 'kruskal', title: T('nav_kruskal'), keywords: 'kruskal mst minimum spanning tree union find' },
      { id: 'floyd', title: T('nav_floyd'), keywords: 'floyd warshall all pairs shortest path' },
      { id: 'sliding', title: T('nav_sliding'), keywords: 'sliding window subarray substring' },
      { id: 'time-complexity', title: T('nav_time_complexity'), keywords: 'big o time complexity growth rate' },
      { id: 'space-complexity', title: T('nav_space_complexity'), keywords: 'space memory auxiliary stack' },
      { id: 'complexity', title: T('nav_complexity'), keywords: 'race comparison big o visualization' },
      { id: 'rotting', title: T('nav_rotting'), keywords: 'rotting oranges bfs grid simulation' },
      { id: 'advanced-sorting', title: T('nav_advanced_sorting'), keywords: 'timsort radix counting advanced sort' },
      { id: 'string-algos', title: T('nav_string_algos'), keywords: 'kmp rabin-karp z-algorithm string matching' },
      { id: 'dp-algos', title: T('nav_dp_algos'), keywords: 'knapsack lcs matrix chain multiplication dynamic programming' }
    ];

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function fuzzyMatch(query, text) {
      query = query.toLowerCase();
      text = text.toLowerCase();
      let j = 0;
      for (let i = 0; i < query.length; i++) {
        const index = text.indexOf(query[i], j);
        if (index === -1) return false;
        j = index + 1;
      }
      return true;
    }

    function performSearch() {
      const input = document.getElementById('global-search');
      const resultsDiv = document.getElementById('search-results');
      const query = input.value.trim();
      if (!query) {
        resultsDiv.style.display = 'none';
        return;
      }
      const matches = dsaIndex.filter(item =>
        fuzzyMatch(query, item.title) || fuzzyMatch(query, item.keywords)
      );
      if (matches.length === 0) {
        resultsDiv.innerHTML = '<div style="padding:12px;color:#888;">' + T('msg_not_found') + '</div>';
        resultsDiv.style.display = 'block';
        return;
      }
      resultsDiv.innerHTML = matches.map(item =>
        `<div onclick="show('${item.id}'); document.getElementById('global-search').value=''; resultsDiv.style.display='none';"
        style="padding:12px 16px; cursor:pointer; border-bottom:1px solid #333; transition:background 0.2s;">
        <strong>${item.title}</strong>
        </div>`
      ).join('');
      resultsDiv.style.display = 'block';
    }

    document.getElementById('global-search').addEventListener('input', debounce(performSearch, 200));
    document.addEventListener('click', (e) => {
      const searchBox = document.getElementById('global-search');
      const resultsDiv = document.getElementById('search-results');
      if (!searchBox.contains(e.target) && !resultsDiv.contains(e.target)) {
        resultsDiv.style.display = 'none';
      }
    });

    // ====================== TIME COMPLEXITY ANIMATION ======================
    async function animateTimeGrowth() {
      const n = parseInt(document.getElementById('time-n').value) || 50;
      const canvas = document.getElementById('time-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(80, 450);
      ctx.lineTo(1050, 450);
      ctx.moveTo(80, 50);
      ctx.lineTo(80, 450);
      ctx.stroke();
      const funcs = [
        { name: 'O(1)', color: '#00ff88', fn: () => 1 },
        { name: 'O(log n)', color: '#00ccff', fn: (x) => Math.log2(x || 1) },
        { name: 'O(n)', color: '#ffeb3b', fn: (x) => x },
        { name: 'O(n log n)', color: '#ff9800', fn: (x) => x * Math.log2(x || 1) },
        { name: 'O(n¬≤)', color: '#ff5252', fn: (x) => x * x },
        { name: 'O(2‚Åø)', color: '#e040fb', fn: (x) => Math.pow(2, Math.min(x / 5, 15)) }
      ];
      const maxVal = Math.max(...funcs.map(f => f.fn(n)));
      const scaleY = 400 / (maxVal || 1);
      for (let step = 1; step <= n; step += Math.max(1, Math.floor(n / 100))) {
        ctx.clearRect(81, 0, 970, 450);
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(80, 450);
        ctx.lineTo(1050, 450);
        ctx.moveTo(80, 50);
        ctx.lineTo(80, 450);
        ctx.stroke();
        funcs.forEach(f => {
          ctx.strokeStyle = f.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          for (let x = 1; x <= step; x++) {
            const y = 450 - f.fn(x) * scaleY;
            const screenX = 80 + (x / n) * 970;
            if (x === 1) ctx.moveTo(screenX, y);
            else ctx.lineTo(screenX, y);
          }
          ctx.stroke();
        });
        document.getElementById('time-info').textContent = `Simulating growth for n = ${step}...`;
        await sleep(20);
      }
      document.getElementById('time-info').innerHTML = '<span style="color:#0f0">Animation complete! Lower curve = more efficient.</span>';
    }

    function resetTimeCanvas() {
      const ctx = document.getElementById('time-canvas').getContext('2d');
      ctx.clearRect(0, 0, 1100, 500);
      document.getElementById('time-info').textContent = T('time_info');
    }

    // ====================== SPACE COMPLEXITY ANIMATION ======================
    async function animateSpaceUsage() {
      const n = parseInt(document.getElementById('space-n').value) || 10;
      const canvas = document.getElementById('space-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const recursiveSpace = n;
      const iterativeSpace = 1;
      const barWidth = 200;
      const gap = 100;
      const startX1 = (canvas.width - (2 * barWidth + gap)) / 2;
      const startX2 = startX1 + barWidth + gap;
      const baseY = 300;
      const scaleY = 200 / Math.max(recursiveSpace, 10);
      ctx.fillStyle = '#ff5252';
      ctx.fillRect(startX1, baseY - recursiveSpace * scaleY, barWidth, recursiveSpace * scaleY);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.strokeRect(startX1, baseY - recursiveSpace * scaleY, barWidth, recursiveSpace * scaleY);
      ctx.fillStyle = '#00ff88';
      ctx.fillRect(startX2, baseY - iterativeSpace * scaleY, barWidth, iterativeSpace * scaleY);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.strokeRect(startX2, baseY - iterativeSpace * scaleY, barWidth, iterativeSpace * scaleY);
      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Recursive', startX1 + barWidth / 2, baseY + 40);
      ctx.fillText('Iterative', startX2 + barWidth / 2, baseY + 40);
      ctx.fillText(`O(n) = ${recursiveSpace}`, startX1 + barWidth / 2, baseY - recursiveSpace * scaleY - 20);
      ctx.fillText(`O(1) = ${iterativeSpace}`, startX2 + barWidth / 2, baseY - iterativeSpace * scaleY - 20);
      ctx.font = '28px Arial';
      ctx.fillText(`Memory Usage for n = ${n}`, canvas.width / 2, 80);
      document.getElementById('space-info').innerHTML = `<span style="color:#0f0">Recursive uses ${recursiveSpace}x more memory than iterative!</span>`;
    }

    // ====================== COMPLEXITY RACE ======================
    const complexityAlgos = {
      'bubble': {
        name: 'Bubble Sort',
        time: 'O(n¬≤)',
        space: 'O(1)',
        desc: 'Repeatedly swaps adjacent elements if in wrong order. Inefficient for large datasets.',
        verdict: 'Simple but inefficient. Use only for teaching or extremely small datasets.',
        code: `def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr`,
        simulate: (n) => n * n
      },
      'quick': {
        name: 'Quick Sort',
        time: 'O(n log n) avg, O(n¬≤) worst',
        space: 'O(log n)',
        desc: 'Divide-and-conquer using a pivot. Fast in practice but worst-case is poor.',
        verdict: 'The standard for general sorting. Fast, but watch out for worst-case O(n¬≤) scenarios.',
        code: `def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)`,
        simulate: (n) => n * Math.log2(n || 1)
      },
      'merge': {
        name: 'Merge Sort',
        time: 'O(n log n)',
        space: 'O(n)',
        desc: 'Stable, divide-and-conquer. Always O(n log n) but uses extra memory.',
        verdict: 'Reliable and stable. Great for linked lists or when O(n log n) guarantee is needed.',
        code: `def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    merged = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged`,
        simulate: (n) => n * Math.log2(n || 1)
      },
      'linear': {
        name: 'Linear Search',
        time: 'O(n)',
        space: 'O(1)',
        desc: 'Checks each element sequentially. Works on unsorted data.',
        verdict: 'Okay for small or unsorted lists. Too slow for large datasets.',
        code: `def linear_search(arr, target):
    for i, val in enumerate(arr):
        if val == target:
            return i
    return -1`,
        simulate: (n) => n
      },
      'binary': {
        name: 'Binary Search',
        time: 'O(log n)',
        space: 'O(1)',
        desc: 'Halves search space each step. Requires sorted input.',
        verdict: 'Excellent for sorted lists. Much faster than linear search.',
        code: `def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1`,
        simulate: (n) => Math.log2(n || 1)
      },
      'fib-recursive': {
        name: 'Fibonacci (Recursive)',
        time: 'O(2‚Åø)',
        space: 'O(n)',
        desc: 'Naive recursion. Exponential time due to repeated calculations.',
        verdict: 'Terrible performance for n > 30. Good only for understanding recursion.',
        code: `def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)`,
        simulate: (n) => Math.pow(2, n)
      },
      'fib-dp': {
        name: 'Fibonacci (Dynamic Programming)',
        time: 'O(n)',
        space: 'O(n)',
        desc: 'Stores previous results to avoid recomputation. Linear time.',
        verdict: 'Deeply efficient compared to naive recursion. Classic example of Time-Space tradeoff.',
        code: `def fib(n):
    if n <= 1:
        return n
    dp = [0] * (n+1)
    dp[1] = 1
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]`,
        simulate: (n) => n
      },
      'insertion': {
        name: 'Insertion Sort',
        time: 'O(n¬≤)',
        space: 'O(1)',
        desc: 'Builds sorted array one item at a time. Efficient for small/nearly sorted data.',
        verdict: 'Best for very small arrays (n < 50) or nearly sorted data. Low overhead.',
        code: `def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
        return arr`,
        simulate: (n) => n * n
      },
      'selection': {
        name: 'Selection Sort',
        time: 'O(n¬≤)',
        space: 'O(1)',
        desc: 'Repeatedly finds minimum element and moves it to beginning.',
        verdict: 'Simple, but generally outperformed by Insertion Sort. Not stable.',
        code: `def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        return arr`,
        simulate: (n) => n * n
      },
      'heap': {
        name: 'Heap Sort',
        time: 'O(n log n)',
        space: 'O(1)',
        desc: 'Uses a binary heap to sort. In-place and efficient.',
        verdict: 'Good guaranteed O(n log n) performance without external memory. Not stable.',
        code: `def heap_sort(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr`,
        simulate: (n) => n * Math.log2(n || 1)
      },
      'radix': {
        name: 'Radix Sort',
        time: 'O(nk)',
        space: 'O(n+k)',
        desc: 'Non-comparative integer sort. Processes digits from LSB to MSB.',
        verdict: 'Extremely fast for integers or fixed-length strings. Beats O(n log n) comparison sorts for large inputs.',
        code: `def radix_sort(arr):
    max_num = max(arr)
    exp = 1
    while max_num // exp > 0:
        counting_sort(arr, exp)
        exp *= 10`,
        simulate: (n) => n * 4 // linear-ish simulation
      },
      'access': {
        name: 'Array Access',
        time: 'O(1)',
        space: 'O(1)',
        desc: 'Direct access to an element using its index.',
        verdict: 'Examples: arr[5]. Instant access regardless of array size. The gold standard of speed.',
        code: `def get_element(arr, idx):
    return arr[idx]`,
        simulate: (n) => 1
      },
      'bst': {
        name: 'BST Search',
        time: 'O(log n)',
        space: 'O(n)',
        desc: 'Standard binary search tree lookup.',
        verdict: 'Fast if balanced. Degrades to O(n) if the tree becomes a linked list.',
        code: `def search_bst(root, key):
    if root is None or root.val == key:
        return root
    if root.val < key:
        return search_bst(root.right, key)
    return search_bst(root.left, key)`,
        simulate: (n) => Math.log2(n || 1)
      },
      'hashtable': {
        name: 'Hash Table Search',
        time: 'O(1)',
        space: 'O(n)',
        desc: 'Key-value lookup using a hash function.',
        verdict: 'Unbeatable average speed. Essential for caching and dictionary lookups.',
        code: `def search_hash(table, key):
    return table.get(key)`,
        simulate: (n) => 1
      }
    };

    function showComplexityDetails(algoKey) {
      const algo = complexityAlgos[algoKey];
      document.getElementById('complexity-title').textContent = algo.name;
      document.getElementById('complexity-code').textContent = algo.code;
      document.getElementById('complexity-desc').textContent = algo.desc;
      document.getElementById('complexity-verdict').innerHTML = `<span style="color:#0f0">${algo.verdict}</span>`;
      document.getElementById('time-complexity').textContent = algo.time;
      document.getElementById('space-complexity').textContent = algo.space;
      document.getElementById('complexity-explanation').style.display = 'block';
    }

    document.getElementById('complexity-canvas').addEventListener('click', (e) => {
      const rect = e.target.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (y < 250) {
        showComplexityDetails(document.getElementById('algo-a').value);
      } else {
        showComplexityDetails(document.getElementById('algo-b').value);
      }
    });

    async function runComplexityRace() {
      const algoA = document.getElementById('algo-a').value;
      const algoB = document.getElementById('algo-b').value;
      const canvas = document.getElementById('complexity-canvas');
      const ctx = canvas.getContext('2d');
      if (algoA === algoB) {
        document.getElementById('complexity-info').innerHTML = '<span style="color:#ffeb3b">Please select two different algorithms!</span>';
        return;
      }
      document.getElementById('complexity-info').textContent = 'Racing...';
      document.getElementById('complexity-explanation').style.display = 'none';
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(80, 450);
      ctx.lineTo(1050, 450);
      ctx.moveTo(80, 50);
      ctx.lineTo(80, 450);
      ctx.stroke();
      ctx.fillStyle = '#aaa';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      for (let i = 0; i <= 10; i++) {
        const x = 80 + i * 97;
        const n = i * 10;
        ctx.fillText(`n=${n}`, x, 470);
      }
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const y = 450 - i * 80;
        const ops = i * 100;
        ctx.fillText(`${ops}`, 70, y + 5);
      }
      const pointsA = [];
      const pointsB = [];
      const maxN = 100;
      const step = 5;
      for (let n = 5; n <= maxN; n += step) {
        const opsA = Math.min(complexityAlgos[algoA].simulate(n), 500);
        const opsB = Math.min(complexityAlgos[algoB].simulate(n), 500);
        pointsA.push({ x: 80 + (n / 100) * 970, y: 450 - opsA });
        pointsB.push({ x: 80 + (n / 100) * 970, y: 450 - opsB });
        ctx.clearRect(81, 0, 970, 450);
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(80, 450);
        ctx.lineTo(1050, 450);
        ctx.moveTo(80, 50);
        ctx.lineTo(80, 450);
        ctx.stroke();
        drawCurve(ctx, pointsA, '#ff6b6b', 'Algorithm A');
        drawCurve(ctx, pointsB, '#4ecdc4', 'Algorithm B');
        await sleep(150);
      }
      document.getElementById('complexity-info').innerHTML =
        `<span style="color:#0f0">Race complete! Click on either curve to see details.</span>`;
    }

    function drawCurve(ctx, points, color, label) {
      if (points.length === 0) return;
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.stroke();
      const last = points[points.length - 1];
      ctx.fillStyle = color;
      ctx.font = '16px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(label, last.x + 10, last.y);
    }

    function resetComplexity() {
      document.getElementById('complexity-explanation').style.display = 'none';
      document.getElementById('complexity-info').textContent = T('complexity_info');
      const ctx = document.getElementById('complexity-canvas').getContext('2d');
      ctx.clearRect(0, 0, 1100, 500);
    }

    // ====================== 1. DYNAMIC ARRAY ======================
    let dynamicArray = [];
    function loadArrayFromInput() {
      const vals = document.getElementById('array-input').value.split(',').map(n => Number(n.trim())).filter(n => !isNaN(n));
      dynamicArray = vals;
      visualizeArray();
    }
    function updateArrayStatus() {
      document.getElementById('array-status').textContent = `Array: [${dynamicArray.join(', ')}] | Length: ${dynamicArray.length}`;
    }
    function visualizeArray() {
      const arr = dynamicArray;
      const canvas = document.getElementById('array-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (arr.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(T('msg_array_empty'), canvas.width / 2, canvas.height / 2);
        updateArrayStatus();
        return;
      }
      const maxVal = Math.max(...arr, 10);
      const cellW = Math.min(100, canvas.width / arr.length * 0.85);
      const startX = (canvas.width - arr.length * cellW) / 2;
      const baseY = canvas.height - 100;
      arr.forEach((val, i) => {
        const h = (val / maxVal) * 220;
        const x = startX + i * cellW;
        ctx.fillStyle = '#00d4ff';
        ctx.fillRect(x + 10, baseY - h, cellW - 20, h);
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.strokeRect(x + 10, baseY - h, cellW - 20, h);
        ctx.fillStyle = 'white';
        ctx.font = '22px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(val, x + cellW / 2, baseY - h - 10);
        ctx.fillStyle = '#aaa';
        ctx.font = '16px Arial';
        ctx.fillText(i, x + cellW / 2, baseY + 30);
      });
      updateArrayStatus();
    }
    function insertAt() {
      const v = Number(document.getElementById('insert-val').value);
      let i = Number(document.getElementById('insert-idx').value);
      if (isNaN(v)) return;
      i = Math.max(0, Math.min(i, dynamicArray.length));
      dynamicArray.splice(i, 0, v);
      visualizeArray();
    }
    function deleteAt() {
      const i = Number(document.getElementById('delete-idx').value);
      if (i >= 0 && i < dynamicArray.length) {
        dynamicArray.splice(i, 1);
        visualizeArray();
      }
    }
    function pushValue() {
      const v = Number(document.getElementById('push-val').value);
      if (!isNaN(v)) {
        dynamicArray.push(v);
        visualizeArray();
      }
    }
    function popValue() {
      if (dynamicArray.length > 0) {
        dynamicArray.pop();
        visualizeArray();
      }
    }
    function unshiftValue() {
      const v = Number(document.getElementById('unshift-val').value);
      if (!isNaN(v)) {
        dynamicArray.unshift(v);
        visualizeArray();
      }
    }
    function shiftValue() {
      if (dynamicArray.length > 0) {
        dynamicArray.shift();
        visualizeArray();
      }
    }
    function clearArray() {
      dynamicArray = [];
      visualizeArray();
    }
    function searchArraySearch() {
      const val = Number(document.getElementById('search-val').value);
      const idx = dynamicArray.indexOf(val);
      const canvas = document.getElementById('array-canvas');
      const ctx = canvas.getContext('2d');
      if (idx === -1) {
        ctx.fillStyle = 'rgba(255,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f66';
        ctx.font = '36px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(T('msg_not_found'), canvas.width / 2, canvas.height / 2);
        setTimeout(visualizeArray, 1500);
      } else {
        const cellW = Math.min(100, canvas.width / dynamicArray.length * 0.85);
        const startX = (canvas.width - dynamicArray.length * cellW) / 2;
        const x = startX + idx * cellW;
        ctx.fillStyle = 'rgba(0,255,0,0.4)';
        ctx.fillRect(x, 50, cellW, canvas.height - 100);
        ctx.fillStyle = '#0f0';
        ctx.font = '32px Arial';
        ctx.fillText(T('msg_found_index', { i: idx }), canvas.width / 2, 100);
        setTimeout(visualizeArray, 2000);
      }
    }

    // ====================== 2. SORTING ======================
    let sortArray = [], sortingSteps = 0;
    async function startSorting() {
      sortArray = document.getElementById('sort-input').value.split(',').map(Number).filter(n => !isNaN(n));
      sortingSteps = 0;
      document.getElementById('sort-info').textContent = T('msg_running');
      drawSort(sortArray);
      const algo = document.getElementById('sort-algo').value;
      if (algo === 'bubble') await bubbleSortVis();
      if (algo === 'quick') await quickSortVis(0, sortArray.length - 1);
      if (algo === 'merge') await mergeSortVis(0, sortArray.length - 1);
      document.getElementById('sort-info').textContent = T('msg_done_steps', { steps: sortingSteps });
    }
    function drawSort(arr) {
      const canvas = document.getElementById('sort-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const w = canvas.width / arr.length;
      arr.forEach((v, i) => {
        const h = (v / Math.max(...arr, 1)) * 380;
        ctx.fillStyle = `hsl(${v * 4},80%,50%)`;
        ctx.fillRect(i * w + 5, canvas.height - h - 40, w - 10, h);
        ctx.fillStyle = '#fff';
        ctx.fillText(v, i * w + w / 2, canvas.height - 15);
      });
    }
    async function bubbleSortVis() {
      for (let i = 0; i < sortArray.length; i++) {
        for (let j = 0; j < sortArray.length - i - 1; j++) {
          if (sortArray[j] > sortArray[j + 1]) {
            [sortArray[j], sortArray[j + 1]] = [sortArray[j + 1], sortArray[j]];
            sortingSteps++;
            drawSort(sortArray);
            await sleep(30);
          }
        }
      }
    }
    async function quickSortVis(low, high) {
      if (low < high) {
        let pi = await partition(low, high);
        await quickSortVis(low, pi - 1);
        await quickSortVis(pi + 1, high);
      }
    }
    async function partition(low, high) {
      let pivot = sortArray[high];
      let i = low - 1;
      for (let j = low; j < high; j++) {
        if (sortArray[j] < pivot) {
          i++;
          [sortArray[i], sortArray[j]] = [sortArray[j], sortArray[i]];
          drawSort(sortArray);
          sortingSteps++;
          await sleep(60);
        }
      }
      [sortArray[i + 1], sortArray[high]] = [sortArray[high], sortArray[i + 1]];
      drawSort(sortArray);
      sortingSteps++;
      await sleep(60);
      return i + 1;
    }
    async function mergeSortVis(l, r) {
      if (l >= r) return;
      let m = Math.floor((l + r) / 2);
      await mergeSortVis(l, m);
      await mergeSortVis(m + 1, r);
      await merge(l, m, r);
    }
    async function merge(l, m, r) {
      let left = sortArray.slice(l, m + 1);
      let right = sortArray.slice(m + 1, r + 1);
      let i = 0, j = 0, k = l;
      while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
          sortArray[k++] = left[i++];
        } else {
          sortArray[k++] = right[j++];
        }
        drawSort(sortArray);
        sortingSteps++;
        await sleep(80);
      }
      while (i < left.length) {
        sortArray[k++] = left[i++];
        drawSort(sortArray);
        await sleep(40);
      }
      while (j < right.length) {
        sortArray[k++] = right[j++];
        drawSort(sortArray);
        await sleep(40);
      }
    }
    function resetSorting() {
      sortArray = document.getElementById('sort-input').value.split(',').map(Number).filter(n => !isNaN(n));
      drawSort(sortArray);
      document.getElementById('sort-info').textContent = T('msg_steps', { steps: 0 });
    }

    // ====================== 3. SEARCHING ======================
    let searchArray = [], searchSteps = 0;
    function loadSearchArray() {
      searchArray = document.getElementById('search-input').value.split(',').map(Number).filter(n => !isNaN(n));
      searchSteps = 0;
      document.getElementById('search-steps').textContent = T('msg_steps', { steps: 0 });
      document.getElementById('search-result').textContent = '';
      drawSearchArray([]);
    }
    function drawSearchArray(highlightIndices = [], foundIndex = -1, isSortedSearch = false) {
      const canvas = document.getElementById('search-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = '28px Arial';
      ctx.textAlign = 'center';
      if (searchArray.length === 0) {
        ctx.fillStyle = '#888';
        ctx.fillText(T('msg_load_array_first'), canvas.width / 2, canvas.height / 2);
        return;
      }
      const boxW = 90, gap = 15;
      const totalW = searchArray.length * (boxW + gap) - gap;
      const startX = (canvas.width - totalW) / 2;
      searchArray.forEach((v, i) => {
        const x = startX + i * (boxW + gap);
        let fillStyle = foundIndex === i ? '#00ff88' : highlightIndices.includes(i) ? '#ffeb3b' : '#4488ff';
        if (isSortedSearch && !highlightIndices.includes(i)) fillStyle = '#333';
        ctx.fillStyle = fillStyle;
        ctx.fillRect(x, 140, boxW, 90);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.strokeRect(x, 140, boxW, 90);
        ctx.fillStyle = 'white';
        ctx.font = '32px Arial';
        ctx.textBaseline = 'middle';
        ctx.fillText(v, x + boxW / 2, 185);
        ctx.fillStyle = '#aaa';
        ctx.font = '16px Arial';
        ctx.fillText(i, x + boxW / 2, 260);
      });
    }
    async function startSearch() {
      const target = Number(document.getElementById('target-val').value);
      const algo = document.getElementById('search-algo').value;
      searchSteps = 0;
      document.getElementById('search-result').textContent = T('msg_searching');
      document.getElementById('search-steps').textContent = T('msg_steps', { steps: searchSteps });
      const needsSort = algo !== 'linear';
      if (needsSort) {
        searchArray.sort((a, b) => a - b);
        drawSearchArray([], -1, false);
        await sleep(600);
      }
      if (algo === 'linear') await linearSearchVis(target);
      else if (algo === 'binary') await binarySearchVis(target);
      else if (algo === 'jump') await jumpSearchVis(target);
      else if (algo === 'exponential') await exponentialSearchVis(target);
    }
    async function linearSearchVis(target) {
      let found = false;
      for (let i = 0; i < searchArray.length; i++) {
        searchSteps++;
        document.getElementById('search-steps').textContent = T('msg_steps', { steps: searchSteps });
        drawSearchArray([i], -1, false);
        await sleep(800);
        if (searchArray[i] === target) {
          found = true;
          drawSearchArray([i], i, false);
          document.getElementById('search-result').innerHTML = `<span style="color:#0f0">${T('msg_found_target', { target, i })}</span>`;
          return;
        }
      }
      drawSearchArray([], -1, false);
      document.getElementById('search-result').innerHTML = `<span style="color:#f66">${T('msg_not_found_steps', { steps: searchSteps })}</span>`;
    }
    async function binarySearchVisHelper(target, left, right) {
      let resultIndex = -1;
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        searchSteps++;
        document.getElementById('search-steps').textContent = T('msg_steps', { steps: searchSteps });
        const range = [];
        for (let k = left; k <= right; k++) range.push(k);
        drawSearchArray(range, -1, true);
        const canvas = document.getElementById('search-canvas');
        const ctx = canvas.getContext('2d');
        const boxW = 90, gap = 15;
        const totalW = searchArray.length * (boxW + gap) - gap;
        const startX = (canvas.width - totalW) / 2;
        ctx.fillStyle = '#ffff00';
        ctx.font = '40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('‚ñº', startX + mid * (boxW + gap) + boxW / 2, 100);
        await sleep(1400);
        if (searchArray[mid] === target) {
          resultIndex = mid;
          break;
        } else if (searchArray[mid] < target) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      if (resultIndex !== -1) {
        const range = [];
        for (let k = left; k <= right; k++) range.push(k);
        drawSearchArray(range, resultIndex, true);
        return resultIndex;
      }
      return -1;
    }
    async function binarySearchVis(target) {
      const result = await binarySearchVisHelper(target, 0, searchArray.length - 1);
      if (result !== -1) {
        document.getElementById('search-result').innerHTML = `<span style="color:#0f0">${T('msg_found_target', { target, i: result })}</span>`;
      } else {
        drawSearchArray([], -1, true);
        document.getElementById('search-result').innerHTML = `<span style="color:#f66">${T('msg_not_found_steps', { steps: searchSteps })}</span>`;
      }
    }
    async function jumpSearchVis(target) {
      let n = searchArray.length;
      if (n === 0) return -1;
      let step = Math.floor(Math.sqrt(n));
      let prev = 0;
      while (searchArray[Math.min(step, n) - 1] < target) {
        searchSteps++;
        document.getElementById('search-steps').textContent = `${T('msg_steps', { steps: searchSteps })} (Jump Check)`;
        let blockRange = [];
        for (let k = prev; k < Math.min(step, n); k++) blockRange.push(k);
        drawSearchArray(blockRange, -1, true);
        await sleep(1000);
        prev = step;
        step += Math.floor(Math.sqrt(n));
        if (prev >= n) break;
      }
      let end = Math.min(step, n);
      document.getElementById('search-result').textContent = T('msg_linear_range', { a: prev, b: end - 1 });
      let finalRange = [];
      for (let k = prev; k < end; k++) finalRange.push(k);
      drawSearchArray(finalRange, -1, true);
      await sleep(800);
      let resultIndex = -1;
      for (let i = prev; i < end; i++) {
        searchSteps++;
        document.getElementById('search-steps').textContent = `${T('msg_steps', { steps: searchSteps })} (Linear Check)`;
        drawSearchArray([i], -1, true);
        await sleep(800);
        if (searchArray[i] === target) {
          resultIndex = i;
          break;
        }
      }
      if (resultIndex !== -1) {
        drawSearchArray([resultIndex], resultIndex, true);
        document.getElementById('search-result').innerHTML = `<span style="color:#0f0">${T('msg_found_target', { target, i: resultIndex })}</span>`;
      } else {
        drawSearchArray([], -1, true);
        document.getElementById('search-result').innerHTML = `<span style="color:#f66">${T('msg_not_found_steps', { steps: searchSteps })}</span>`;
      }
      return resultIndex;
    }
    async function exponentialSearchVis(target) {
      let n = searchArray.length;
      if (n === 0) return -1;
      if (searchArray[0] === target) {
        searchSteps++;
        document.getElementById('search-steps').textContent = `${T('msg_steps', { steps: searchSteps })} (Initial Check)`;
        drawSearchArray([0], 0, false);
        document.getElementById('search-result').innerHTML = `<span style="color:#0f0">${T('msg_found_target', { target, i: 0 })}</span>`;
        return 0;
      }
      let i = 1;
      while (i < n && searchArray[i] <= target) {
        searchSteps++;
        document.getElementById('search-steps').textContent = `${T('msg_steps', { steps: searchSteps })} (Exponential Jump Check)`;
        drawSearchArray([i], -1, false);
        await sleep(1000);
        i *= 2;
      }
      let left = Math.floor(i / 2);
      let right = Math.min(i, n - 1);
      document.getElementById('search-result').textContent = T('msg_binary_range', { a: left, b: right });
      let finalRange = [];
      for (let k = left; k <= right; k++) finalRange.push(k);
      drawSearchArray(finalRange, -1, true);
      await sleep(800);
      const result = await binarySearchVisHelper(target, left, right);
      if (result === -1) {
        drawSearchArray([], -1, true);
        document.getElementById('search-result').innerHTML = `<span style="color:#f66">${T('msg_not_found_steps', { steps: searchSteps })}</span>`;
      } else {
        document.getElementById('search-result').innerHTML = `<span style="color:#0f0">${T('msg_found_target', { target, i: result })}</span>`;
      }
    }
    function resetSearch() {
      loadSearchArray();
    }

    // ====================== 4. BINARY TREE (BT) ======================
    let btArray = [];
    let highlightBTNode = null;
    function buildBT() {
      btArray = document.getElementById('bt-input').value.split(',').map(Number).filter(n => !isNaN(n));
      drawTree(btArray, 'bt-canvas', highlightBTNode);
    }
    function clearBT() {
      btArray = [];
      drawTree(btArray, 'bt-canvas', highlightBTNode);
      document.getElementById('bt-traversal-output').textContent = '';
    }
    function drawTree(dataArray, canvasId, highlightNode) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (dataArray.length === 0) {
        ctx.fillStyle = '#888';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(T('msg_enter_values_tree'), canvas.width / 2, canvas.height / 2);
        return;
      }
      const nodeRadius = 30;
      const levelHeight = 90;
      const baseY = 80;
      const depth = Math.floor(Math.log2(dataArray.length)) + 1;
      const maxNodesAtDepth = Math.pow(2, depth - 1);
      const totalWidth = canvas.width - 100;
      const nodeSpacing = totalWidth / (maxNodesAtDepth + 1);
      for (let i = 0; i < dataArray.length; i++) {
        const level = Math.floor(Math.log2(i + 1));
        const nodesAtLevel = Math.pow(2, level);
        const positionInLevel = i - (nodesAtLevel - 1);
        const levelWidth = nodeSpacing * (Math.pow(2, level) + 1);
        const startX = (canvas.width - levelWidth) / 2;
        const x = startX + (positionInLevel + 1) * nodeSpacing;
        const y = baseY + level * levelHeight;
        if (i > 0) {
          const parentIndex = Math.floor((i - 1) / 2);
          const parentLevel = Math.floor(Math.log2(parentIndex + 1));
          const parentNodesAtLevel = Math.pow(2, parentLevel);
          const parentPosition = parentIndex - (parentNodesAtLevel - 1);
          const parentLevelWidth = nodeSpacing * (Math.pow(2, parentLevel) + 1);
          const parentStartX = (canvas.width - parentLevelWidth) / 2;
          const parentX = parentStartX + (parentPosition + 1) * nodeSpacing;
          const parentY = baseY + parentLevel * levelHeight;
          ctx.strokeStyle = '#00d4ff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(parentX, parentY + nodeRadius);
          ctx.lineTo(x, y - nodeRadius);
          ctx.stroke();
        }
        ctx.fillStyle = (i === highlightNode) ? '#ff0' : '#667eea';
        ctx.beginPath();
        ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(dataArray[i], x, y);
        ctx.fillStyle = '#aaa';
        ctx.font = '14px Arial';
        ctx.fillText(`[${i}]`, x, y + nodeRadius + 15);
      }
    }
    async function traverseBT(type) {
      const result = [];
      highlightBTNode = null;
      drawTree(btArray, 'bt-canvas', highlightBTNode);
      if (btArray.length === 0) return;
      if (type === 'inorder') {
        await inorderBT(0, result);
      } else if (type === 'preorder') {
        await preorderBT(0, result);
      } else if (type === 'postorder') {
        await postorderBT(0, result);
      }
      document.getElementById('bt-traversal-output').textContent = `${type.toUpperCase()}: ${result.join(' ‚Üí ')}`;
      highlightBTNode = null;
      drawTree(btArray, 'bt-canvas', highlightBTNode);
    }
    async function inorderBT(i, res) {
      if (i >= btArray.length) return;
      await inorderBT(2 * i + 1, res);
      res.push(btArray[i]);
      highlightBTNode = i;
      drawTree(btArray, 'bt-canvas', highlightBTNode);
      await sleep(800);
      await inorderBT(2 * i + 2, res);
    }
    async function preorderBT(i, res) {
      if (i >= btArray.length) return;
      res.push(btArray[i]);
      highlightBTNode = i;
      drawTree(btArray, 'bt-canvas', highlightBTNode);
      await sleep(800);
      await preorderBT(2 * i + 1, res);
      await preorderBT(2 * i + 2, res);
    }
    async function postorderBT(i, res) {
      if (i >= btArray.length) return;
      await postorderBT(2 * i + 1, res);
      await postorderBT(2 * i + 2, res);
      res.push(btArray[i]);
      highlightBTNode = i;
      drawTree(btArray, 'bt-canvas', highlightBTNode);
      await sleep(800);
    }

    // ====================== 5. BINARY SEARCH TREE (BST) ======================
    class TreeNode {
      constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
      }
    }
    let bstRoot = null;
    let highlightBSTNode = null;
    function buildBST() {
      const vals = document.getElementById('bst-input').value.split(',').map(Number).filter(n => !isNaN(n));
      bstRoot = null;
      vals.forEach(v => bstRoot = insertBST(bstRoot, v));
      drawBST();
    }
    function insertBST(node, val) {
      if (!node) return new TreeNode(val);
      if (val < node.val) node.left = insertBST(node.left, val);
      else if (val > node.val) node.right = insertBST(node.right, val);
      return node;
    }
    function drawBST() {
      const canvas = document.getElementById('bst-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!bstRoot) {
        ctx.fillStyle = '#888';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(T('msg_enter_values_bst'), canvas.width / 2, canvas.height / 2);
        return;
      }
      assignBSTPositions(bstRoot, canvas.width / 2, 60, canvas.width / 4);
      drawBSTNode(ctx, bstRoot);
    }
    function assignBSTPositions(node, x, y, offset) {
      if (!node) return;
      node.x = x;
      node.y = y;
      if (node.left) assignBSTPositions(node.left, x - offset, y + 80, offset / 2);
      if (node.right) assignBSTPositions(node.right, x + offset, y + 80, offset / 2);
    }
    function drawBSTNode(ctx, node) {
      if (!node) return;
      const nodeR = 28;
      if (node.left) {
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.left.x, node.left.y);
        ctx.stroke();
        drawBSTNode(ctx, node.left);
      }
      if (node.right) {
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.right.x, node.right.y);
        ctx.stroke();
        drawBSTNode(ctx, node.right);
      }
      ctx.fillStyle = (node === highlightBSTNode) ? '#ff0' : '#667eea';
      ctx.beginPath();
      ctx.arc(node.x, node.y, nodeR, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.val, node.x, node.y);
    }
    async function traverseBST(type) {
      const result = [];
      highlightBSTNode = null;
      drawBST();
      if (!bstRoot) return;
      if (type === 'inorder') await inorderBST(bstRoot, result);
      else if (type === 'preorder') await preorderBST(bstRoot, result);
      else if (type === 'postorder') await postorderBST(bstRoot, result);
      document.getElementById('bst-traversal-output').textContent = `${type.toUpperCase()}: ${result.join(' ‚Üí ')}`;
      highlightBSTNode = null;
      drawBST();
    }
    async function inorderBST(node, res) {
      if (node) {
        await inorderBST(node.left, res);
        res.push(node.val);
        highlightBSTNode = node;
        drawBST();
        await sleep(800);
        highlightBSTNode = null;
        drawBST();
        await inorderBST(node.right, res);
      }
    }
    async function preorderBST(node, res) {
      if (node) {
        res.push(node.val);
        highlightBSTNode = node;
        drawBST();
        await sleep(800);
        highlightBSTNode = null;
        drawBST();
        await preorderBST(node.left, res);
        await preorderBST(node.right, res);
      }
    }
    async function postorderBST(node, res) {
      if (node) {
        await postorderBST(node.left, res);
        await postorderBST(node.right, res);
        res.push(node.val);
        highlightBSTNode = node;
        drawBST();
        await sleep(800);
        highlightBSTNode = null;
        drawBST();
      }
    }

    // ====================== 6. AVL TREE ======================
    class AVLNode {
      constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
        this.height = 1;
        this.x = 0;
        this.y = 0;
      }
    }
    let avlRoot = null;
    function getHeight(node) {
      return node ? node.height : 0;
    }
    function getBalance(node) {
      return node ? getHeight(node.left) - getHeight(node.right) : 0;
    }
    function updateHeight(node) {
      node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));
    }
    function rotateRight(y) {
      const x = y.left;
      const T2 = x.right;
      x.right = y;
      y.left = T2;
      updateHeight(y);
      updateHeight(x);
      drawAVL(x, `Right Rotation on node ${y.val}`);
      return x;
    }
    function rotateLeft(x) {
      const y = x.right;
      const T2 = y.left;
      y.left = x;
      x.right = T2;
      updateHeight(x);
      updateHeight(y);
      drawAVL(y, `Left Rotation on node ${x.val}`);
      return y;
    }
    async function insertAVLValue(node, val) {
      if (!node) return new AVLNode(val);
      if (val < node.val) node.left = await insertAVLValue(node.left, val);
      else if (val > node.val) node.right = await insertAVLValue(node.right, val);
      else return node;
      updateHeight(node);
      const balance = getBalance(node);
      drawAVL(avlRoot, `Checking balance at ${node.val}. BF: ${balance}`);
      await sleep(600);
      if (balance > 1 && val < node.left.val) {
        return rotateRight(node);
      }
      if (balance < -1 && val > node.right.val) {
        return rotateLeft(node);
      }
      if (balance > 1 && val > node.left.val) {
        node.left = rotateLeft(node.left);
        drawAVL(avlRoot, `LR Case: Inner Left Rotation on ${node.left.val}`);
        await sleep(600);
        return rotateRight(node);
      }
      if (balance < -1 && val < node.right.val) {
        node.right = rotateRight(node.right);
        drawAVL(avlRoot, `RL Case: Inner Right Rotation on ${node.right.val}`);
        await sleep(600);
        return rotateLeft(node);
      }
      return node;
    }
    async function insertAVL() {
      const val = Number(document.getElementById('avl-insert-val').value);
      if (isNaN(val)) return;
      document.getElementById('avl-insert-val').value = '';
      avlRoot = await insertAVLValue(avlRoot, val);
      drawAVL(avlRoot, `Inserted ${val}. Final Tree.`);
    }
    async function buildAVL() {
      clearAVL();
      const vals = document.getElementById('avl-input').value.split(',').map(Number).filter(n => !isNaN(n));
      for (const val of vals) {
        avlRoot = await insertAVLValue(avlRoot, val);
        drawAVL(avlRoot, `Inserted ${val}`);
        await sleep(1000);
      }
      drawAVL(avlRoot, `AVL Tree Built.`);
    }
    function clearAVL() {
      avlRoot = null;
      drawAVL(avlRoot, 'Tree cleared.');
    }
    function drawAVL(node, status = '') {
      const canvas = document.getElementById('avl-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      document.getElementById('avl-canvas').style.border = getBalance(node) > 1 || getBalance(node) < -1 ? '4px solid #f66' : 'none';
      if (!node) {
        ctx.fillStyle = '#888';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(status, canvas.width / 2, canvas.height / 2);
        return;
      }
      assignAVLPositions(node, canvas.width / 2, 60, canvas.width / 4);
      drawAVLNode(ctx, node);
      ctx.fillStyle = '#0f0';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`Status: ${status}`, canvas.width / 2, 20);
    }
    function assignAVLPositions(node, x, y, offset) {
      if (!node) return;
      node.x = x;
      node.y = y;
      if (node.left) assignAVLPositions(node.left, x - offset, y + 80, offset / 2);
      if (node.right) assignAVLPositions(node.right, x + offset, y + 80, offset / 2);
    }
    function drawAVLNode(ctx, node) {
      if (!node) return;
      const nodeR = 28;
      if (node.left) {
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.left.x, node.left.y);
        ctx.stroke();
        drawAVLNode(ctx, node.left);
      }
      if (node.right) {
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.right.x, node.right.y);
        ctx.stroke();
        drawAVLNode(ctx, node.right);
      }
      const balance = getBalance(node);
      let color = '#667eea';
      if (balance > 1 || balance < -1) color = '#f66';
      else if (balance !== 0) color = '#ffeb3b';
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(node.x, node.y, nodeR, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.fillStyle = (color === '#ffeb3b' || color === '#f66') ? '#000' : 'white';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.val, node.x, node.y - 10);
      ctx.font = '14px Arial';
      ctx.fillText(`BF:${balance}`, node.x, node.y + 10);
    }

    // ====================== 7. TRIE (PREFIX TREE) ======================
    class TrieNode {
      constructor(char) {
        this.char = char;
        this.children = {};
        this.isEndOfWord = false;
        this.x = 0;
        this.y = 0;
      }
    }
    let trieRoot = new TrieNode(null);
    let highlightTrieNode = null;
    function insertTrie(word) {
      let node = trieRoot;
      for (const char of word) {
        if (!node.children[char]) {
          node.children[char] = new TrieNode(char);
        }
        node = node.children[char];
      }
      node.isEndOfWord = true;
    }
    function buildTrie() {
      const words = document.getElementById('trie-input').value.split(',').map(s => s.trim()).filter(s => s.length > 0);
      trieRoot = new TrieNode(null);
      words.forEach(insertTrie);
      drawTrie(T('msg_trie_built', { count: words.length }));
    }
    function insertTrieWord() {
      const word = document.getElementById('trie-insert-word').value.trim();
      if (word) {
        insertTrie(word);
        drawTrie(T('msg_trie_inserted', { word }));
      }
    }
    function clearTrie() {
      trieRoot = new TrieNode(null);
      drawTrie(T('msg_trie_empty'));
    }
    async function searchTrieWord() {
      const word = document.getElementById('trie-search-word').value.trim();
      if (!word) return;
      let node = trieRoot;
      highlightTrieNode = trieRoot;
      drawTrie(T('msg_trie_searching', { word }));
      await sleep(800);
      for (const char of word) {
        if (!node.children[char]) {
          drawTrie(T('msg_prefix_not_found', { word }));
          highlightTrieNode = null;
          return;
        }
        node = node.children[char];
        highlightTrieNode = node;
        drawTrie(`Current prefix: ${char}`);
        await sleep(800);
      }
      if (node.isEndOfWord) {
        document.getElementById('trie-status').innerHTML = `<span style="color:#0f0">${T('msg_word_found', { word })}</span>`;
      } else {
        document.getElementById('trie-status').innerHTML = `<span style="color:#ffeb3b">${T('msg_prefix_found', { word })}</span>`;
      }
      highlightTrieNode = null;
    }
    function drawTrie(status) {
      const canvas = document.getElementById('trie-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      document.getElementById('trie-status').textContent = status;
      if (Object.keys(trieRoot.children).length === 0) {
        ctx.fillStyle = '#888';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(T('msg_trie_empty'), canvas.width / 2, canvas.height / 2);
        return;
      }
      const nodeR = 25;
      const vGap = 80;
      const queue = [{ node: trieRoot, level: 0 }];
      trieRoot.x = canvas.width / 2;
      trieRoot.y = 50;
      let levelPositions = {};
      levelPositions[0] = [trieRoot];
      while (queue.length > 0) {
        const { node, level } = queue.shift();
        const children = Object.values(node.children);
        if (children.length === 0) continue;
        if (!levelPositions[level + 1]) levelPositions[level + 1] = [];
        children.forEach((childNode) => {
          levelPositions[level + 1].push(childNode);
          queue.push({ node: childNode, level: level + 1 });
        });
      }
      Object.keys(levelPositions).forEach(level => {
        const nodes = levelPositions[level];
        const numNodes = nodes.length;
        const totalWidth = canvas.width;
        const spacing = totalWidth / (numNodes + 1);
        nodes.forEach((node, index) => {
          node.x = spacing * (index + 1);
          node.y = 50 + level * vGap;
        });
      });
      function drawTrieConnections(node) {
        Object.values(node.children).forEach(child => {
          ctx.strokeStyle = '#00d4ff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(child.x, child.y);
          ctx.stroke();
          const mx = (node.x + child.x) / 2;
          const my = (node.y + child.y) / 2;
          ctx.fillStyle = '#ffeb3b';
          ctx.font = '16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(child.char, mx, my - 5);
          drawTrieConnections(child);
        });
      }
      drawTrieConnections(trieRoot);
      function drawTrieNodes(node) {
        if (node.char !== null) {
          let color = node === highlightTrieNode ? '#ff0' : (node.isEndOfWord ? '#0f0' : '#667eea');
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(node.x, node.y, nodeR, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#0ff';
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.fillStyle = (color === '#ffeb3b' || color === '#ff0') ? '#000' : 'white';
          ctx.font = '16px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(node.char, node.x, node.y);
        }
        Object.values(node.children).forEach(drawTrieNodes);
      }
      drawTrieNodes(trieRoot);
    }

    // ====================== 8. HEAPS ======================
    let heap = [];
    let heapType = 'min';
    let isSorting = false;
    function resetHeap() {
      heap = [];
      isSorting = false;
      drawHeap();
      document.getElementById('heap-info').textContent = 'Heap cleared';
    }
    function runHeapSort() {
      if (heap.length === 0) {
        alert('Load data first');
        return;
      }
      isSorting = true;
      document.getElementById('heap-info').textContent = 'Running Heap Sort...';
      heapSortVisualization([...heap]);
    }
    async function heapSortVisualization(arr) {
      buildMaxHeap(arr);
      drawHeapSort(arr, arr.length, 'Building max-heap...');
      await sleep(800);
      for (let i = arr.length - 1; i > 0; i--) {
        [arr[0], arr[i]] = [arr[i], arr[0]];
        drawHeapSort(arr, i, `Moved max to position ${i}`);
        await sleep(800);
        heapifyMax(arr, i, 0);
        drawHeapSort(arr, i, `Heapified root (size: ${i})`);
        await sleep(800);
      }
      heap = arr;
      isSorting = false;
      document.getElementById('heap-info').textContent = 'Heap Sort completed!';
    }
    function buildMaxHeap(arr) {
      const n = arr.length;
      for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapifyMax(arr, n, i);
      }
    }
    function heapifyMax(arr, heapSize, i) {
      let largest = i;
      const left = 2 * i + 1;
      const right = 2 * i + 2;
      if (left < heapSize && arr[left] > arr[largest]) {
        largest = left;
      }
      if (right < heapSize && arr[right] > arr[largest]) {
        largest = right;
      }
      if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        heapifyMax(arr, heapSize, largest);
      }
    }
    function updateHeapType(type) {
      heapType = type;
      if (heap.length > 0 && !isSorting) {
        if (type === 'sort') {
          document.getElementById('heap-info').textContent = 'Select "Run Heap Sort" to start';
        } else {
          const original = [...heap];
          if (type === 'min') {
            heap = [...original];
            buildHeap(heap);
          } else if (type === 'max') {
            heap = [...original];
            buildHeap(heap);
          }
          drawHeap();
        }
      }
    }
    function getCompare() {
      return heapType === 'min' ? (a, b) => a < b : (a, b) => a > b;
    }
    function heapInsert() {
      const val = Number(document.getElementById('heap-val').value);
      if (isNaN(val)) return;
      heap.push(val);
      heapifyUp(heap.length - 1);
      drawHeap();
    }
    function heapExtract() {
      if (heap.length === 0) return;
      heap[0] = heap[heap.length - 1];
      heap.pop();
      if (heap.length > 0) heapifyDown(0);
      drawHeap();
    }
    function heapifyUp(i) {
      const compare = getCompare();
      while (i > 0) {
        const parent = Math.floor((i - 1) / 2);
        if (!compare(heap[i], heap[parent])) break;
        [heap[i], heap[parent]] = [heap[parent], heap[i]];
        i = parent;
      }
    }
    function heapifyDown(i) {
      const compare = getCompare();
      while (true) {
        let smallest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        if (left < heap.length && compare(heap[left], heap[smallest])) smallest = left;
        if (right < heap.length && compare(heap[right], heap[smallest])) smallest = right;
        if (smallest === i) break;
        [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
        i = smallest;
      }
    }
    function buildHeap(arr) {
      heap = arr;
      for (let i = Math.floor(heap.length / 2) - 1; i >= 0; i--) {
        heapifyDown(i);
      }
    }
    function loadHeap() {
      const vals = document.getElementById('heap-input').value.split(',').map(n => Number(n.trim())).filter(n => !isNaN(n));
      if (vals.length === 0) return;
      heap = [...vals];
      isSorting = false;
      if (heapType === 'min') {
        buildHeap(heap);
      } else if (heapType === 'max') {
        buildHeap(heap);
      }
      drawHeap();
      document.getElementById('heap-info').textContent = `Loaded ${heap.length} elements`;
    }
    function randomHeap() {
      const size = Number(document.getElementById('heap-size').value);
      const arr = [];
      for (let i = 0; i < size; i++) {
        arr.push(Math.floor(Math.random() * 100) + 1);
      }
      heap = [...arr];
      isSorting = false;
      if (heapType === 'min') {
        buildHeap(heap);
      } else if (heapType === 'max') {
        buildHeap(heap);
      }
      drawHeap();
      document.getElementById('heap-info').textContent = `Generated ${size} random elements`;
    }
    function drawHeap() {
      if (isSorting) return;
      const canvas = document.getElementById('heap-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (heap.length === 0) {
        ctx.fillStyle = '#888';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(T('msg_heap_empty'), canvas.width / 2, canvas.height / 2);
        return;
      }
      const levels = Math.floor(Math.log2(heap.length)) + 1;
      const startY = 60;
      const levelGap = 90;
      const nodeRadius = 28;
      for (let i = 0; i < heap.length; i++) {
        const level = Math.floor(Math.log2(i + 1));
        const posInLevel = i - (Math.pow(2, level) - 1);
        const nodesInLevel = Math.pow(2, level);
        const spacing = canvas.width / (nodesInLevel + 1);
        const x = spacing * (posInLevel + 1);
        const y = startY + level * levelGap;
        if (i > 0) {
          const parent = Math.floor((i - 1) / 2);
          const pLevel = Math.floor(Math.log2(parent + 1));
          const pPos = parent - (Math.pow(2, pLevel) - 1);
          const pNodes = Math.pow(2, pLevel);
          const pSpacing = canvas.width / (pNodes + 1);
          const px = pSpacing * (pPos + 1);
          const py = startY + pLevel * levelGap;
          ctx.strokeStyle = '#00d4ff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(px, py + nodeRadius);
          ctx.lineTo(x, y - nodeRadius);
          ctx.stroke();
        }
        let color = '#764ba2';
        if (heapType === 'min') {
          color = (i === 0) ? '#0f0' : '#764ba2';
        } else if (heapType === 'max') {
          color = (i === 0) ? '#ff5252' : '#764ba2';
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(heap[i], x, y);
      }
    }
    function drawHeapSort(arr, heapSize, status) {
      const canvas = document.getElementById('heap-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const levels = Math.floor(Math.log2(arr.length)) + 1;
      const startY = 60;
      const levelGap = 90;
      const nodeRadius = 28;
      for (let i = 0; i < arr.length; i++) {
        const level = Math.floor(Math.log2(i + 1));
        const posInLevel = i - (Math.pow(2, level) - 1);
        const nodesInLevel = Math.pow(2, level);
        const spacing = canvas.width / (nodesInLevel + 1);
        const x = spacing * (posInLevel + 1);
        const y = startY + level * levelGap;
        if (i > 0 && i < heapSize) {
          const parent = Math.floor((i - 1) / 2);
          if (parent < heapSize) {
            const pLevel = Math.floor(Math.log2(parent + 1));
            const pPos = parent - (Math.pow(2, pLevel) - 1);
            const pNodes = Math.pow(2, pLevel);
            const pSpacing = canvas.width / (pNodes + 1);
            const px = pSpacing * (pPos + 1);
            const py = startY + pLevel * levelGap;
            ctx.strokeStyle = i < heapSize ? '#00d4ff' : '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(px, py + nodeRadius);
            ctx.lineTo(x, y - nodeRadius);
            ctx.stroke();
          }
        }
        ctx.fillStyle = i >= heapSize ? '#555' : (i === 0 ? '#ff5252' : '#764ba2');
        ctx.beginPath();
        ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(arr[i], x, y);
      }
      document.getElementById('heap-info').textContent = status;
    }

    // ====================== 9. GRAPH BFS/DFS ======================
    const graphNodes = [
      { id: 0, x: 200, y: 150 }, { id: 1, x: 400, y: 100 }, { id: 2, x: 600, y: 150 },
      { id: 3, x: 300, y: 300 }, { id: 4, x: 500, y: 300 }, { id: 5, x: 700, y: 350 }
    ];
    const graphEdges = [[0, 1], [0, 3], [1, 2], [1, 4], [2, 5], [3, 4], [4, 5]];
    async function runBFS() {
      const canvas = document.getElementById('graph-canvas');
      const ctx = canvas.getContext('2d');
      const visited = new Set();
      const queue = [0];
      visited.add(0);
      while (queue.length > 0) {
        const node = queue.shift();
        drawGraph(ctx, visited, node);
        await sleep(800);
        for (let [a, b] of graphEdges) {
          const neighbor = a === node ? b : (b === node ? a : -1);
          if (neighbor !== -1 && !visited.has(neighbor)) {
            visited.add(neighbor);
            queue.push(neighbor);
          }
        }
      }
      drawGraph(ctx, visited, -1);
    }
    async function runDFS() {
      const canvas = document.getElementById('graph-canvas');
      const ctx = canvas.getContext('2d');
      const visited = new Set();
      await dfsVisit(0, visited, ctx);
      drawGraph(ctx, visited, -1);
    }
    async function dfsVisit(node, visited, ctx) {
      visited.add(node);
      drawGraph(ctx, visited, node);
      await sleep(800);
      for (let [a, b] of graphEdges) {
        const neighbor = a === node ? b : (b === node ? a : -1);
        if (neighbor !== -1 && !visited.has(neighbor)) {
          await dfsVisit(neighbor, visited, ctx);
        }
      }
    }
    function drawGraph(ctx, visited, current) {
      ctx.clearRect(0, 0, 1100, 500);
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 3;
      graphEdges.forEach(([a, b]) => {
        ctx.beginPath();
        ctx.moveTo(graphNodes[a].x, graphNodes[a].y);
        ctx.lineTo(graphNodes[b].x, graphNodes[b].y);
        ctx.stroke();
      });
      graphNodes.forEach(n => {
        ctx.fillStyle = current === n.id ? '#ff0' : (visited.has(n.id) ? '#0f0' : '#667eea');
        ctx.beginPath();
        ctx.arc(n.x, n.y, 30, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '22px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(n.id, n.x, n.y);
      });
    }

    // ====================== 10. BELLMAN-FORD ======================
    async function runBellmanFord() {
      const canvas = document.getElementById('bellman-canvas');
      const ctx = canvas.getContext('2d');
      const nodes = [{ id: 0, x: 150, y: 250 }, { id: 1, x: 400, y: 150 }, { id: 2, x: 650, y: 250 }, { id: 3, x: 400, y: 350 }];
      const edges = [{ from: 0, to: 1, weight: 4 }, { from: 0, to: 3, weight: 5 }, { from: 1, to: 2, weight: 3 }, { from: 3, to: 1, weight: -6 }, { from: 3, to: 2, weight: 2 }];
      const dist = Array(nodes.length).fill(Infinity);
      dist[0] = 0;
      for (let i = 0; i < nodes.length - 1; i++) {
        for (let e of edges) {
          if (dist[e.from] !== Infinity && dist[e.from] + e.weight < dist[e.to]) {
            dist[e.to] = dist[e.from] + e.weight;
          }
        }
        drawBellman(ctx, nodes, edges, dist);
        await sleep(800);
      }
      document.getElementById('bellman-output').textContent = `Shortest distances from node 0: ${dist.map((d, i) => `${i}:${d}`).join(', ')}`;
    }
    function drawBellman(ctx, nodes, edges, dist) {
      ctx.clearRect(0, 0, 1100, 500);
      edges.forEach(e => {
        const from = nodes[e.from];
        const to = nodes[e.to];
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        const mx = (from.x + to.x) / 2;
        const my = (from.y + to.y) / 2;
        ctx.fillStyle = '#ff0';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(e.weight, mx, my - 10);
      });
      nodes.forEach((n, i) => {
        ctx.fillStyle = i === 0 ? '#0f0' : '#667eea';
        ctx.beginPath();
        ctx.arc(n.x, n.y, 35, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(n.id, n.x, n.y - 8);
        ctx.font = '16px Arial';
        ctx.fillText(dist[i] === Infinity ? '‚àû' : dist[i], n.x, n.y + 12);
      });
    }

    // ====================== 11. DIJKSTRA ======================
    let dijkstraNodes = [];
    let dijkstraEdges = [];
    function loadDijkstraGraph() {
      const edgesInput = document.getElementById('graph-edges').value;
      const edgeList = edgesInput.split(',').map(s => s.trim());
      let maxNode = 0;
      dijkstraEdges = [];
      edgeList.forEach(e => {
        if (!e) return;
        const [fromTo, w] = e.split(':');
        const [from, to] = fromTo.split('-').map(Number);
        const weight = w ? Number(w) : 1;
        dijkstraEdges.push({ from, to, weight });
        maxNode = Math.max(maxNode, from, to);
      });
      const numNodes = maxNode + 1;
      const isUndirected = document.getElementById('graph-dir').value === 'undirected';
      if (isUndirected) {
        for (let i = 0; i < dijkstraEdges.length; i++) {
          const e = dijkstraEdges[i];
          if (!dijkstraEdges.some(ee => ee.from === e.to && ee.to === e.from && ee.weight === e.weight)) {
            dijkstraEdges.push({ from: e.to, to: e.from, weight: e.weight });
          }
        }
      }
      dijkstraNodes = [];
      for (let i = 0; i < numNodes; i++) {
        const angle = 2 * Math.PI * i / numNodes;
        const x = 550 + 300 * Math.cos(angle);
        const y = 250 + 200 * Math.sin(angle);
        dijkstraNodes.push({ id: i, x, y });
      }
    }
    async function runDijkstra() {
      if (dijkstraNodes.length === 0) loadDijkstraGraph();
      const canvas = document.getElementById('dijkstra-canvas');
      const ctx = canvas.getContext('2d');
      const start = Number(document.getElementById('dijkstra-start').value);
      const end = Number(document.getElementById('dijkstra-end').value);
      const numNodes = dijkstraNodes.length;
      const dist = Array(numNodes).fill(Infinity);
      const prev = Array(numNodes).fill(-1);
      const visited = new Set();
      dist[start] = 0;
      while (visited.size < numNodes) {
        let u = -1;
        for (let i = 0; i < numNodes; i++) {
          if (!visited.has(i) && (u === -1 || dist[i] < dist[u])) u = i;
        }
        if (dist[u] === Infinity) break;
        visited.add(u);
        for (let e of dijkstraEdges) {
          if (e.from === u && dist[u] + e.weight < dist[e.to]) {
            dist[e.to] = dist[u] + e.weight;
            prev[e.to] = u;
          }
        }
        drawDijkstra(ctx, dijkstraNodes, dijkstraEdges, dist, visited, []);
        await sleep(1000);
      }
      let output = `Shortest distances from node ${start}: ${dist.map((d, i) => `${i}:${d === Infinity ? '‚àû' : d}`).join(', ')}`;
      if (!isNaN(end) && end >= 0 && end < numNodes) {
        if (dist[end] === Infinity) {
          output += ' | No path to end';
        } else {
          let path = [];
          let curr = end;
          while (curr !== -1) {
            path.push(curr);
            curr = prev[curr];
          }
          path.reverse();
          output += ` | Path to ${end}: ${path.join(' -> ')} | Distance: ${dist[end]}`;
          drawDijkstra(ctx, dijkstraNodes, dijkstraEdges, dist, visited, path);
        }
      }
      document.getElementById('dijkstra-output').textContent = output;
    }
    function drawDijkstra(ctx, nodes, edges, dist, visited, path) {
      ctx.clearRect(0, 0, 1100, 500);
      edges.forEach(e => {
        const from = nodes[e.from];
        const to = nodes[e.to];
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        const mx = (from.x + to.x) / 2;
        const my = (from.y + to.y) / 2;
        ctx.fillStyle = '#ff0';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(e.weight, mx, my - 10);
      });
      nodes.forEach((n, i) => {
        ctx.fillStyle = path.includes(i) ? '#ff0' : (visited.has(i) ? '#0f0' : '#667eea');
        ctx.beginPath();
        ctx.arc(n.x, n.y, 35, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(n.id, n.x, n.y - 8);
        ctx.font = '16px Arial';
        ctx.fillText(dist[i] === Infinity ? '‚àû' : dist[i], n.x, n.y + 12);
      });
    }

    // ====================== 12. A* PATHFINDING ======================
    const gridSize = 30;
    const gridRows = 18;
    const gridCols = 30;
    let grid = [];
    let startCell = { r: 1, c: 1 };
    let endCell = { r: 16, c: 28 };
    function initGrid() {
      grid = [];
      for (let r = 0; r < gridRows; r++) {
        grid[r] = [];
        for (let c = 0; c < gridCols; c++) {
          grid[r][c] = { wall: false, visited: false, path: false };
        }
      }
    }
    initGrid();
    document.getElementById('astar-canvas').addEventListener('click', (e) => {
      const rect = e.target.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const c = Math.floor(x / gridSize);
      const r = Math.floor(y / gridSize);
      if (r >= 0 && r < gridRows && c >= 0 && c < gridCols) {
        if ((r === startCell.r && c === startCell.c) || (r === endCell.r && c === endCell.c)) return;
        grid[r][c].wall = !grid[r][c].wall;
        drawAstarGrid();
      }
    });
    function clearGrid() {
      initGrid();
      drawAstarGrid();
    }
    function drawAstarGrid() {
      const canvas = document.getElementById('astar-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          const cell = grid[r][c];
          if (r === startCell.r && c === startCell.c) ctx.fillStyle = '#0f0';
          else if (r === endCell.r && c === endCell.c) ctx.fillStyle = '#f00';
          else if (cell.path) ctx.fillStyle = '#ffeb3b';
          else if (cell.visited) ctx.fillStyle = '#00bcd4';
          else if (cell.wall) ctx.fillStyle = '#333';
          else ctx.fillStyle = '#1a1a2e';
          ctx.fillRect(c * gridSize, r * gridSize, gridSize - 1, gridSize - 1);
        }
      }
    }
    function heuristic(r, c) {
      return Math.abs(r - endCell.r) + Math.abs(c - endCell.c);
    }
    async function runAstar() {
      const walls = [];
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          if (grid[r][c].wall) walls.push({ r, c });
          grid[r][c].visited = false;
          grid[r][c].path = false;
        }
      }
      initGrid();
      walls.forEach(w => grid[w.r][w.c].wall = true);
      const speed = 101 - document.getElementById('astar-speed').value;
      let openSet = [{ r: startCell.r, c: startCell.c }];
      let cameFrom = {};
      let gScore = {};
      let fScore = {};
      gScore[`${startCell.r},${startCell.c}`] = 0;
      fScore[`${startCell.r},${startCell.c}`] = heuristic(startCell.r, startCell.c);
      const getScore = (map, r, c) => map[`${r},${c}`] === undefined ? Infinity : map[`${r},${c}`];
      while (openSet.length > 0) {
        openSet.sort((a, b) => getScore(fScore, a.r, a.c) - getScore(fScore, b.r, b.c));
        let current = openSet.shift();
        const currentKey = `${current.r},${current.c}`;
        if (current.r === endCell.r && current.c === endCell.c) {
          let pathNode = current;
          while (pathNode.r !== startCell.r || pathNode.c !== startCell.c) {
            grid[pathNode.r][pathNode.c].path = true;
            pathNode = cameFrom[`${pathNode.r},${pathNode.c}`];
          }
          grid[startCell.r][startCell.c].path = true;
          drawAstarGrid();
          return;
        }
        grid[current.r][current.c].visited = true;
        drawAstarGrid();
        await sleep(speed);
        const neighbors = [{ r: current.r - 1, c: current.c }, { r: current.r + 1, c: current.c }, { r: current.r, c: current.c - 1 }, { r: current.r, c: current.c + 1 }];
        for (let n of neighbors) {
          if (n.r < 0 || n.r >= gridRows || n.c < 0 || n.c >= gridCols) continue;
          if (grid[n.r][n.c].wall) continue;
          const neighborKey = `${n.r},${n.c}`;
          const tentative_gScore = getScore(gScore, current.r, current.c) + 1;
          if (tentative_gScore < getScore(gScore, n.r, n.c)) {
            cameFrom[neighborKey] = current;
            gScore[neighborKey] = tentative_gScore;
            fScore[neighborKey] = tentative_gScore + heuristic(n.r, n.c);
            const inOpenSet = openSet.some(o => o.r === n.r && o.c === n.c);
            if (!inOpenSet) {
              openSet.push(n);
            }
          }
        }
      }
      drawAstarGrid();
    }

    // ====================== 13. TOWERS OF HANOI ======================
    let hanoiState = { pegs: [[], [], []], moves: 0 };
    async function solveHanoi() {
      const n = Number(document.getElementById('hanoi-disks').value);
      hanoiState = { pegs: [[], [], []], moves: 0 };
      for (let i = n; i >= 1; i--) hanoiState.pegs[0].push(i);
      drawHanoi();
      await sleep(500);
      await hanoi(n, 0, 2, 1);
    }
    async function hanoi(n, from, to, aux) {
      if (n === 1) {
        const disk = hanoiState.pegs[from].pop();
        hanoiState.pegs[to].push(disk);
        hanoiState.moves++;
        drawHanoi();
        await sleep(600);
        return;
      }
      await hanoi(n - 1, from, aux, to);
      const disk = hanoiState.pegs[from].pop();
      hanoiState.pegs[to].push(disk);
      hanoiState.moves++;
      drawHanoi();
      await sleep(600);
      await hanoi(n - 1, aux, to, from);
    }
    function drawHanoi() {
      const canvas = document.getElementById('hanoi-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const pegX = [200, 550, 900];
      const baseY = 380;
      ctx.strokeStyle = '#00d4ff';
      ctx.lineWidth = 8;
      pegX.forEach(x => {
        ctx.beginPath();
        ctx.moveTo(x, baseY);
        ctx.lineTo(x, baseY - 250);
        ctx.stroke();
        ctx.fillStyle = '#444';
        ctx.fillRect(x - 80, baseY, 160, 15);
      });
      hanoiState.pegs.forEach((peg, i) => {
        peg.forEach((disk, j) => {
          const w = disk * 20 + 40;
          const h = 25;
          const x = pegX[i] - w / 2;
          const y = baseY - (j + 1) * h - 5;
          ctx.fillStyle = `hsl(${disk * 30}, 80%, 60%)`;
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
        });
      });
      ctx.fillStyle = '#0f0';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`Moves: ${hanoiState.moves}`, canvas.width / 2, 50);
    }

    // ====================== 14. LINKED LIST SANDBOX MODE ======================
    (() => {
      const container = document.getElementById('linkedlist');
      if (!container) return;

      // ---------- DOM ----------
      const elMode = container.querySelector('#mode');
      const elExecMode = container.querySelector('#execMode');
      const listView = container.querySelector('#listView');
      const stats = container.querySelector('#stats');
      const headTail = container.querySelector('#headTail');
      const stepPill = container.querySelector('#stepPill');

      const buildInput = container.querySelector('#buildInput');
      const valueInput = container.querySelector('#valueInput');
      const indexInput = container.querySelector('#indexInput');

      const buildBtn = container.querySelector('#buildBtn');
      const clearBtn = container.querySelector('#clearBtn');
      const validateBtn = container.querySelector('#validateBtn');

      const insHeadBtn = container.querySelector('#insHead');
      const insTailBtn = container.querySelector('#insTail');
      const insIndexBtn = container.querySelector('#insIndex');

      const delValBtn = container.querySelector('#delVal');
      const delIndexBtn = container.querySelector('#delIndex');

      const searchBtn = container.querySelector('#searchVal');
      const stopBtn = container.querySelector('#stopAnim');

      const speed = container.querySelector('#speed');
      const speedLabel = container.querySelector('#speedLabel');

      const nextStepBtn = container.querySelector('#nextStep');
      const resetStepsBtn = container.querySelector('#resetSteps');

      const statusLine = container.querySelector('#statusLine');
      const logBox = container.querySelector('#logBox');
      const integrityBox = container.querySelector('#integrityBox');
      const integrityPill = container.querySelector('#integrityPill');

      // ---------- State ----------
      let idSeq = 1;
      let nodes = new Map();
      let order = [];
      let headId = null;
      let tailId = null;

      let activeId = null;
      let checkedIds = new Set();
      let foundId = null;

      let animating = false;
      let cancelToken = { cancelled: false };

      let steps = [];
      let stepIndex = 0;
      let stepSnapshot = null;

      // ---------- Helpers ----------
      const nowTime = () => new Date().toLocaleTimeString();
      const mode = () => elMode.value;
      const execMode = () => elExecMode.value;
      const size = () => order.length;
      const headNode = () => headId ? nodes.get(headId) : null;
      const tailNode = () => tailId ? nodes.get(tailId) : null;

      function setStatus(text){ statusLine.textContent = text; }
      function log(msg){
        const line = document.createElement('div');
        line.textContent = `[${nowTime()}] ${msg}`;
        logBox.appendChild(line);
        logBox.scrollTop = logBox.scrollHeight;
      }
      function logIntegrity(msg){
        const line = document.createElement('div');
        line.textContent = `[${nowTime()}] ${msg}`;
        integrityBox.appendChild(line);
        integrityBox.scrollTop = integrityBox.scrollHeight;
      }
      function escapeHtml(s){
        return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
      }
      function parseValueInput(){
        const raw = valueInput.value.trim();
        if(raw === ''){ log('‚ö† Please enter a value.'); setStatus('‚ö† Please enter a value.'); return null; }
        const num = Number(raw);
        const isNum = Number.isFinite(num) && /^[-+]?\d+(\.\d+)?$/.test(raw);
        return isNum ? num : raw;
      }
      function parseIndexInput(){
        const raw = indexInput.value.trim();
        if(raw === ''){ log('‚ö† Please enter an index.'); setStatus('‚ö† Please enter an index.'); return null; }
        const idx = Number(raw);
        if(!Number.isInteger(idx) || idx < 0){ log('‚ö† Index must be a non-negative integer.'); setStatus('‚ö† Index must be a non-negative integer.'); return null; }
        return idx;
      }
      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }
      function setControlsEnabled(enabled){
        const controls = [elMode, elExecMode, buildInput, valueInput, indexInput, buildBtn, clearBtn, validateBtn, insHeadBtn, insTailBtn, insIndexBtn, delValBtn, delIndexBtn, searchBtn, nextStepBtn, resetStepsBtn, speed];
        controls.forEach(el => el.disabled = !enabled);
        stopBtn.disabled = enabled;
      }
      function updateSpeedLabel(){ speedLabel.textContent = `${speed.value}ms`; }
      function updateStepControls(){
        stepPill.textContent = `Steps: ${steps.length ? (stepIndex + '/' + steps.length) : '0'}`;
        const hasSteps = steps.length > 0;
        nextStepBtn.disabled = !(execMode() === 'step' && hasSteps && stepIndex < steps.length);
        resetStepsBtn.disabled = !(execMode() === 'step' && hasSteps);
      }
      function clearHighlights(){ activeId = null; foundId = null; checkedIds.clear(); }

      // ---------- Core Linked List Maintenance ----------
      function rebuildPointers(){
        for(const id of order){
          const n = nodes.get(id);
          n.nextId = null;
          n.prevId = null;
        }
        headId = order[0] ?? null;
        tailId = order[order.length - 1] ?? null;
        if(order.length === 0) return;
        if(mode() === 'singly'){
          for(let i=0;i<order.length;i++){
            const id = order[i];
            const n = nodes.get(id);
            n.nextId = (i < order.length - 1) ? order[i+1] : null;
            n.prevId = null;
          }
        } else if(mode() === 'doubly'){
          for(let i=0;i<order.length;i++){
            const id = order[i];
            const n = nodes.get(id);
            n.nextId = (i < order.length - 1) ? order[i+1] : null;
            n.prevId = (i > 0) ? order[i-1] : null;
          }
        } else if(mode() === 'circular'){
          for(let i=0;i<order.length;i++){
            const id = order[i];
            const n = nodes.get(id);
            n.nextId = (i < order.length - 1) ? order[i+1] : (order.length > 1 ? order[0] : null);
            n.prevId = null;
          }
        }
      }

      function validateIntegrity(silent=false){
        integrityBox.innerHTML = '';
        let ok = true;
        const report = (msg) => { if(!silent) logIntegrity(msg); };
        if(order.length === 0){
          if(headId !== null || tailId !== null){ ok = false; report('‚ùå Empty order but head/tail are not null.'); }
          else { report('‚úÖ Empty list integrity OK.'); }
          setIntegrityPill(ok); return ok;
        }
        if(headId !== order[0]){ ok = false; report(`‚ùå headId mismatch. headId=${headId} expected=${order[0]}`); }
        else { report(`‚úÖ headId OK (id:${headId})`); }
        if(tailId !== order[order.length-1]){ ok = false; report(`‚ùå tailId mismatch. tailId=${tailId} expected=${order[order.length-1]}`); }
        else { report(`‚úÖ tailId OK (id:${tailId})`); }
        for(const id of order){ if(!nodes.has(id)){ ok = false; report(`‚ùå order contains missing node id:${id}`); } }
        const visited = new Set();
        let cur = headId;
        let stepsCount = 0;
        const maxSteps = order.length + 2;
        while(cur !== null && stepsCount < maxSteps){
          if(visited.has(cur)){
            if(mode() === 'circular' && cur === headId && visited.size === order.length){ report('‚úÖ Circular loop detected correctly (tail.next=head).'); }
            else { ok = false; report(`‚ùå Unexpected cycle at id:${cur}`); }
            break;
          }
          visited.add(cur);
          const node = nodes.get(cur);
          if(!node){ ok = false; report(`‚ùå Traversal hit missing node id:${cur}`); break; }
          if(mode() === 'doubly'){
            const idx = order.indexOf(cur);
            const expectedPrev = idx > 0 ? order[idx-1] : null;
            if(node.prevId !== expectedPrev){ ok = false; report(`‚ùå prevId mismatch at id:${cur}. prevId=${node.prevId} expected=${expectedPrev}`); }
          }
          cur = node.nextId;
          stepsCount++;
          if(mode() !== 'circular' && cur === null) break;
          if(mode() === 'circular' && cur === headId && visited.size === order.length) break;
        }
        if(visited.size !== order.length){ ok = false; report(`‚ùå Traversal visited ${visited.size}/${order.length} nodes.`); }
        else { report(`‚úÖ Traversal visited all nodes (${visited.size}).`); }
        setIntegrityPill(ok);
        return ok;
      }
      function setIntegrityPill(ok){
        integrityPill.textContent = ok ? 'OK' : 'ERROR';
        integrityPill.style.borderColor = ok ? 'rgba(42,122,74,.85)' : 'rgba(122,42,42,.9)';
      }

      // ---------- Rendering ----------
      function makeArrowBetween(){
        const a = document.createElement('div');
        a.className = 'arrow';
        if(mode() === 'doubly'){ a.innerHTML = `<div>‚Üí</div><div class="back">‚Üê</div>`; }
        else { a.innerHTML = `<div>‚Üí</div>`; }
        return a;
      }
      function render(){
        listView.innerHTML = '';
        stats.textContent = `Size: ${size()}`;
        const h = headNode();
        const t = tailNode();
        headTail.textContent = `Head: ${h ? h.value : '-'} | Tail: ${t ? t.value : '-'}`;
        if(size() === 0){
          const empty = document.createElement('div');
          empty.className = 'pill';
          empty.textContent = 'List is empty. Build or insert nodes.';
          listView.appendChild(empty);
          updateStepControls();
          return;
        }
        for(let i=0;i<order.length;i++){
          const id = order[i];
          const n = nodes.get(id);
          const nodeEl = document.createElement('div');
          let cls = 'node';
          if(id === activeId) cls += ' active';
          if(checkedIds.has(id)) cls += ' checked';
          if(id === foundId) cls += ' found';
          nodeEl.className = cls;
          const topBadges = [];
          if(id === headId) topBadges.push(`<span class="badge head">HEAD</span>`);
          if(id === tailId) topBadges.push(`<span class="badge tail">TAIL</span>`);
          const nextLabel = n.nextId === null ? 'null' : `id:${n.nextId}`;
          const prevLabel = n.prevId === null ? 'null' : `id:${n.prevId}`;
          let ptrText = '';
          if(mode() === 'doubly'){
            ptrText = `<div class="ptr mono">prev ‚Üê ${escapeHtml(prevLabel)}<br>next ‚Üí ${escapeHtml(nextLabel)}</div>`;
          } else {
            ptrText = `<div class="ptr mono">next ‚Üí ${escapeHtml(nextLabel)}</div>`;
          }
          nodeEl.innerHTML = `
            <div class="top">${topBadges.join(' ')}</div>
            <div class="val">${escapeHtml(n.value)}</div>
            <div class="id mono">id:${n.id}</div>
            ${ptrText}
          `;
          listView.appendChild(nodeEl);
          const isLast = (i === order.length - 1);
          if(!isLast){ listView.appendChild(makeArrowBetween()); }
          else {
            if(mode() === 'circular' && order.length > 1){
              const loop = document.createElement('div');
              loop.className = 'loop';
              loop.innerHTML = `<div style="font-size:20px;">‚Ü∫</div><div class="t mono">tail.next ‚Üí head</div>`;
              listView.appendChild(loop);
            }
          }
        }
        updateStepControls();
      }

      // ---------- Snapshot / Restore ----------
      function snapshotState(){
        const nodesArr = [];
        for(const [id, n] of nodes.entries()){ nodesArr.push({ id, value: n.value, nextId: n.nextId, prevId: n.prevId }); }
        return { idSeq, order: [...order], headId, tailId, mode: mode(), nodesArr };
      }
      function restoreState(snap){
        if(!snap) return;
        idSeq = snap.idSeq;
        order = [...snap.order];
        headId = snap.headId;
        tailId = snap.tailId;
        nodes = new Map();
        for(const n of snap.nodesArr){ nodes.set(n.id, { id:n.id, value:n.value, nextId:n.nextId, prevId:n.prevId }); }
        rebuildPointers();
        clearHighlights();
        setStatus('Steps reset to snapshot.');
        render();
        validateIntegrity(true);
      }

      // ---------- Core Operations ----------
      function createNode(value){
        const node = { id: idSeq++, value, nextId: null, prevId: null };
        nodes.set(node.id, node);
        return node.id;
      }
      function insertAtInstant(idx, value){
        if(idx < 0) idx = 0;
        if(idx > order.length) idx = order.length;
        const id = createNode(value);
        order.splice(idx, 0, id);
        rebuildPointers();
        clearHighlights();
        activeId = id;
        log(`Inserted value=${value} at index=${idx} (id:${id})`);
        setStatus(`Inserted value=${value} at index=${idx}.`);
        render();
        validateIntegrity(true);
      }
      function insertHeadInstant(value){ insertAtInstant(0, value); }
      function insertTailInstant(value){ insertAtInstant(order.length, value); }
      function deleteAtInstant(idx){
        if(order.length === 0){ log('‚ùå Delete failed: list is empty.'); setStatus('‚ùå Delete failed: list is empty.'); return; }
        if(idx < 0 || idx >= order.length){ log(`‚ùå Delete failed: index ${idx} out of range.`); setStatus(`‚ùå Delete failed: index ${idx} out of range.`); return; }
        const removedId = order.splice(idx, 1)[0];
        nodes.delete(removedId);
        rebuildPointers();
        clearHighlights();
        log(`Deleted node at index=${idx} (id:${removedId}).`);
        setStatus(`Deleted index=${idx}.`);
        render();
        validateIntegrity(true);
      }
      function deleteValueInstant(value){
        if(order.length === 0){ log('‚ùå Delete failed: list is empty.'); setStatus('‚ùå Delete failed: list is empty.'); return; }
        const idx = order.findIndex(id => nodes.get(id)?.value === value);
        if(idx === -1){ log(`‚ùå Value ${value} not found. No deletion.`); setStatus(`‚ùå Value ${value} not found.`); clearHighlights(); render(); return; }
        deleteAtInstant(idx);
      }
      function buildListInstant(){
        const raw = buildInput.value.trim();
        if(raw === ''){ log('‚ö† Enter comma-separated values to build.'); setStatus('‚ö† Enter comma-separated values to build.'); return; }
        const parts = raw.split(',').map(s => s.trim()).filter(Boolean);
        nodes.clear(); order = []; headId = null; tailId = null; clearHighlights();
        for(const p of parts){
          const num = Number(p);
          const isNum = Number.isFinite(num) && /^[-+]?\d+(\.\d+)?$/.test(p);
          const value = isNum ? num : p;
          const id = createNode(value);
          order.push(id);
        }
        rebuildPointers();
        log(`Built list with ${order.length} nodes.`);
        setStatus(`Built list with ${order.length} nodes.`);
        render();
        validateIntegrity(true);
      }
      function clearListInstant(){
        nodes.clear(); order = []; headId = null; tailId = null; clearHighlights();
        steps = []; stepIndex = 0; stepSnapshot = null;
        log('Cleared list.');
        setStatus('Cleared list.');
        render();
        validateIntegrity(true);
      }

      // ---------- Step Mode ----------
      function queueSteps(stepList, snapshotBefore=true){
        if(animating){ log('‚ö† Cannot queue steps while animation is running.'); setStatus('‚ö† Stop animation first.'); return; }
        steps = []; stepIndex = 0; clearHighlights(); foundId = null; checkedIds.clear();
        if(snapshotBefore){ stepSnapshot = snapshotState(); } else { stepSnapshot = null; }
        steps = stepList;
        log(`Queued ${steps.length} step(s). Press Next Step.`);
        setStatus(`Queued ${steps.length} step(s). Press Next Step.`);
        render();
        updateStepControls();
      }
      function nextStep(){
        if(execMode() !== 'step') return;
        if(stepIndex >= steps.length) return;
        const s = steps[stepIndex];
        if(typeof s.highlightId !== 'undefined') activeId = s.highlightId;
        if(typeof s.checked !== 'undefined' && s.checked !== null) checkedIds.add(s.checked);
        if(typeof s.found !== 'undefined') foundId = s.found;
        if(s.status) setStatus(s.status);
        s.run();
        stepIndex++;
        if(stepIndex >= steps.length){ log('‚úÖ Steps complete.'); setStatus('‚úÖ Steps complete.'); }
        render();
        validateIntegrity(true);
      }
      function resetSteps(){
        if(execMode() !== 'step') return;
        if(!stepSnapshot){ steps = []; stepIndex = 0; clearHighlights(); setStatus('No snapshot available.'); render(); updateStepControls(); return; }
        restoreState(stepSnapshot);
        steps = []; stepIndex = 0; stepSnapshot = null;
        updateStepControls();
        log('Steps reset (snapshot restored).');
      }
      function buildInsertAtSteps(idx, value){
        const localOrder = [...order]; const localHead = headId;
        if(idx < 0) idx = 0;
        if(idx > localOrder.length) idx = localOrder.length;
        const stepList = [];
        if(localOrder.length === 0){
          stepList.push({ label:'Insert into empty list', status:`Insert into empty list at index 0`, highlightId:null, run: () => { insertAtInstant(0, value); } });
          return stepList;
        }
        const traverseCount = Math.min(idx, localOrder.length);
        let cur = localHead;
        for(let k=0;k<traverseCount && cur!==null;k++){
          const curNode = nodes.get(cur);
          stepList.push({ label:`Traverse k=${k}`, status:`Traversing: at node id:${cur} value:${curNode?.value}`, highlightId:cur, checked:cur, run: () => {} });
          cur = curNode?.nextId ?? null;
          if(mode()==='circular' && cur===localHead && k<traverseCount-1) break;
        }
        stepList.push({ label:'Pointer update + Insert', status:`Insert value=${value} at index=${idx} (apply pointer updates)`, highlightId:null, run: () => { insertAtInstant(idx, value); } });
        return stepList;
      }
      function buildDeleteAtSteps(idx){
        if(order.length === 0){
          return [{ label:'Delete fail', status:'‚ùå Delete failed: list is empty.', run: () => { log('‚ùå Delete failed: list is empty.'); } }];
        }
        if(idx < 0 || idx >= order.length){
          return [{ label:'Delete fail', status:`‚ùå Delete failed: index ${idx} out of range.`, run: () => { log(`‚ùå Delete failed: index ${idx} out of range.`); } }];
        }
        const stepList = []; let cur = headId;
        for(let k=0;k<=idx && cur!==null;k++){
          const curNode = nodes.get(cur);
          stepList.push({ label:`Traverse k=${k}`, status:`Traversing: at node id:${cur} value:${curNode?.value}`, highlightId:cur, checked:cur, run: () => {} });
          if(k === idx) break;
          cur = curNode?.nextId ?? null;
          if(mode()==='circular' && cur===headId && k<idx-1) break;
        }
        stepList.push({ label:'Delete apply', status:`Delete node at index=${idx} (apply pointer updates)`, highlightId:null, run: () => { deleteAtInstant(idx); } });
        return stepList;
      }
      function buildDeleteValueSteps(value){
        if(order.length === 0){
          return [{ label:'Delete fail', status:'‚ùå Delete failed: list is empty.', run: () => { log('‚ùå Delete failed: list is empty.'); } }];
        }
        const stepList = []; let cur = headId; let k = 0; const visited = new Set();
        while(cur !== null){
          if(mode()==='circular'){ if(visited.has(cur)) break; visited.add(cur); }
          const curNode = nodes.get(cur);
          stepList.push({ label:`Check node`, status:`Checking node id:${cur} value:${curNode?.value}`, highlightId:cur, checked:cur, run: () => {} });
          if(curNode && curNode.value === value){
            stepList.push({ label:'Delete apply', status:`Found value=${value}. Deleting at position ${k} (apply pointer updates).`, highlightId:cur, found:cur, run: () => { deleteAtInstant(k); } });
            return stepList;
          }
          cur = curNode?.nextId ?? null; k++;
          if(mode() !== 'circular' && cur === null) break;
        }
        stepList.push({ label:'Not found', status:`‚ùå Value ${value} not found. No deletion.`, highlightId:null, run: () => { log(`‚ùå Value ${value} not found. No deletion.`); } });
        return stepList;
      }

      // ---------- Animated Search ----------
      async function searchAnimated(value){
        if(animating) return;
        if(order.length === 0){ log('üîé Search failed: list is empty.'); setStatus('üîé Search failed: list is empty.'); return; }
        steps = []; stepIndex = 0; stepSnapshot = null; updateStepControls();
        animating = true; cancelToken = { cancelled: false }; setControlsEnabled(false); stopBtn.disabled = false;
        clearHighlights(); render();
        log(`Search started for value=${value} (animated).`);
        setStatus(`Searching for ${value}...`);
        let cur = headId; let pos = 0; const visited = new Set(); const maxSteps = (mode() === 'circular') ? order.length + 1 : order.length + 1;
        for(let step=0; step<maxSteps; step++){
          if(cancelToken.cancelled){ log('‚õî Search cancelled.'); setStatus('‚õî Search cancelled.'); break; }
          if(cur === null){ setStatus(`‚ùå Not found (reached null).`); log(`‚ùå Not found: reached null.`); break; }
          if(mode() === 'circular'){
            if(visited.has(cur)){ setStatus(`‚ùå Not found (returned to head).`); log(`‚ùå Not found: loop complete.`); break; }
            visited.add(cur);
          }
          const n = nodes.get(cur);
          checkedIds.add(cur); activeId = cur; foundId = null; render();
          setStatus(`Checking node id:${cur} value:${n.value} (pos ${pos})`);
          await sleep(Number(speed.value));
          if(cancelToken.cancelled){ log('‚õî Search cancelled.'); setStatus('‚õî Search cancelled.'); break; }
          if(n.value === value){ foundId = cur; activeId = cur; render(); setStatus(`‚úÖ Found value=${value} at position ${pos} (id:${cur}).`); log(`‚úÖ Found value=${value} at position ${pos} (id:${cur}).`); break; }
          cur = n.nextId; pos++;
        }
        animating = false; setControlsEnabled(true); stopBtn.disabled = true; validateIntegrity(true);
      }
      function stopAnimation(){ if(!animating) return; cancelToken.cancelled = true; }

      // ---------- Step Search Builder ----------
      function buildSearchSteps(value){
        if(order.length === 0){
          return [{ label:'Search fail', status:'üîé Search failed: list is empty.', run: () => { log('üîé Search failed: list is empty.'); } }];
        }
        const stepList = []; let cur = headId; let pos = 0; const visited = new Set();
        while(cur !== null){
          if(mode() === 'circular'){ if(visited.has(cur)) break; visited.add(cur); }
          const n = nodes.get(cur);
          stepList.push({ label:'Check node', status:`Checking node id:${cur} value:${n.value} (pos ${pos})`, highlightId:cur, checked:cur, run: () => {} });
          if(n.value === value){
            stepList.push({ label:'Found', status:`‚úÖ Found value=${value} at position ${pos} (id:${cur}).`, highlightId:cur, found:cur, run: () => { log(`‚úÖ Found value=${value} at position ${pos} (id:${cur}).`); } });
            return stepList;
          }
          cur = n.nextId; pos++;
          if(mode() !== 'circular' && cur === null) break;
        }
        stepList.push({ label:'Not found', status:`‚ùå Not found: value=${value}.`, highlightId:null, run: () => { log(`‚ùå Not found: value=${value}.`); } });
        return stepList;
      }

      // ---------- Event Listeners ----------
      buildBtn.addEventListener('click', () => {
        if(execMode() === 'step'){ buildListInstant(); steps = []; stepIndex = 0; stepSnapshot = null; updateStepControls(); }
        else { buildListInstant(); }
      });
      clearBtn.addEventListener('click', () => { if(animating) return; clearListInstant(); });
      validateBtn.addEventListener('click', () => { const ok = validateIntegrity(false); log(ok ? '‚úÖ Integrity OK.' : '‚ùå Integrity ERROR.'); setStatus(ok ? '‚úÖ Integrity OK.' : '‚ùå Integrity ERROR.'); });
      insHeadBtn.addEventListener('click', () => { const v = parseValueInput(); if(v === null) return; if(execMode() === 'instant'){ insertHeadInstant(v); } else { queueSteps(buildInsertAtSteps(0, v)); } });
      insTailBtn.addEventListener('click', () => { const v = parseValueInput(); if(v === null) return; if(execMode() === 'instant'){ insertTailInstant(v); } else { queueSteps(buildInsertAtSteps(order.length, v)); } });
      insIndexBtn.addEventListener('click', () => { const v = parseValueInput(); if(v === null) return; const idx = parseIndexInput(); if(idx === null) return; if(execMode() === 'instant'){ insertAtInstant(idx, v); } else { queueSteps(buildInsertAtSteps(idx, v)); } });
      delIndexBtn.addEventListener('click', () => { const idx = parseIndexInput(); if(idx === null) return; if(execMode() === 'instant'){ deleteAtInstant(idx); } else { queueSteps(buildDeleteAtSteps(idx)); } });
      delValBtn.addEventListener('click', () => { const v = parseValueInput(); if(v === null) return; if(execMode() === 'instant'){ deleteValueInstant(v); } else { queueSteps(buildDeleteValueSteps(v)); } });
      searchBtn.addEventListener('click', async () => {
        const v = parseValueInput(); if(v === null) return;
        if(execMode() === 'step'){ queueSteps(buildSearchSteps(v)); }
        else { await searchAnimated(v); }
      });
      stopBtn.addEventListener('click', stopAnimation);
      nextStepBtn.addEventListener('click', () => { if(animating) return; nextStep(); });
      resetStepsBtn.addEventListener('click', () => { if(animating) return; resetSteps(); });
      container.querySelector('#clearLog').addEventListener('click', () => { logBox.innerHTML = ''; });
      elMode.addEventListener('change', () => { if(animating) return; rebuildPointers(); clearHighlights(); steps = []; stepIndex = 0; stepSnapshot = null; log(`Mode changed to: ${mode()}`); setStatus(`Mode changed to: ${mode()}`); render(); validateIntegrity(true); updateLinkedListExplanation(); });
      elExecMode.addEventListener('change', () => { if(animating) return; steps = []; stepIndex = 0; stepSnapshot = null; updateStepControls(); log(`Execution changed to: ${execMode()}`); setStatus(`Execution: ${execMode()}`); clearHighlights(); render(); });
      speed.addEventListener('input', updateSpeedLabel);

      // ---------- Init ----------
      updateSpeedLabel();
      rebuildPointers();
      render();
      validateIntegrity(true);
      setStatus('Ready.');

      // ====================== LINKED LIST EXPLANATIONS & PYTHON CODE ======================
      const modeContent = {
        en: {
          singly: {
            desc: "<strong>Singly Linked List</strong>: Each node has a <code>data</code> field and a <code>next</code> pointer to the following node. Traversal is only forward. Memory efficient but no backward navigation.",
            python: `class ListNode:
    def __init__(self, val=0):
        self.val = val
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None
    
    def prepend(self, val):
        new_node = ListNode(val)
        new_node.next = self.head
        self.head = new_node
    
    def append(self, val):
        if not self.head:
            self.head = ListNode(val)
            return
        curr = self.head
        while curr.next:
            curr = curr.next
        curr.next = ListNode(val)
    
    def delete(self, val):
        if not self.head: return
        if self.head.val == val:
            self.head = self.head.next
            return
        curr = self.head
        while curr.next and curr.next.val != val:
            curr = curr.next
        if curr.next:
            curr.next = curr.next.next`
          },
          doubly: {
            desc: "<strong>Doubly Linked List</strong>: Each node has <code>prev</code> and <code>next</code> pointers, enabling bidirectional traversal. Slightly more memory per node, but allows efficient reverse iteration and deletion without a prior reference.",
            python: `class ListNode:
    def __init__(self, val=0):
        self.val = val
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def prepend(self, val):
        new_node = ListNode(val)
        if not self.head:
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
    
    def append(self, val):
        new_node = ListNode(val)
        if not self.tail:
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
    
    def delete(self, val):
        curr = self.head
        while curr and curr.val != val:
            curr = curr.next
        if not curr: return
        if curr.prev: curr.prev.next = curr.next
        else: self.head = curr.next
        if curr.next: curr.next.prev = curr.prev
        else: self.tail = curr.prev`
          },
          circular: {
            desc: "<strong>Circular Singly Linked List</strong>: The last node's <code>next</code> points back to the head, forming a loop. Useful for round-robin scheduling or buffers. Traversal must guard against infinite loops by tracking visited nodes or using size limits.",
            python: `class ListNode:
    def __init__(self, val=0):
        self.val = val
        self.next = None

class CircularLinkedList:
    def __init__(self):
        self.head = None
        self.size = 0
    
    def append(self, val):
        new_node = ListNode(val)
        if not self.head:
            self.head = new_node
            new_node.next = self.head
        else:
            curr = self.head
            while curr.next != self.head:
                curr = curr.next
            curr.next = new_node
            new_node.next = self.head
        self.size += 1
    
    def search(self, target):
        if not self.head: return False
        curr = self.head
        for _ in range(self.size):
            if curr.val == target:
                return True
            curr = curr.next
        return False`
          }
        },
        uz: {
          singly: {
            desc: "<strong>Yagona Bog'langan Ro'yxat</strong>: Har bir tugun <code>ma'lumot</code> maydoni va keyingi tugunga ko'rsatkich (<code>next</code>) ni o'z ichiga oladi. Faqat oldinga qarab yurish mumkin. Xotiradan tejashli, lekin orqaga qaytish imkoni yo'q.",
            python: `class ListNode:
    def __init__(self, val=0):
        self.val = val
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None
    
    def prepend(self, val):
        new_node = ListNode(val)
        new_node.next = self.head
        self.head = new_node
    
    def append(self, val):
        if not self.head:
            self.head = ListNode(val)
            return
        curr = self.head
        while curr.next:
            curr = curr.next
        curr.next = ListNode(val)
    
    def delete(self, val):
        if not self.head: return
        if self.head.val == val:
            self.head = self.head.next
            return
        curr = self.head
        while curr.next and curr.next.val != val:
            curr = curr.next
        if curr.next:
            curr.next = curr.next.next`
          },
          doubly: {
            desc: "<strong>Ikki tomonlama Bog'langan Ro'yxat</strong>: Har bir tugunda <code>prev</code> (oldingi) va <code>next</code> (keyingi) ko'rsatkichlar mavjud, bu ikki tomonlama yurish imkonini beradi. Tugun boshina biroz ko'proq xotira talab qilinadi, lekin teskari takrorlash va referensiz o'chirish samarali amalga oshiriladi.",
            python: `class ListNode:
    def __init__(self, val=0):
        self.val = val
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def prepend(self, val):
        new_node = ListNode(val)
        if not self.head:
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
    
    def append(self, val):
        new_node = ListNode(val)
        if not self.tail:
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
    
    def delete(self, val):
        curr = self.head
        while curr and curr.val != val:
            curr = curr.next
        if not curr: return
        if curr.prev: curr.prev.next = curr.next
        else: self.head = curr.next
        if curr.next: curr.next.prev = curr.prev
        else: self.tail = curr.prev`
          },
          circular: {
            desc: "<strong>Aylanma Yagona Bog'langan Ro'yxat</strong>: Oxirgi tugunning <code>next</code> ko'rsatkichi bosh tugunga qaytadi, shu bilan halqa hosil qiladi. Aylanma jadval (round-robin) yoki buferlar uchun foydalidir. Cheksiz sikldan saqlanish uchun yurishda tashrif buyurilgan tugunlarni kuzatish yoki hajm chegarasidan foydalanish kerak.",
            python: `class ListNode:
    def __init__(self, val=0):
        self.val = val
        self.next = None

class CircularLinkedList:
    def __init__(self):
        self.head = None
        self.size = 0
    
    def append(self, val):
        new_node = ListNode(val)
        if not self.head:
            self.head = new_node
            new_node.next = self.head
        else:
            curr = self.head
            while curr.next != self.head:
                curr = curr.next
            curr.next = new_node
            new_node.next = self.head
        self.size += 1
    
    def search(self, target):
        if not self.head: return False
        curr = self.head
        for _ in range(self.size):
            if curr.val == target:
                return True
            curr = curr.next
        return False`
          }
        }
      };

      function updateLinkedListExplanation() {
        const modeSelect = container.querySelector('#mode');
        const mode = modeSelect.value;
        const lang = localStorage.getItem('app-lang') || 'en';
        const content = modeContent[lang][mode] || modeContent.en[mode];

        container.querySelector('#mode-explanation').innerHTML = content.desc;
        container.querySelector('#python-code-content').textContent = content.python;
      }

      // Initial load
      updateLinkedListExplanation();

      // Listen for language changes
      window.addEventListener('storage', (e) => {
        if (e.key === 'app-lang') updateLinkedListExplanation();
      });
    })();

    // ====================== 15. HASH TABLE ======================
    let hashTable = null;
    function htPut() {
      const key = document.getElementById('ht-key').value.trim();
      const val = document.getElementById('ht-value').value.trim();
      if (!key) {
        alert('Key cannot be empty');
        return;
      }
      if (!hashTable) hashTable = new Map();
      hashTable.set(key, val);
      drawHashTable();
      document.getElementById('ht-key').value = '';
      document.getElementById('ht-value').value = '';
    }
    function htGet() {
      const key = document.getElementById('ht-key').value.trim();
      if (!key || !hashTable) {
        document.getElementById('ht-status').innerHTML = '<span style="color:#f66">Enter a key or build table first</span>';
        return;
      }
      const val = hashTable.get(key);
      if (val !== undefined) {
        document.getElementById('ht-status').innerHTML = `<span style="color:#0f0">Key '${key}' = '${val}'</span>`;
      } else {
        document.getElementById('ht-status').innerHTML = `<span style="color:#f66">Key '${key}' not found</span>`;
      }
    }
    function htRemove() {
      const key = document.getElementById('ht-key').value.trim();
      if (!key || !hashTable) return;
      const existed = hashTable.delete(key);
      drawHashTable();
      document.getElementById('ht-key').value = '';
      if (existed) {
        document.getElementById('ht-status').innerHTML = `<span style="color:#0f0">Key '${key}' removed</span>`;
      } else {
        document.getElementById('ht-status').innerHTML = `<span style="color:#f66">Key '${key}' not found</span>`;
      }
    }
    function htClear() {
      hashTable = null;
      drawHashTable();
      document.getElementById('ht-status').textContent = 'Table cleared';
    }
    function drawHashTable() {
      const canvas = document.getElementById('ht-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!hashTable || hashTable.size === 0) {
        document.getElementById('ht-status').textContent = T('ht_status');
        ctx.fillStyle = '#888';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Hash Table is empty', canvas.width / 2, canvas.height / 2);
        return;
      }
      const entries = Array.from(hashTable.entries());
      const buckets = 10;
      const bucketHeight = 35;
      const startX = 50;
      const startY = 50;
      const bucketWidth = (canvas.width - 100) / buckets;
      for (let i = 0; i < buckets; i++) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(startX + i * bucketWidth, startY, bucketWidth - 5, canvas.height - 100);
        ctx.strokeStyle = '#444';
        ctx.strokeRect(startX + i * bucketWidth, startY, bucketWidth - 5, canvas.height - 100);
        ctx.fillStyle = '#aaa';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Bucket ${i}`, startX + i * bucketWidth + bucketWidth / 2, startY - 10);
      }
      const bucketEntries = Array(buckets).fill().map(() => []);
      entries.forEach(([k, v]) => {
        const bucket = Math.abs(hashCode(k)) % buckets;
        bucketEntries[bucket].push({ k, v });
      });
      bucketEntries.forEach((entries, bucketIdx) => {
        entries.forEach((entry, idx) => {
          const x = startX + bucketIdx * bucketWidth + 10;
          const y = startY + 10 + idx * bucketHeight;
          ctx.fillStyle = '#667eea';
          ctx.fillRect(x, y, bucketWidth - 25, 25);
          ctx.strokeStyle = '#0ff';
          ctx.strokeRect(x, y, bucketWidth - 25, 25);
          ctx.fillStyle = 'white';
          ctx.font = '14px Arial';
          ctx.fillText(`${entry.k} ‚Üí ${entry.v}`, x + 5, y + 16);
        });
      });
      document.getElementById('ht-status').textContent = `Entries: ${hashTable.size}`;
    }
    function hashCode(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return hash;
    }

    // ====================== 16. TOPOLOGICAL SORT (ENHANCED) ======================
    (() => {
      const container = document.getElementById('toposort');
      if (!container) return;

      // State
      let nodes = 5;
      let edges = [];
      let animationState = null;
      let isAnimating = false;

      // DOM Elements
      const nodeInput = container.querySelector('#topo-nodes');
      const edgeFrom = container.querySelector('#edge-from');
      const edgeTo = container.querySelector('#edge-to');
      const addEdgeBtn = container.querySelector('#add-edge');
      const runBtn = container.querySelector('#run-topo');
      const clearBtn = container.querySelector('#clear-edges');
      const randomBtn = container.querySelector('#random-graph');
      const edgeList = container.querySelector('#edge-list');
      const inDegreeDisplay = container.querySelector('#in-degree-display');
      const canvas = container.querySelector('#topo-canvas');
      const ctx = canvas.getContext('2d');
      const statusDiv = container.querySelector('#topo-status');
      const resultDiv = container.querySelector('#topo-result');

      // Bilingual content
      const updateLanguage = () => {
        const lang = localStorage.getItem('app-lang') || 'en';
        const desc = lang === 'uz' ? 
          'Topologik saralash ‚Äî yo\'naltirilgan aylanmas graf (DAG) tugunlarini har bir u‚Üív qirrasi uchun u v dan oldin keladigan tartibda saralashdir. U vazifa jadvalini tuzish, kurs old-shartlari va qurilish tizimlarida ishlatiladi.' :
          'Topological Sort orders vertices in a Directed Acyclic Graph (DAG) so that for every directed edge u‚Üív, u comes before v. It\'s used in task scheduling, course prerequisites, and build systems.';
        
        container.querySelector('#topo-desc').textContent = desc;
        applyI18nToContainer(container);
      };

      function applyI18nToContainer(el) {
        el.querySelectorAll('[data-i18n]').forEach(node => {
          const key = node.getAttribute('data-i18n');
          node.textContent = T(key);
        });
      }

      // Initialize
      const initGraph = () => {
        nodes = parseInt(nodeInput.value) || 5;
        edges = [];
        updateUI();
        drawGraph();
      };

      const updateUI = () => {
        // Update edge list
        edgeList.innerHTML = edges.length ? 
          edges.map(e => `${e[0]} ‚Üí ${e[1]}`).join(', ') : 
          '<span style="opacity:0.6;">None</span>';
        
        // Calculate in-degree
        inDegree = Array(nodes).fill(0);
        edges.forEach(([u, v]) => {
          if (v < nodes) inDegree[v]++;
        });
        
        // Update in-degree display
        inDegreeDisplay.innerHTML = inDegree.map((deg, i) => `${i}:${deg}`).join(', ');
      };

      const drawGraph = (highlightNodes = {}, queueNodes = new Set(), processingNode = null) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (nodes === 0) {
          ctx.fillStyle = '#888';
          ctx.font = '24px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('Add nodes to begin', canvas.width/2, canvas.height/2);
          return;
        }
        
        // Position nodes in a circle
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2 - 50;
        const radius = Math.min(200, (Math.min(canvas.width, canvas.height) - 200) / 2);
        const angleStep = (2 * Math.PI) / nodes;
        
        const nodePositions = [];
        for (let i = 0; i < nodes; i++) {
          const angle = i * angleStep - Math.PI / 2;
          const x = centerX + radius * Math.cos(angle);
          const y = centerY + radius * Math.sin(angle);
          nodePositions.push({x, y});
          
          // Determine node color
          let color = '#667eea'; // Default
          if (highlightNodes[i] === 'processed') color = '#00c853'; // Green
          else if (queueNodes.has(i)) color = '#ffab00'; // Amber
          else if (highlightNodes[i] === 'cycle') color = '#ff5252'; // Red
          
          // Draw node
          ctx.beginPath();
          ctx.arc(x, y, 30, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
          ctx.strokeStyle = '#0ff';
          ctx.lineWidth = highlightNodes[i] === 'cycle' ? 4 : 2;
          ctx.stroke();
          
          // Draw node label
          ctx.fillStyle = 'white';
          ctx.font = '20px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(i, x, y);
          
          // Draw in-degree
          ctx.fillStyle = '#aaa';
          ctx.font = '14px Arial';
          ctx.fillText(`in:${inDegree[i]}`, x, y + 40);
        }
        
        // Draw edges
        edges.forEach(([u, v]) => {
          if (u >= nodes || v >= nodes) return;
          const from = nodePositions[u];
          const to = nodePositions[v];
          drawArrow(ctx, from.x, from.y, to.x, to.y, '#555');
        });
        
        // Highlight processing node
        if (processingNode !== null && processingNode < nodes) {
          const {x, y} = nodePositions[processingNode];
          ctx.strokeStyle = '#ffff00';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(x, y, 35, 0, Math.PI * 2);
          ctx.stroke();
        }
      };

      const drawArrow = (ctx, fromX, fromY, toX, toY, color) => {
        const headLen = 15;
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();
        
        // Arrowhead
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI/6), toY - headLen * Math.sin(angle - Math.PI/6));
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI/6), toY - headLen * Math.sin(angle + Math.PI/6));
        ctx.stroke();
      };

      // Event Listeners
      nodeInput.addEventListener('change', () => {
        const val = parseInt(nodeInput.value);
        nodeInput.value = Math.max(1, Math.min(10, val));
        initGraph();
      });

      addEdgeBtn.addEventListener('click', () => {
        const u = parseInt(edgeFrom.value);
        const v = parseInt(edgeTo.value);
        
        if (isNaN(u) || isNaN(v)) {
          alert(T('alert_valid_numbers'));
          return;
        }
        
        if (u < 0 || v < 0 || u >= nodes || v >= nodes) {
          alert(T('alert_node_range', {max: nodes-1}));
          return;
        }
        
        if (u === v) {
          alert(T('alert_no_self_loop'));
          return;
        }
        
        // Check for duplicate
        if (edges.some(e => e[0] === u && e[1] === v)) {
          alert(T('alert_duplicate_edge'));
          return;
        }
        
        edges.push([u, v]);
        edgeFrom.value = '';
        edgeTo.value = '';
        updateUI();
        drawGraph();
      });

      clearBtn.addEventListener('click', () => {
        edges = [];
        updateUI();
        drawGraph();
        resultDiv.innerHTML = '';
        statusDiv.textContent = '';
        statusDiv.style.backgroundColor = '';
      });

      randomBtn.addEventListener('click', () => {
        // Generate a random DAG
        edges = [];
        const maxEdges = Math.min(15, nodes * (nodes - 1) / 2);
        const possibleEdges = [];
        
        // Only allow edges from lower to higher index to guarantee acyclic
        for (let i = 0; i < nodes; i++) {
          for (let j = i + 1; j < nodes; j++) {
            possibleEdges.push([i, j]);
          }
        }
        
        // Shuffle and pick random edges
        for (let i = possibleEdges.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [possibleEdges[i], possibleEdges[j]] = [possibleEdges[j], possibleEdges[i]];
        }
        
        const numEdges = Math.min(maxEdges, Math.floor(Math.random() * possibleEdges.length) + 1);
        edges = possibleEdges.slice(0, numEdges);
        
        updateUI();
        drawGraph();
      });

      runBtn.addEventListener('click', async () => {
        if (isAnimating) return;
        isAnimating = true;
        runBtn.disabled = true;
        
        // Reset state
        const highlightNodes = {};
        const queueNodes = new Set();
        let processingNode = null;
        
        // Kahn's Algorithm with visualization
        const graph = Array(nodes).fill().map(() => []);
        const inDeg = Array(nodes).fill(0);
        
        edges.forEach(([u, v]) => {
          if (u < nodes && v < nodes) {
            graph[u].push(v);
            inDeg[v]++;
          }
        });
        
        const queue = [];
        const result = [];
        
        // Initialize queue
        for (let i = 0; i < nodes; i++) {
          if (inDeg[i] === 0) {
            queue.push(i);
            queueNodes.add(i);
          }
        }
        
        drawGraph(highlightNodes, queueNodes, processingNode);
        await sleep(800);
        
        while (queue.length > 0) {
          const u = queue.shift();
          queueNodes.delete(u);
          processingNode = u;
          
          drawGraph(highlightNodes, queueNodes, processingNode);
          await sleep(1000);
          
          result.push(u);
          highlightNodes[u] = 'processed';
          processingNode = null;
          
          drawGraph(highlightNodes, queueNodes, processingNode);
          await sleep(800);
          
          // Process neighbors
          for (const v of graph[u]) {
            inDeg[v]--;
            if (inDeg[v] === 0) {
              queue.push(v);
              queueNodes.add(v);
            }
          }
          
          drawGraph(highlightNodes, queueNodes, processingNode);
          await sleep(600);
        }
        
        // Final state
        if (result.length === nodes) {
          statusDiv.textContent = '‚úÖ Valid Topological Order';
          statusDiv.style.backgroundColor = 'rgba(0, 200, 83, 0.2)';
          resultDiv.innerHTML = `<span style="color:#00c853">${T('topo_order')}: ${result.join(' ‚Üí ')}</span>`;
        } else {
          // Mark all nodes as part of cycle
          for (let i = 0; i < nodes; i++) {
            if (!highlightNodes[i]) highlightNodes[i] = 'cycle';
          }
          drawGraph(highlightNodes, queueNodes, processingNode);
          
          statusDiv.textContent = '‚ùå Cycle Detected!';
          statusDiv.style.backgroundColor = 'rgba(255, 82, 82, 0.2)';
          resultDiv.innerHTML = `<span style="color:#ff5252">${T('cycle_detected')}</span>`;
        }
        
        isAnimating = false;
        runBtn.disabled = false;
      });

      // Helper
      const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

      // Initialize
      initGraph();
      updateLanguage();
      
      // Listen for language changes
      window.addEventListener('storage', (e) => {
        if (e.key === 'app-lang') updateLanguage();
      });

      // Expose function globally for language updates
      window.updateTopoExplanation = updateLanguage;
    })();

    // ====================== 17. KRUSKAL'S MST (ENHANCED) ======================
    (() => {
      const container = document.getElementById('kruskal');
      if (!container) return;

      // State
      let nodes = 4;
      let edges = [];
      let isAnimating = false;

      // DOM Elements
      const nodeInput = container.querySelector('#kruskal-nodes');
      const edgeU = container.querySelector('#edge-u');
      const edgeV = container.querySelector('#edge-v');
      const edgeW = container.querySelector('#edge-w');
      const addEdgeBtn = container.querySelector('#add-kruskal-edge');
      const runBtn = container.querySelector('#run-kruskal');
      const clearBtn = container.querySelector('#clear-kruskal-edges');
      const randomBtn = container.querySelector('#random-mst');
      const edgeList = container.querySelector('#kruskal-edge-list');
      const mstStatus = container.querySelector('#mst-status');
      const canvas = container.querySelector('#kruskal-canvas');
      const ctx = canvas.getContext('2d');
      const statusDiv = container.querySelector('#kruskal-status');
      const resultDiv = container.querySelector('#kruskal-result');

      // Bilingual content
      const updateLanguage = () => {
        const lang = localStorage.getItem('app-lang') || 'en';
        const desc = lang === 'uz' ? 
          'Kruskal algoritmi ‚Äî bog\'langan, yo\'naltirilmagan grafning minimal uzunlikdagi bog\'lovchi daraxtini (MUD) topish uchun eng kichik vaznli qirralarni ochko\'z qo\'shish orqali ishlaydi. Sikllarni aniqlash uchun Union-Find (ajratilgan to\'plamlar birlashmasi) dan foydalanadi. Siyrak graflar uchun ideal. Vaqt: saralash tufayli O(E log E).' :
          'Kruskal\'s Algorithm finds the Minimum Spanning Tree (MST) of a connected, undirected graph by greedily adding the smallest edge that doesn\'t form a cycle. It uses Union-Find (Disjoint Set Union) to detect cycles. Ideal for sparse graphs. Time: O(E log E) due to sorting.';
        
        container.querySelector('#kruskal-desc').textContent = desc;
        applyI18nToContainer(container);
      };

      function applyI18nToContainer(el) {
        el.querySelectorAll('[data-i18n]').forEach(node => {
          const key = node.getAttribute('data-i18n');
          node.textContent = T(key);
        });
      }

      // Initialize
      const initGraph = () => {
        nodes = parseInt(nodeInput.value) || 4;
        edges = [];
        updateUI();
        drawGraph();
      };

      const updateUI = () => {
        edgeList.innerHTML = edges.length ? 
          edges.map(e => `${e[0]}‚Äì${e[1]}:${e[2].toFixed(1)}`).join(', ') : 
          '<span style="opacity:0.6;">None</span>';
        mstStatus.textContent = `Edges: ${edges.length}, Required for MST: ${nodes - 1}`;
      };

      const drawGraph = (mstEdges = new Set(), processedEdges = new Set(), currentEdge = null) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (nodes === 0) {
          ctx.fillStyle = '#888';
          ctx.font = '24px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('Add nodes to begin', canvas.width/2, canvas.height/2);
          return;
        }
        
        // Position nodes in a circle
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2 - 50;
        const radius = Math.min(200, (Math.min(canvas.width, canvas.height) - 200) / 2);
        const angleStep = (2 * Math.PI) / nodes;
        
        const nodePositions = [];
        for (let i = 0; i < nodes; i++) {
          const angle = i * angleStep - Math.PI / 2;
          const x = centerX + radius * Math.cos(angle);
          const y = centerY + radius * Math.sin(angle);
          nodePositions.push({x, y});
          
          // Draw node
          ctx.beginPath();
          ctx.arc(x, y, 28, 0, Math.PI * 2);
          ctx.fillStyle = '#667eea';
          ctx.fill();
          ctx.strokeStyle = '#0ff';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Draw label
          ctx.fillStyle = 'white';
          ctx.font = '20px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(i, x, y);
        }
        
        // Draw edges
        edges.forEach(([u, v, w], idx) => {
          if (u >= nodes || v >= nodes) return;
          const from = nodePositions[u];
          const to = nodePositions[v];
          
          let color = '#aaa'; // Default gray
          let width = 2;
          
          if (mstEdges.has(idx)) {
            color = '#00c853'; // Green for MST
            width = 4;
          } else if (processedEdges.has(idx)) {
            color = '#ff5252'; // Red for skipped (cycle)
            width = 2;
          }
          
          if (currentEdge === idx) {
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
          }
          
          ctx.strokeStyle = color;
          ctx.lineWidth = width;
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          ctx.stroke();
          
          // Draw weight
          const mx = (from.x + to.x) / 2;
          const my = (from.y + to.y) / 2;
          ctx.fillStyle = color;
          ctx.font = '16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(w.toFixed(1), mx, my - 10);
        });
      };

      // Event Listeners
      nodeInput.addEventListener('change', () => {
        const val = parseInt(nodeInput.value);
        nodeInput.value = Math.max(2, Math.min(10, val));
        initGraph();
      });

      addEdgeBtn.addEventListener('click', () => {
        const u = parseInt(edgeU.value);
        const v = parseInt(edgeV.value);
        const w = parseFloat(edgeW.value);
        
        if (isNaN(u) || isNaN(v) || isNaN(w)) {
          alert(T('alert_valid_numbers'));
          return;
        }
        
        if (u < 0 || v < 0 || u >= nodes || v >= nodes) {
          alert(T('alert_node_range', {max: nodes-1}));
          return;
        }
        
        if (u === v) {
          alert(T('alert_no_self_loop'));
          return;
        }
        
        // Check for duplicate
        const exists = edges.some(e => (e[0] === u && e[1] === v) || (e[0] === v && e[1] === u));
        if (exists) {
          alert(T('alert_duplicate_edge'));
          return;
        }
        
        edges.push([u, v, w]);
        edgeU.value = '';
        edgeV.value = '';
        edgeW.value = '';
        updateUI();
        drawGraph();
      });

      clearBtn.addEventListener('click', () => {
        edges = [];
        updateUI();
        drawGraph();
        resultDiv.innerHTML = '';
        statusDiv.textContent = '';
        statusDiv.style.backgroundColor = '';
      });

      randomBtn.addEventListener('click', () => {
        // Generate a random connected graph
        edges = [];
        const allPossible = [];
        for (let i = 0; i < nodes; i++) {
          for (let j = i + 1; j < nodes; j++) {
            allPossible.push([i, j]);
          }
        }
        
        // Ensure connectivity: create a random spanning tree first
        const uf = new Array(nodes).fill().map((_, i) => i);
        const find = (x) => uf[x] === x ? x : (uf[x] = find(uf[x]));
        const union = (a, b) => {
          const ra = find(a), rb = find(b);
          if (ra !== rb) { uf[rb] = ra; return true; }
          return false;
        };
        
        // Add n-1 edges for spanning tree
        const treeEdges = [];
        while (treeEdges.length < nodes - 1) {
          const idx = Math.floor(Math.random() * allPossible.length);
          const [u, v] = allPossible[idx];
          if (union(u, v)) {
            treeEdges.push([u, v, (Math.random() * 9 + 1).toFixed(1)]);
            allPossible.splice(idx, 1);
          }
        }
        
        // Add some extra random edges
        const extraCount = Math.min(5, allPossible.length);
        for (let i = 0; i < extraCount; i++) {
          const [u, v] = allPossible[Math.floor(Math.random() * allPossible.length)];
          treeEdges.push([u, v, (Math.random() * 9 + 1).toFixed(1)]);
        }
        
        edges = treeEdges.map(e => [e[0], e[1], parseFloat(e[2])]);
        updateUI();
        drawGraph();
      });

      runBtn.addEventListener('click', async () => {
        if (isAnimating || edges.length === 0) return;
        isAnimating = true;
        runBtn.disabled = true;
        
        // Sort edges by weight
        const sortedEdges = [...edges].map((e, idx) => ({...e, origIdx: idx}))
          .sort((a, b) => a[2] - b[2]);
        
        // Union-Find setup
        const parent = Array(nodes).fill().map((_, i) => i);
        const rank = Array(nodes).fill(0);
        
        const find = (x) => {
          if (parent[x] !== x) parent[x] = find(parent[x]);
          return parent[x];
        };
        
        const union = (x, y) => {
          const rx = find(x), ry = find(y);
          if (rx === ry) return false;
          if (rank[rx] < rank[ry]) parent[rx] = ry;
          else if (rank[rx] > rank[ry]) parent[ry] = rx;
          else {
            parent[ry] = rx;
            rank[rx]++;
          }
          return true;
        };
        
        const mstEdges = new Set();
        const processedEdges = new Set();
        const mstResult = [];
        
        drawGraph(mstEdges, processedEdges);
        await sleep(800);
        
        for (const edge of sortedEdges) {
          const [u, v, w] = edge;
          const origIdx = edge.origIdx;
          
          // Highlight current edge
          drawGraph(mstEdges, processedEdges, origIdx);
          await sleep(1000);
          
          if (union(u, v)) {
            mstEdges.add(origIdx);
            mstResult.push([u, v, w]);
            drawGraph(mstEdges, processedEdges, origIdx);
            await sleep(800);
          } else {
            processedEdges.add(origIdx);
            drawGraph(mstEdges, processedEdges, origIdx);
            await sleep(600);
          }
          
          if (mstResult.length === nodes - 1) break;
        }
        
        // Final result
        const totalWeight = mstResult.reduce((sum, [, , w]) => sum + w, 0);
        if (mstResult.length === nodes - 1) {
          statusDiv.textContent = '‚úÖ MST Constructed!';
          statusDiv.style.backgroundColor = 'rgba(0, 200, 83, 0.2)';
          resultDiv.innerHTML = `
            <span style="color:#00c853">
              MST Edges: ${mstResult.map(([u, v, w]) => `${u}‚Äì${v}(${w.toFixed(1)})`).join(', ')}<br>
              Total Weight: ${totalWeight.toFixed(2)}
            </span>
          `;
        } else {
          statusDiv.textContent = '‚ùå Disconnected Graph!';
          statusDiv.style.backgroundColor = 'rgba(255, 82, 82, 0.2)';
          resultDiv.innerHTML = `<span style="color:#ff5252">${T('graph_disconnected')}</span>`;
        }
        
        isAnimating = false;
        runBtn.disabled = false;
      });

      const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

      // Initialize
      initGraph();
      updateLanguage();
      
      // Listen for language changes
      window.addEventListener('storage', (e) => {
        if (e.key === 'app-lang') updateLanguage();
      });

      // Expose function globally for language updates
      window.updateKruskalExplanation = updateLanguage;
    })();

    // ====================== 18. FLOYD-WARSHALL ======================
    async function runFloyd() {
      const edgeStr = document.getElementById('floyd-edges').value.trim();
      const n = parseInt(document.getElementById('floyd-nodes').value) || 0;
      if (n <= 0) {
        alert('Number of nodes must be > 0');
        return;
      }
      const graph = {};
      for (let i = 0; i < n; i++) graph[i] = {};
      if (edgeStr) {
        edgeStr.split(',').forEach(pair => {
          const [nodes, w] = pair.split(':');
          const [u, v] = nodes.split('-').map(x => parseInt(x.trim()));
          const weight = parseFloat(w);
          if (!isNaN(u) && !isNaN(v) && !isNaN(weight) && u >= 0 && v >= 0 && u < n && v < n) {
            graph[u][v] = weight;
          }
        });
      }
      const dist = floydWarshallJS(graph, n);
      let output = 'Distance Matrix:\n';
      for (let i = 0; i < n; i++) {
        output += dist[i].map(d => d === Infinity ? '‚àû' : d.toFixed(1)).join('\t') + '\n';
      }
      document.getElementById('floyd-result').textContent = output;
      drawFloydMatrix(dist, n);
    }
    function floydWarshallJS(graph, n) {
      const dist = Array(n).fill().map(() => Array(n).fill(Infinity));
      for (let i = 0; i < n; i++) dist[i][i] = 0;
      for (const u in graph) {
        for (const v in graph[u]) {
          dist[u][v] = graph[u][v];
        }
      }
      for (let k = 0; k < n; k++) {
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            if (dist[i][k] + dist[k][j] < dist[i][j]) {
              dist[i][j] = dist[i][k] + dist[k][j];
            }
          }
        }
      }
      return dist;
    }
    function drawFloydMatrix(dist, n) {
      const canvas = document.getElementById('floyd-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (n === 0) return;
      const cellSize = Math.min(80, (canvas.width - 100) / n);
      const startX = (canvas.width - n * cellSize) / 2;
      const startY = 50;
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const x = startX + j * cellSize;
          const y = startY + i * cellSize;
          ctx.fillStyle = '#1a1a2e';
          ctx.fillRect(x, y, cellSize, cellSize);
          ctx.strokeStyle = '#444';
          ctx.strokeRect(x, y, cellSize, cellSize);
          ctx.fillStyle = 'white';
          ctx.font = '16px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const val = dist[i][j];
          const text = val === Infinity ? '‚àû' : val.toFixed(1);
          ctx.fillText(text, x + cellSize / 2, y + cellSize / 2);
        }
      }
      ctx.fillStyle = '#aaa';
      for (let i = 0; i < n; i++) {
        ctx.fillText(i, startX + i * cellSize + cellSize / 2, startY - 15);
        ctx.fillText(i, startX - 20, startY + i * cellSize + cellSize / 2);
      }
    }

    // ====================== 19. SLIDING WINDOW ======================
    async function runSlidingWindow() {
      const arrStr = document.getElementById('sw-array').value.trim();
      const k = parseInt(document.getElementById('sw-k').value);
      if (k <= 0) {
        alert('Window size must be > 0');
        return;
      }
      const arr = arrStr.split(',').map(s => parseFloat(s.trim())).filter(x => !isNaN(x));
      if (arr.length === 0) {
        alert('Enter valid numbers');
        return;
      }
      if (arr.length < k) {
        document.getElementById('sw-result').innerHTML = '<span style="color:#f66">Array too small!</span>';
        return;
      }
      let windowSum = arr.slice(0, k).reduce((a, b) => a + b, 0);
      let maxSum = windowSum;
      let bestStart = 0;
      for (let i = k; i < arr.length; i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        if (windowSum > maxSum) {
          maxSum = windowSum;
          bestStart = i - k + 1;
        }
      }
      document.getElementById('sw-result').innerHTML =
        `<span style="color:#0f0">Max sum of size ${k}: ${maxSum} (subarray: [${arr.slice(bestStart, bestStart + k).join(', ')}])</span>`;
      drawSlidingWindow(arr, k, bestStart);
    }
    function drawSlidingWindow(arr, k, bestStart) {
      const canvas = document.getElementById('sw-canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const barWidth = Math.min(60, (canvas.width - 100) / arr.length);
      const barSpacing = 10;
      const totalWidth = arr.length * (barWidth + barSpacing) - barSpacing;
      const startX = (canvas.width - totalWidth) / 2;
      const baseY = canvas.height - 50;
      const maxVal = Math.max(...arr, 1);
      arr.forEach((val, i) => {
        const x = startX + i * (barWidth + barSpacing);
        const h = (val / maxVal) * 100;
        if (i >= bestStart && i < bestStart + k) {
          ctx.fillStyle = '#0f0';
        } else {
          ctx.fillStyle = '#667eea';
        }
        ctx.fillRect(x, baseY - h, barWidth, h);
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, baseY - h, barWidth, h);
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(val, x + barWidth / 2, baseY - h - 10);
        ctx.fillText(i, x + barWidth / 2, baseY + 20);
      });
    }

    // ====================== INITIALIZE ======================
    window.addEventListener('load', () => {
      const savedLang = localStorage.getItem('app-lang') || 'en';
      setLang(savedLang);
      loadArrayFromInput();
      loadSearchArray();
      visualizeArray();
      drawAstarGrid();
      drawGraph(document.getElementById('graph-canvas').getContext('2d'), new Set(), -1);
      document.getElementById('heap-type').value = heapType;
      buildBT();
      buildBST();
      buildAVL();
      buildTrie();
      // Linked List already initialized by its own IIFE
      drawHashTable();
    });
  </script>
</body>
</html>