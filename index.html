<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DSA Sandbox Pro - Ultimate Algorithm Visualizer</title>
<style>
body { 
    font-family: 'Segoe UI', sans-serif; 
    margin: 0; 
    background: #0f0f1a; 
    color: #ddd; 
    line-height: 1.6;
}
header { 
    background: linear-gradient(135deg, #667eea, #764ba2); 
    padding: 40px; 
    text-align: center; 
    color: white; 
}
nav { 
    background: #1a1a2e; 
    padding: 15px; 
    overflow-x: auto; 
    white-space: nowrap; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.4); 
}
nav a { 
    color: #82d8ff; 
    margin: 0 20px; 
    text-decoration: none; 
    font-weight: bold; 
    font-size: 1.1em; 
}
nav a:hover { 
    color: #ff6bcb; 
}
.container { 
    max-width: 1200px; 
    margin: 20px auto; 
    padding: 20px; 
}
.section { 
    display: none; 
    background: #16213e; 
    padding: 30px; 
    border-radius: 16px; 
    box-shadow: 0 15px 40px rgba(0,0,0,0.6); 
    margin-bottom: 30px; 
}
.active { 
    display: block;
}
h2 { 
    color: #82d8ff; 
    margin-top: 0; 
    border-bottom: 2px solid #667eea;
    padding-bottom: 10px;
}
h3 {
    color: #82d8ff;
    margin-top: 25px;
}
.controls { 
    margin: 15px 0; 
    display: flex; 
    flex-wrap: wrap; 
    gap: 10px; 
    align-items: center; 
    background: #1a1a2e;
    padding: 15px;
    border-radius: 8px;
}
input, select, button {
    padding: 10px 14px; 
    border-radius: 8px; 
    border: none; 
    font-size: 15px;
}
input, select { 
    background: #0f1629; 
    color: #a2e0a2; 
}
button {
    background: #00d4aa; 
    color: white; 
    font-weight: bold; 
    cursor: pointer;
    transition: all 0.3s;
}
button:hover { 
    background: #00b893; 
    transform: translateY(-2px); 
}
canvas { 
    display: block; 
    margin: 20px auto; 
    background: #0b1021; 
    border-radius: 12px; 
    box-shadow: 0 10px 30px rgba(0,0,0,0.6); 
}
.info { 
    margin-top: 10px; 
    padding: 12px; 
    background: #0004; 
    border-radius: 8px; 
    font-family: monospace; 
    color: #0f0; 
}
.details { 
    margin: 20px 0; 
    padding: 20px; 
    background: #1a1a2e; 
    border-radius: 12px; 
    border-left: 4px solid #667eea;
}
.python-code {
    background: #0a0a14;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 15px;
    margin: 15px 0;
    overflow-x: auto;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.4;
    color: #a2e0a2;
}
.python-code pre {
    margin: 0;
    white-space: pre-wrap;
}
.code-header {
    background: #333;
    color: #82d8ff;
    padding: 10px;
    border-radius: 6px 6px 0 0;
    font-weight: bold;
    text-align: center;
}
</style>
</head>
<body>
<header>
<h1>DSA Sandbox Pro</h1>
<p>Interactive • Beautiful • Fully Visual Algorithm Playground</p>
</header>
<nav>
<a href="#" onclick="show('arrays')">Arrays</a>
<a href="#" onclick="show('sorting')">Sorting</a>
<a href="#" onclick="show('searching')">Searching</a>
<a href="#" onclick="show('bt')">Binary Tree</a>
<a href="#" onclick="show('bst')">BST</a>
<a href="#" onclick="show('avl')">AVL Tree</a>
<a href="#" onclick="show('trie')">Trie</a>
<a href="#" onclick="show('heaps')">Heaps</a>
<a href="#" onclick="show('graphs')">Graphs</a>
<a href="#" onclick="show('bellman')">Bellman-Ford</a>
<a href="#" onclick="show('dijkstra')">Dijkstra</a>
<a href="#" onclick="show('astar')">A*</a>
<a href="#" onclick="show('recursion')">Recursion</a>
</nav>
<div class="container">
<div id="arrays" class="section active">
<h2>Dynamic Array Operations</h2>
<div class="details">
<h3>Details</h3>
<p>Dynamic arrays are resizable arrays that provide efficient random access and dynamic sizing. They automatically double in capacity when full to maintain amortized O(1) append operations. Key operations include access (O(1)), append/push (amortized O(1)), insert/delete at index (O(n) due to shifting), and search (O(n)). They are ideal for lists where size is unknown in advance, but frequent inserts/deletes in the middle can be costly due to element shifting.</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
class DynamicArray:
    def __init__(self):
        self.array = []
        self.capacity = 4
        self.size = 0

    def push(self, value):
        if self.size == self.capacity:
            self._resize(self.capacity * 2)
        self.array.append(value)
        self.size += 1

    def pop(self):
        if self.size == 0:
            raise IndexError("Array is empty")
        value = self.array.pop()
        self.size -= 1
        return value

    def insert(self, index, value):
        if index < 0 or index > self.size:
            raise IndexError("Invalid index")
        if self.size == self.capacity:
            self._resize(self.capacity * 2)
        self.array.insert(index, value)
        self.size += 1

    def delete(self, index):
        if index < 0 or index >= self.size:
            raise IndexError("Invalid index")
        del self.array[index]
        self.size -= 1

    def unshift(self, value):
        self.insert(0, value)

    def shift(self):
        return self.delete(0)

    def search(self, value):
        return self.array.index(value) if value in self.array else -1

    def _resize(self, new_capacity):
        new_array = [None] * new_capacity
        for i in range(self.size):
            new_array[i] = self.array[i]
        self.array = new_array
        self.capacity = new_capacity

# Example usage
da = DynamicArray()
da.push(10)
da.push(20)
print(da.array)  # [10, 20]
da.insert(1, 15)
print(da.array)  # [10, 15, 20]
print(da.search(15))  # 1
</pre>
</div>
<div class="controls">
<input type="text" id="array-input" value="10,5,8,3,9,1,15,7" style="flex:1">
<button onclick="loadArrayFromInput()">Load</button>
<button onclick="visualizeArray()">Refresh</button>
</div>
<div class="controls">
<input type="number" id="insert-val" placeholder="Value">
<input type="number" id="insert-idx" placeholder="Index">
<button onclick="insertAt()">Insert</button>
<input type="number" id="delete-idx" placeholder="Index">
<button onclick="deleteAt()">Delete</button>
<input type="number" id="push-val" placeholder="Value">
<button onclick="pushValue()">Push</button>
<button onclick="popValue()">Pop</button>
<input type="number" id="unshift-val" placeholder="Value">
<button onclick="unshiftValue()">Unshift</button>
<button onclick="shiftValue()">Shift</button>
<input type="number" id="search-val" placeholder="Find">
<button onclick="searchArraySearch()">Search</button>
<button onclick="clearArray()">Clear</button>
</div>
<canvas id="array-canvas" width="1100" height="380"></canvas>
<div class="info" id="array-status">Array: [] | Length: 0</div>
</div>

<div id="sorting" class="section">
<h2>Sorting Algorithms</h2>
<div class="details">
<h3>Details</h3>
<p>Sorting algorithms rearrange elements in ascending or descending order. <strong>Bubble Sort</strong> (O(n²)) swaps adjacent elements repeatedly. <strong>Quick Sort</strong> (average O(n log n), worst O(n²)) uses partitioning around a pivot. <strong>Merge Sort</strong> (O(n log n)) divides the array and merges sorted halves. These are fundamental for data organization, with trade-offs in stability, space, and time.</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x &lt; pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    merged = []
    i = j = 0
    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt; right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged

# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(arr.copy()))  # [11, 12, 22, 25, 34, 64, 90]
print(quick_sort(arr.copy()))   # [11, 12, 22, 25, 34, 64, 90]
print(merge_sort(arr.copy()))   # [11, 12, 22, 25, 34, 64, 90]
</pre>
</div>
<div class="controls">
<input type="text" id="sort-input" value="64,34,25,12,22,11,90,88,55">
<select id="sort-algo">
<option value="bubble">Bubble Sort</option>
<option value="quick">Quick Sort</option>
<option value="merge">Merge Sort</option>
</select>
<button onclick="startSorting()">Start</button>
<button onclick="resetSorting()">Reset</button>
</div>
<canvas id="sort-canvas" width="1100" height="450"></canvas>
<div class="info" id="sort-info">Steps: 0</div>
</div>

<div id="searching" class="section">
<h2>Search Algorithms</h2>
<div class="details">
<h3>Details</h3>
<p>Search algorithms locate a target in a collection. <strong>Linear Search</strong> (O(n)) checks each element sequentially, suitable for unsorted data. <strong>Binary Search</strong> (O(log n)) halves the search interval on sorted data. <strong>Jump Search</strong> (O(&#x221A;n)) skips blocks of size &#x221A;n, then performs linear search, offering a middle ground. <strong>Exponential Search</strong> (O(log n)) finds a range where the target exists using exponential steps, then performs Binary Search in that range. Both Jump and Exponential Search require the array to be sorted for efficient (sub-linear) operation.</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
def linear_search(arr, target):
    for i, val in enumerate(arr):
        if val == target:
            return i
    return -1

def binary_search(arr, target):
    arr.sort()  # Prerequisite: array must be sorted
    left, right = 0, len(arr) - 1
    while left &lt;= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] &lt; target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

def jump_search(arr, target):
    n = len(arr)
    step = int(n**0.5)
    prev = 0
    while arr[min(step, n)-1] &lt; target:
        prev = step
        step += int(n**0.5)
        if prev &gt;= n:
            return -1
    
    while arr[prev] &lt; target:
        prev += 1
        if prev == min(step, n):
            return -1
    
    if arr[prev] == target:
        return prev
    return -1

# Helper for Exponential Search
def binary_search_recursive(arr, target, left, right):
    if left &gt; right:
        return -1
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] &lt; target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

def exponential_search(arr, target):
    if arr[0] == target: return 0
    i = 1
    while i &lt; len(arr) and arr[i] &lt;= target:
        i *= 2
    
    # Call a binary search in the range [i/2, min(i, len(arr)-1)]
    return binary_search_recursive(arr, target, i//2, min(i, len(arr)-1))


# Example usage
arr = [12, 5, 23, 8, 45, 3, 67, 19, 34, 91]
arr.sort() # [3, 5, 8, 12, 19, 23, 34, 45, 67, 91]
print(f"Linear search (34): {linear_search([12, 5, 23, 8, 45, 3, 67, 19, 34, 91], 34)}")
print(f"Binary search (34): {binary_search(arr.copy(), 34)}")
print(f"Jump search (34): {jump_search(arr.copy(), 34)}")
print(f"Exponential search (34): {exponential_search(arr.copy(), 34)}")
</pre>
</div>
<div class="controls">
<input type="text" id="search-input" value="12,5,23,8,45,3,67,19,34,91">
<button onclick="loadSearchArray()">Load Array</button>
</div>
<div class="controls">
<input type="number" id="target-val" value="34">
<select id="search-algo">
<option value="linear">Linear Search</option>
<option value="binary">Binary Search</option>
<option value="jump">Jump Search</option>
<option value="exponential">Exponential Search</option>
</select>
<button onclick="startSearch()">Start Search</button>
<button onclick="resetSearch()">Reset</button>
</div>
<div class="info" id="search-steps">Steps: 0</div>
<div class="info" id="search-result"></div>
<canvas id="search-canvas" width="1100" height="380"></canvas>
</div>

<div id="bt" class="section">
<h2>Binary Tree (BT)</h2>
<div class="details">
<h3>Details</h3>
<p>A <strong>Binary Tree</strong> is a tree data structure in which each node has at most two children, referred to as the left child and the right child. Unlike a BST, there is no ordering constraint on the values. This implementation uses level-order insertion to create a **Complete Binary Tree** for visualization simplicity. Key operations include: Insert (O(1) in a complete BT array representation), and Traversals (O(n)).</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation (using array for a Complete BT)</div>
<pre>
class BinaryTree:
    def __init__(self):
        self.tree = []

    def insert(self, value):
        # Simplest way to represent a complete binary tree
        self.tree.append(value)
        
    def get_parent(self, i):
        return self.tree[(i - 1) // 2] if i > 0 else None

    def get_children(self, i):
        left_idx = 2 * i + 1
        right_idx = 2 * i + 2
        left = self.tree[left_idx] if left_idx < len(self.tree) else None
        right = self.tree[right_idx] if right_idx < len(self.tree) else None
        return left, right

# Example usage
bt = BinaryTree()
for val in [10, 5, 15, 3, 7, 12, 18]:
    bt.insert(val)
print(bt.tree) # [10, 5, 15, 3, 7, 12, 18]
</pre>
</div>
<div class="controls">
<input type="text" id="bt-input" value="10,5,15,3,7,12,18,1,9">
<button onclick="buildBT()">Build Tree</button>
<button onclick="traverseBT('inorder')">In-order</button>
<button onclick="traverseBT('preorder')">Pre-order</button>
<button onclick="traverseBT('postorder')">Post-order</button>
</div>
<canvas id="bt-canvas" width="1100" height="600"></canvas>
<div class="info" id="bt-traversal-output"></div>
</div>

<div id="bst" class="section">
<h2>Binary Search Tree (BST)</h2>
<div class="details">
<h3>Details</h3>
<p>A <strong>Binary Search Tree (BST)</strong> is a binary tree where each node's left subtree has values less than the node, and right has greater. It supports efficient search, insert, and delete (average O(log n), worst O(n) if unbalanced). Traversals include <strong>in-order</strong> (sorted), <strong>pre-order</strong>, and <strong>post-order</strong>.</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert(self.root, val)

    def _insert(self, node, val):
        if val &lt; node.val:
            if node.left is None:
                node.left = TreeNode(val)
            else:
                self._insert(node.left, val)
        elif val > node.val:
            if node.right is None:
                node.right = TreeNode(val)
            else:
                self._insert(node.right, val)

    # Inorder traversal (returns sorted array)
    def inorder(self, node):
        res = []
        if node:
            res.extend(self.inorder(node.left))
            res.append(node.val)
            res.extend(self.inorder(node.right))
        return res

# Example usage
bst = BST()
for val in [50, 30, 70, 20, 40, 60, 80]:
    bst.insert(val)
print(bst.inorder(bst.root))  # [20, 30, 40, 50, 60, 70, 80]
</pre>
</div>
<div class="controls">
<input type="text" id="bst-input" value="50,30,70,20,40,60,80,90,10">
<button onclick="buildBST()">Build BST</button>
<button onclick="traverseBST('inorder')">In-order</button>
<button onclick="traverseBST('preorder')">Pre-order</button>
<button onclick="traverseBST('postorder')">Post-order</button>
</div>
<canvas id="bst-canvas" width="1100" height="600"></canvas>
<div class="info" id="bst-traversal-output"></div>
</div>

<div id="avl" class="section">
<h2>AVL Tree (Self-Balancing BST)</h2>
<div class="details">
<h3>Details</h3>
<p>An <strong>AVL Tree</strong> is a self-balancing Binary Search Tree where the height difference (balance factor) between the left and right subtrees of any node is at most 1. This strict balance ensures that search, insert, and delete operations maintain an optimal time complexity of O(log n) even in the worst-case scenario, unlike a regular BST which can degenerate to O(n).</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation (Simplified)</div>
<pre>
class AVLNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    # A full implementation requires methods for:
    # 1. Getting node height
    # 2. Calculating balance factor
    # 3. Performing Left/Right Rotations
    # 4. Insertion that calls rotation functions if imbalance > 1

    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        return self.get_height(node.left) - self.get_height(node.right) if node else 0

    def right_rotate(self, y):
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        # Update heights
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        return x # new root

    # ... and left_rotate, insert, and delete methods
</pre>
</div>
<div class="controls">
<input type="number" id="avl-insert-val" placeholder="Value to Insert">
<button onclick="insertAVL()">Insert Value</button>
<input type="text" id="avl-input" value="10,20,30,40,50,25">
<button onclick="buildAVL()">Build Tree</button>
<button onclick="clearAVL()">Clear</button>
</div>
<canvas id="avl-canvas" width="1100" height="600"></canvas>
</div>

<div id="trie" class="section">
<h2>Trie (Prefix Tree)</h2>
<div class="details">
<h3>Details</h3>
<p>A <strong>Trie</strong>, or Prefix Tree, is an efficient data structure for storing and searching a dynamic set of strings. It organizes strings based on shared prefixes. Search and insertion are typically O(L), where L is the length of the string, making it much faster than BSTs for strings. Tries are used for auto-complete, spell checkers, and IP routing. Each node stores a map to its children (characters), and a boolean flag marks the end of a word.</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

    def starts_with(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True

# Example usage
trie = Trie()
trie.insert("apple")
trie.insert("apply")
trie.insert("app")
print(trie.search("apple"))  # True
print(trie.starts_with("app")) # True
print(trie.search("banana")) # False
</pre>
</div>
<div class="controls">
<input type="text" id="trie-insert-word" placeholder="Word to Insert (e.g., car)">
<button onclick="insertTrieWord()">Insert Word</button>
<input type="text" id="trie-input" value="car,cat,cab,dog,dot">
<button onclick="buildTrie()">Build Trie</button>
<input type="text" id="trie-search-word" placeholder="Search/Prefix (e.g., ca)">
<button onclick="searchTrieWord()">Search/Prefix</button>
<button onclick="clearTrie()">Clear</button>
</div>
<canvas id="trie-canvas" width="1100" height="500"></canvas>
<div class="info" id="trie-status">Trie is empty.</div>
</div>

<div id="heaps" class="section">
<h2>Heaps</h2>
<div class="details">
<h3>Details</h3>
<p><strong>Heaps</strong> are complete binary trees satisfying the heap property: <strong>min-heap</strong> (parent ≤ children) or <strong>max-heap</strong> (parent ≥ children). They support insert and extract-min/max in O(log n), used for priority queues. Building a heap is O(n).</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
import heapq

# Min-Heap example
min_heap = []
heapq.heappush(min_heap, 5)
heapq.heappush(min_heap, 3)
heapq.heappush(min_heap, 8)
print(heapq.heappop(min_heap))  # 3

# Max-Heap (simulate with negatives)
max_heap = []
heapq.heappush(max_heap, -5)
heapq.heappush(max_heap, -3)
heapq.heappush(max_heap, -8)
print(-heapq.heappop(max_heap))  # 8

# Heapify existing list
arr = [3, 1, 4, 1, 5]
heapq.heapify(arr)  # Converts to min-heap
print(arr)  # [1, 1, 4, 3, 5]
</pre>
</div>
<div class="controls">
<select id="heap-type" onchange="updateHeapType(this.value)">
<option value="min">Min-Heap</option>
<option value="max">Max-Heap</option>
</select>
<input type="text" id="heap-input" placeholder="Values: 1,2,3,...">
<button onclick="loadHeap()">Load Heap</button>
<input type="number" id="heap-size" value="10" placeholder="Size">
<button onclick="randomHeap()">Random Heap</button>
<input type="number" id="heap-val" placeholder="Value">
<button onclick="heapInsert()">Insert</button>
<button onclick="heapExtract()">Extract Root</button>
<button onclick="heap=[];drawHeap()">Clear</button>
</div>
<canvas id="heap-canvas" width="1100" height="500"></canvas>
</div>

<div id="graphs" class="section">
<h2>Graph Traversal</h2>
<div class="details">
<h3>Details</h3>
<p>Graphs consist of nodes and edges. <strong>BFS</strong> (Breadth-First Search) explores level-by-level using a queue (O(V+E)), good for shortest paths in unweighted graphs. <strong>DFS</strong> (Depth-First Search) explores deeply using recursion (O(V+E)), useful for cycles or topological sort.</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
from collections import deque

graph = {
    0: [1, 3],
    1: [0, 2, 4],
    2: [1, 5],
    3: [0, 4],
    4: [1, 3, 5],
    5: [2, 4]
}

def bfs(start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    while queue:
        node = queue.popleft()
        print(node, end=' ')
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

def dfs(node, visited=None):
    if visited is None:
        visited = set()
    visited.add(node)
    print(node, end=' ')
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(neighbor, visited)

# Example usage
bfs(0)  # 0 1 3 2 4 5
dfs(0)  # 0 1 2 5 4 3
</pre>
</div>
<div class="controls">
<button onclick="runBFS()">BFS</button>
<button onclick="runDFS()">DFS</button>
</div>
<canvas id="graph-canvas" width="1100" height="500"></canvas>
</div>

<div id="bellman" class="section">
<h2>Bellman-Ford Algorithm</h2>
<div class="details">
<h3>Details</h3>
<p><strong>Bellman-Ford</strong> computes shortest paths from a source in graphs with negative weights (O(VE)). It relaxes all edges V-1 times and detects negative cycles. Unlike Dijkstra, it handles negatives but is slower.</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
def bellman_ford(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    for _ in range(len(graph) - 1):
        for u in graph:
            for v, weight in graph[u].items():
                if dist[u] + weight &lt; dist[v]:
                    dist[v] = dist[u] + weight
    # Check for negative cycles
    for u in graph:
        for v, weight in graph[u].items():
            if dist[u] + weight &lt; dist[v]:
                raise ValueError("Negative cycle detected")
    return dist

# Example graph (dict of dicts)
graph = {
    0: {1: 4, 3: 5},
    1: {2: 3},
    3: {1: -6, 2: 2},
    2: {}
}
print(bellman_ford(graph, 0))  # {0: 0, 1: -1, 2: 1, 3: 5}
</pre>
</div>
<button onclick="runBellmanFord()">Run</button>
<canvas id="bellman-canvas" width="1100" height="500"></canvas>
<div class="info" id="bellman-output"></div>
</div>

<div id="dijkstra" class="section">
<h2>Dijkstra's Algorithm</h2>
<div class="details">
<h3>Details</h3>
<p><strong>Dijkstra</strong> finds shortest paths from a source in graphs with non-negative weights (O((V+E) log V) with priority queue). It uses a greedy approach, selecting the closest unvisited node each time.</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
import heapq

def dijkstra(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]
    while pq:
        current_dist, u = heapq.heappop(pq)
        if current_dist > dist[u]:
            continue
        for v, weight in graph[u].items():
            if dist[u] + weight &lt; dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(pq, (dist[v], v))
    return dist

# Example graph
graph = {
    0: {1: 4, 3: 2},
    1: {2: 3},
    3: {1: 1, 2: 5},
    2: {}
}
print(dijkstra(graph, 0))  # {0: 0, 1: 3, 2: 6, 3: 2}
</pre>
</div>
<div class="controls">
<select id="graph-dir">
<option value="directed">Directed</option>
<option value="undirected">Undirected</option>
</select>
<input type="text" id="graph-edges" value="0-1:4,0-3:2,1-2:3,3-1:1,3-2:5" style="flex:1">
<input type="number" id="dijkstra-start" value="0" placeholder="Start">
<input type="number" id="dijkstra-end" value="2" placeholder="End">
<button onclick="loadDijkstraGraph(); runDijkstra();">Load & Run</button>
</div>
<canvas id="dijkstra-canvas" width="1100" height="500"></canvas>
<div class="info" id="dijkstra-output"></div>
</div>

<div id="astar" class="section">
<h2>A* Pathfinding</h2>
<div class="details">
<h3>Details</h3>
<p><strong>A*</strong> is an informed search algorithm for pathfinding, combining Dijkstra's shortest path with greedy best-first search using heuristics (e.g., Manhattan distance). It's optimal with admissible heuristics, efficient for grids/maps (time varies, worst exponential).</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
import heapq

def a_star(grid, start, goal):
    def heuristic(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal)}
    while open_set:
        _, current = heapq.heappop(open_set)
        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = (current[0] + dx, current[1] + dy)
            if 0 &lt;= neighbor[0] &lt; len(grid) and 0 &lt;= neighbor[1] &lt; len(grid[0]) and grid[neighbor[0]][neighbor[1]] != 1:  # Not wall
                tentative_g = g_score[current] + 1
                if tentative_g &lt; g_score.get(neighbor, float('inf')):
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + heuristic(neighbor, goal)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
    return None  # No path

# Example grid (0: open, 1: wall)
grid = [[0, 0, 0], [1, 0, 1], [0, 0, 0]]
print(a_star(grid, (0, 0), (2, 2)))  # Path like [(0,0), (0,1), (1,1), (2,1), (2,2)]
</pre>
</div>
<div class="controls">
<button onclick="runAstar()">Find Path</button>
<button onclick="clearGrid()">Clear Walls</button>
Speed: <input type="range" id="astar-speed" min="1" max="100" value="50">
</div>
<canvas id="astar-canvas" width="900" height="540"></canvas>
</div>

<div id="recursion" class="section">
<h2>Towers of Hanoi (Recursion)</h2>
<div class="details">
<h3>Details</h3>
<p><strong>Towers of Hanoi</strong> is a classic recursion problem: move n disks from peg A to C using B as auxiliary, without placing larger disks on smaller. It demonstrates divide-and-conquer, with 2^n - 1 moves. Recursion depth is n, time O(2^n).</p>
</div>
<div class="python-code">
<div class="code-header">Python Implementation</div>
<pre>
def hanoi(n, from_peg, to_peg, aux_peg):
    if n == 1:
        print(f"Move disk 1 from {from_peg} to {to_peg}")
        return
    hanoi(n-1, from_peg, aux_peg, to_peg)
    print(f"Move disk {n} from {from_peg} to {to_peg}")
    hanoi(n-1, aux_peg, to_peg, from_peg)

# Example usage
hanoi(3, 'A', 'C', 'B')
# Output:
# Move disk 1 from A to C
# Move disk 2 from A to B
# Move disk 1 from C to B
# Move disk 3 from A to C
# Move disk 1 from B to A
# Move disk 2 from B to C
# Move disk 1 from A to C
</pre>
</div>
<div class="controls">
Disks: <input type="range" id="hanoi-disks" min="3" max="8" value="4">
<button onclick="solveHanoi()">Solve</button>
</div>
<canvas id="hanoi-canvas" width="1100" height="450"></canvas>
</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
<script>
// Navigation
function show(id) {
    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
}

// Utility
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ====================== 1. DYNAMIC ARRAY ======================
let dynamicArray = [];
function loadArrayFromInput() {
    const vals = document.getElementById('array-input').value.split(',').map(n => Number(n.trim())).filter(n => !isNaN(n));
    dynamicArray = vals;
    visualizeArray();
}
function updateArrayStatus() {
    document.getElementById('array-status').textContent = `Array: [${dynamicArray.join(', ')}] | Length: ${dynamicArray.length}`;
}
function visualizeArray() {
    const arr = dynamicArray;
    const canvas = document.getElementById('array-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (arr.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Array is empty', canvas.width/2, canvas.height/2);
        updateArrayStatus();
        return;
    }
    const maxVal = Math.max(...arr, 10);
    const cellW = Math.min(100, canvas.width / arr.length * 0.85);
    const startX = (canvas.width - arr.length * cellW) / 2;
    const baseY = canvas.height - 100;
    arr.forEach((val, i) => {
        const h = (val / maxVal) * 220;
        const x = startX + i * cellW;
        ctx.fillStyle = '#00d4ff';
        ctx.fillRect(x + 10, baseY - h, cellW - 20, h);
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.strokeRect(x + 10, baseY - h, cellW - 20, h);
        ctx.fillStyle = 'white';
        ctx.font = '22px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(val, x + cellW/2, baseY - h - 10);
        ctx.fillStyle = '#aaa';
        ctx.font = '16px Arial';
        ctx.fillText(i, x + cellW/2, baseY + 30);
    });
    updateArrayStatus();
}
function insertAt() { 
    const v = Number(document.getElementById('insert-val').value); 
    let i = Number(document.getElementById('insert-idx').value); 
    if(isNaN(v)) return; 
    i = Math.max(0, Math.min(i, dynamicArray.length)); 
    dynamicArray.splice(i, 0, v); 
    visualizeArray(); 
}
function deleteAt() { 
    const i = Number(document.getElementById('delete-idx').value); 
    if(i >= 0 && i < dynamicArray.length) { 
        dynamicArray.splice(i,1); 
        visualizeArray(); 
    } 
}
function pushValue() { 
    const v = Number(document.getElementById('push-val').value); 
    if(!isNaN(v)) { 
        dynamicArray.push(v); 
        visualizeArray(); 
    } 
}
function popValue() { 
    if(dynamicArray.length>0) { 
        dynamicArray.pop(); 
        visualizeArray(); 
    } 
}
function unshiftValue() { 
    const v = Number(document.getElementById('unshift-val').value); 
    if(!isNaN(v)) { 
        dynamicArray.unshift(v); 
        visualizeArray(); 
    } 
}
function shiftValue() { 
    if(dynamicArray.length>0) { 
        dynamicArray.shift(); 
        visualizeArray(); 
    } 
}
function clearArray() { 
    dynamicArray = []; 
    visualizeArray(); 
}
function searchArraySearch() {
    const val = Number(document.getElementById('search-val').value);
    const idx = dynamicArray.indexOf(val);
    const canvas = document.getElementById('array-canvas');
    const ctx = canvas.getContext('2d');
    if(idx === -1) {
        ctx.fillStyle = 'rgba(255,0,0,0.5)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#f66';
        ctx.font = '36px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Not Found', canvas.width/2, canvas.height/2);
        setTimeout(visualizeArray, 1500);
    } else {
        const cellW = Math.min(100, canvas.width / dynamicArray.length * 0.85);
        const startX = (canvas.width - dynamicArray.length * cellW) / 2;
        const x = startX + idx * cellW;
        ctx.fillStyle = 'rgba(0,255,0,0.4)';
        ctx.fillRect(x, 50, cellW, canvas.height - 100);
        ctx.fillStyle = '#0f0';
        ctx.font = '32px Arial';
        ctx.fillText(`Found at index ${idx}!`, canvas.width/2, 100);
        setTimeout(visualizeArray, 2000);
    }
}

// ====================== 2. SORTING ======================
let sortArray = [], sortingSteps = 0;
async function startSorting() {
    sortArray = document.getElementById('sort-input').value.split(',').map(Number).filter(n=>!isNaN(n));
    sortingSteps = 0;
    document.getElementById('sort-info').textContent = 'Running...';
    drawSort(sortArray);
    const algo = document.getElementById('sort-algo').value;
    if(algo==='bubble') await bubbleSortVis();
    if(algo==='quick') await quickSortVis(0, sortArray.length-1);
    if(algo==='merge') await mergeSortVis(0, sortArray.length-1);
    document.getElementById('sort-info').textContent = `Done – ${sortingSteps} steps`;
}
function drawSort(arr) {
    const canvas = document.getElementById('sort-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const w = canvas.width / arr.length;
    arr.forEach((v,i)=>{
        const h = (v/Math.max(...arr,1))*380;
        ctx.fillStyle = `hsl(${v*4},80%,50%)`;
        ctx.fillRect(i*w+5, canvas.height-h-40, w-10, h);
        ctx.fillStyle = '#fff';
        ctx.fillText(v, i*w + w/2, canvas.height-15);
    });
}
async function bubbleSortVis() {
    for (let i = 0; i < sortArray.length; i++) {
        for (let j = 0; j < sortArray.length - i - 1; j++) {
            if (sortArray[j] > sortArray[j + 1]) {
                [sortArray[j], sortArray[j + 1]] = [sortArray[j + 1], sortArray[j]];
                sortingSteps++;
                drawSort(sortArray);
                await sleep(30);
            }
        }
    }
}
async function quickSortVis(low, high) {
    if (low < high) {
        let pi = await partition(low, high);
        await quickSortVis(low, pi - 1);
        await quickSortVis(pi + 1, high);
    }
}
async function partition(low, high) {
    let pivot = sortArray[high];
    let i = low - 1;
    for (let j = low; j < high; j++) {
        if (sortArray[j] < pivot) {
            i++;
            [sortArray[i], sortArray[j]] = [sortArray[j], sortArray[i]];
            drawSort(sortArray);
            sortingSteps++;
            await sleep(60);
        }
    }
    [sortArray[i + 1], sortArray[high]] = [sortArray[high], sortArray[i + 1]];
    drawSort(sortArray);
    sortingSteps++;
    await sleep(60);
    return i + 1;
}
async function mergeSortVis(l, r) {
    if (l >= r) return;
    let m = Math.floor((l + r) / 2);
    await mergeSortVis(l, m);
    await mergeSortVis(m + 1, r);
    await merge(l, m, r);
}
async function merge(l, m, r) {
    let left = sortArray.slice(l, m + 1);
    let right = sortArray.slice(m + 1, r + 1);
    let i = 0, j = 0, k = l;
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            sortArray[k++] = left[i++];
        } else {
            sortArray[k++] = right[j++];
        }
        drawSort(sortArray);
        sortingSteps++;
        await sleep(80);
    }
    while (i < left.length) { 
        sortArray[k++] = left[i++]; 
        drawSort(sortArray); 
        await sleep(40); 
    }
    while (j < right.length) { 
        sortArray[k++] = right[j++]; 
        drawSort(sortArray); 
        await sleep(40); 
    }
}
function resetSorting() { 
    sortArray = document.getElementById('sort-input').value.split(',').map(Number).filter(n=>!isNaN(n)); 
    drawSort(sortArray); 
    document.getElementById('sort-info').textContent = 'Steps: 0'; 
}

// ====================== 3. SEARCHING ======================
let searchArray = [], searchSteps = 0;
function loadSearchArray() {
    searchArray = document.getElementById('search-input').value.split(',').map(Number).filter(n=>!isNaN(n));
    searchSteps = 0;
    document.getElementById('search-steps').textContent = 'Steps: 0';
    document.getElementById('search-result').textContent = '';
    drawSearchArray([]);
}
function drawSearchArray(highlightIndices = [], foundIndex = -1, isSortedSearch = false) {
    const canvas = document.getElementById('search-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.font = '28px Arial';
    ctx.textAlign = 'center';
    if(searchArray.length===0) { 
        ctx.fillStyle='#888'; 
        ctx.fillText('Load array first', canvas.width/2, canvas.height/2); 
        return; 
    }
    const boxW=90, gap=15;
    const totalW = searchArray.length * (boxW + gap) - gap;
    const startX = (canvas.width - totalW) / 2;
    searchArray.forEach((v,i)=>{
        const x = startX + i*(boxW+gap);
        let fillStyle = foundIndex === i ? '#00ff88' : highlightIndices.includes(i) ? '#ffeb3b' : '#4488ff';
        if (isSortedSearch && !highlightIndices.includes(i)) fillStyle = '#333';
        ctx.fillStyle = fillStyle;
        ctx.fillRect(x,140,boxW,90);
        ctx.strokeStyle='#fff'; 
        ctx.lineWidth=3; 
        ctx.strokeRect(x,140,boxW,90);
        ctx.fillStyle='white'; 
        ctx.font='32px Arial'; 
        ctx.textBaseline='middle';
        ctx.fillText(v, x+boxW/2, 185);
        ctx.fillStyle='#aaa'; 
        ctx.font='16px Arial'; 
        ctx.fillText(i, x+boxW/2, 260);
    });
}
async function startSearch() {
    const target = Number(document.getElementById('target-val').value);
    const algo = document.getElementById('search-algo').value;
    searchSteps = 0;
    document.getElementById('search-result').textContent = 'Searching...';
    document.getElementById('search-steps').textContent = 'Steps: 0';
    
    const needsSort = algo !== 'linear';
    if(needsSort) {
        searchArray.sort((a,b)=>a-b);
        drawSearchArray([], -1, false);
        await sleep(600);
    }

    if(algo==='linear') await linearSearchVis(target);
    else if(algo==='binary') await binarySearchVis(target);
    else if(algo==='jump') await jumpSearchVis(target);
    else if(algo==='exponential') await exponentialSearchVis(target);
}
async function linearSearchVis(target) {
    let found = false;
    for (let i = 0; i < searchArray.length; i++) {
        searchSteps++;
        document.getElementById('search-steps').textContent = `Steps: ${searchSteps}`;
        drawSearchArray([i], -1, false);
        await sleep(800);
        if (searchArray[i] === target) {
            found = true;
            drawSearchArray([i], i, false);
            document.getElementById('search-result').innerHTML = `<span style="color:#0f0">Found ${target} at index ${i}!</span>`;
            return;
        }
    }
    drawSearchArray([], -1, false);
    document.getElementById('search-result').innerHTML = `<span style="color:#f66">Not found after ${searchSteps} steps</span>`;
}
async function binarySearchVisHelper(target, left, right) {
    let resultIndex = -1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        searchSteps++;
        document.getElementById('search-steps').textContent = `Steps: ${searchSteps}`;
        
        // Highlight range
        const range = [];
        for (let k = left; k <= right; k++) range.push(k);
        drawSearchArray(range, -1, true); 

        // Highlight mid
        const canvas = document.getElementById('search-canvas');
        const ctx = canvas.getContext('2d');
        const boxW = 90, gap = 15;
        const totalW = searchArray.length * (boxW + gap) - gap;
        const startX = (canvas.width - totalW) / 2;
        ctx.fillStyle = '#ffff00';
        ctx.font = '40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('▼', startX + mid * (boxW + gap) + boxW / 2, 100);
        
        await sleep(1400);

        if (searchArray[mid] === target) {
            resultIndex = mid;
            break; 
        } else if (searchArray[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    if (resultIndex !== -1) {
        const range = [];
        for (let k = left; k <= right; k++) range.push(k);
        drawSearchArray(range, resultIndex, true);
        return resultIndex;
    }
    return -1;
}
async function binarySearchVis(target) {
    const result = await binarySearchVisHelper(target, 0, searchArray.length - 1);
    if (result !== -1) {
        document.getElementById('search-result').innerHTML = `<span style="color:#0f0">Found ${target} at index ${result}!</span>`;
    } else {
        drawSearchArray([], -1, true);
        document.getElementById('search-result').innerHTML = `<span style="color:#f66">Not found after ${searchSteps} steps</span>`;
    }
}
async function jumpSearchVis(target) {
    let n = searchArray.length;
    if (n === 0) return -1;
    let step = Math.floor(Math.sqrt(n));
    let prev = 0;

    // Phase 1: Jumping
    while (searchArray[Math.min(step, n) - 1] < target) {
        searchSteps++;
        document.getElementById('search-steps').textContent = `Steps: ${searchSteps} (Jump Check)`;
        // Highlight the block being skipped
        let blockRange = [];
        for(let k = prev; k < Math.min(step, n); k++) blockRange.push(k);
        drawSearchArray(blockRange, -1, true); 
        await sleep(1000);

        prev = step;
        step += Math.floor(Math.sqrt(n));
        
        if (prev >= n) break; // Reached end of array
    }

    // Phase 2: Linear Search in block [prev, Math.min(step, n) - 1]
    let end = Math.min(step, n);
    document.getElementById('search-result').textContent = `Linear search in range [${prev}, ${end - 1}]`;
    
    // Set up the final block visualization (darken outside range)
    let finalRange = [];
    for(let k = prev; k < end; k++) finalRange.push(k);
    drawSearchArray(finalRange, -1, true); 
    await sleep(800);

    let resultIndex = -1;
    for (let i = prev; i < end; i++) {
        searchSteps++;
        document.getElementById('search-steps').textContent = `Steps: ${searchSteps} (Linear Check)`;
        
        // Highlight current check
        drawSearchArray([i], -1, true);
        await sleep(800);
        
        if (searchArray[i] === target) {
            resultIndex = i;
            break;
        }
    }

    if (resultIndex !== -1) {
        drawSearchArray([resultIndex], resultIndex, true);
        document.getElementById('search-result').innerHTML = `<span style="color:#0f0">Found ${target} at index ${resultIndex}!</span>`;
    } else {
        drawSearchArray([], -1, true);
        document.getElementById('search-result').innerHTML = `<span style="color:#f66">Not found after ${searchSteps} steps</span>`;
    }
    return resultIndex;
}
async function exponentialSearchVis(target) {
    let n = searchArray.length;
    if (n === 0) return -1;
    
    if (searchArray[0] === target) {
        searchSteps++;
        document.getElementById('search-steps').textContent = `Steps: ${searchSteps} (Initial Check)`;
        drawSearchArray([0], 0, false);
        document.getElementById('search-result').innerHTML = `<span style="color:#0f0">Found ${target} at index 0!</span>`;
        return 0;
    }

    let i = 1;
    // Phase 1: Find range
    while (i < n && searchArray[i] <= target) {
        searchSteps++;
        document.getElementById('search-steps').textContent = `Steps: ${searchSteps} (Exponential Jump Check)`;
        drawSearchArray([i], -1, false); // No need to darken outside yet
        await sleep(1000);
        i *= 2;
    }
    
    // Phase 2: Binary Search in range [i/2, Math.min(i, n - 1)]
    let left = Math.floor(i / 2);
    let right = Math.min(i, n - 1);
    
    document.getElementById('search-result').textContent = `Binary search in range [${left}, ${right}]`;

    // Highlight the final range before binary search starts
    let finalRange = [];
    for(let k = left; k <= right; k++) finalRange.push(k);
    drawSearchArray(finalRange, -1, true); // True to darken outside
    await sleep(800);

    const result = await binarySearchVisHelper(target, left, right);
    
    if (result === -1) {
        drawSearchArray([], -1, true);
        document.getElementById('search-result').innerHTML = `<span style="color:#f66">Not found after ${searchSteps} steps</span>`;
    } else {
        document.getElementById('search-result').innerHTML = `<span style="color:#0f0">Found ${target} at index ${result}!</span>`;
    }
}
function resetSearch(){ 
    loadSearchArray(); 
}

// ====================== 4. BINARY TREE (BT) ======================
let btArray = [];
let highlightBTNode = null;
function buildBT() {
    btArray = document.getElementById('bt-input').value.split(',').map(Number).filter(n=>!isNaN(n));
    drawTree(btArray, 'bt-canvas', highlightBTNode);
}
function drawTree(dataArray, canvasId, highlightNode, extraTextFn = null) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(dataArray.length===0) { 
        ctx.fillStyle='#888'; 
        ctx.font='28px Arial'; 
        ctx.textAlign='center';
        ctx.fillText('Enter values and click Build Tree', canvas.width/2, canvas.height/2);
        return;
    }
    
    const nodePositions = [];
    const maxNodes = dataArray.length;
    const maxLevel = Math.floor(Math.log2(maxNodes)) + 1;
    const levelGap = 80;
    const nodeR = 28;

    for (let i = 0; i < maxNodes; i++) {
        const level = Math.floor(Math.log2(i + 1));
        const y = 60 + level * levelGap;
        const nodesAtLevel = Math.pow(2, level);
        const positionInLevel = i - (nodesAtLevel - 1);
        
        // Calculate dynamic horizontal spacing based on max depth
        const totalWidthAtLevel = canvas.width / nodesAtLevel;
        const x = totalWidthAtLevel * positionInLevel + totalWidthAtLevel / 2;

        nodePositions.push({x, y, val: dataArray[i], index: i});

        // Draw line to parent
        if (i > 0) {
            const parentIndex = Math.floor((i - 1) / 2);
            const parentPos = nodePositions[parentIndex];
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(parentPos.x, parentPos.y + nodeR * Math.cos(Math.atan2(y - parentPos.y, x - parentPos.x)));
            ctx.lineTo(x, y - nodeR * Math.cos(Math.atan2(y - parentPos.y, x - parentPos.x)));
            ctx.stroke();
        }
    }
    
    // Draw nodes and values
    nodePositions.forEach(pos => {
        const nodeVal = pos.val;
        
        ctx.fillStyle = (pos.index === highlightNode) ? '#ff0' : '#667eea';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, nodeR, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(nodeVal, pos.x, pos.y);
        
        // Draw extra text (e.g., Balance Factor for AVL)
        if (extraTextFn) {
            extraTextFn(ctx, pos);
        }
    });
}
async function traverseBT(type) {
    const result = [];
    highlightBTNode = null;
    drawTree(btArray, 'bt-canvas', highlightBTBTNode);
    if(btArray.length === 0) return;
    
    if(type==='inorder') await traverseBTRec(0, result, (i) => btArray[i], (i) => 2*i + 1, (i) => 2*i + 2);
    else if(type==='preorder') await traverseBTRec(0, result, (i) => btArray[i], (i) => 2*i + 1, (i) => 2*i + 2);
    else if(type==='postorder') await traverseBTRec(0, result, (i) => btArray[i], (i) => 2*i + 1, (i) => 2*i + 2);
    
    document.getElementById('bt-traversal-output').textContent = `${type.toUpperCase()}: ${result.join(' → ')}`;
    highlightBTNode = null;
    drawTree(btArray, 'bt-canvas', highlightBTNode);
}
async function traverseBTRec(i, res, getVal, getLeft, getRight) {
    if (i >= btArray.length) return;
    
    const left = getLeft(i);
    const right = getRight(i);
    const val = getVal(i);

    if (document.getElementById('bt').classList.contains('active')) {
        if (left < btArray.length) await traverseBTRec(left, res, getVal, getLeft, getRight);
        
        res.push(val);
        highlightBTNode = i;
        drawTree(btArray, 'bt-canvas', highlightBTNode);
        await sleep(800);
        
        if (right < btArray.length) await traverseBTRec(right, res, getVal, getLeft, getRight);

    } else if (document.getElementById('bst').classList.contains('active')) {
        // This is complex because BST visualization uses nested objects not an array.
        // For simplicity, BST will use its own recursive traversal without array indices.
        // The BT implementation is solely for the array-based complete BT.
    }
}


// ====================== 5. BINARY SEARCH TREE (BST) ======================
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
let bstRoot = null;
let highlightBSTNode = null;
function buildBST() {
    const vals = document.getElementById('bst-input').value.split(',').map(Number).filter(n=>!isNaN(n));
    bstRoot = null;
    vals.forEach(v => bstRoot = insertBST(bstRoot, v));
    drawBST();
}
function insertBST(node, val) {
    if(!node) return new TreeNode(val);
    if(val < node.val) node.left = insertBST(node.left, val);
    else if(val > node.val) node.right = insertBST(node.right, val);
    return node;
}
function drawBST() {
    const canvas = document.getElementById('bst-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(!bstRoot) {
        ctx.fillStyle='#888'; 
        ctx.font='28px Arial'; 
        ctx.textAlign='center';
        ctx.fillText('Enter values and click Build BST', canvas.width/2, canvas.height/2);
        return;
    }
    assignBSTPositions(bstRoot, canvas.width/2, 60, canvas.width/4);
    drawBSTNode(ctx, bstRoot);
}
function assignBSTPositions(node, x, y, offset) {
    if(!node) return;
    node.x = x;
    node.y = y;
    if(node.left) assignBSTPositions(node.left, x - offset, y + 80, offset/2);
    if(node.right) assignBSTPositions(node.right, x + offset, y + 80, offset/2);
}
function drawBSTNode(ctx, node) {
    if(!node) return;
    const nodeR = 28;
    if(node.left) {
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.left.x, node.left.y);
        ctx.stroke();
        drawBSTNode(ctx, node.left);
    }
    if(node.right) {
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.right.x, node.right.y);
        ctx.stroke();
        drawBSTNode(ctx, node.right);
    }
    ctx.fillStyle = (node === highlightBSTNode) ? '#ff0' : '#667eea';
    ctx.beginPath();
    ctx.arc(node.x, node.y, nodeR, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = 'white';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(node.val, node.x, node.y);
}
async function traverseBST(type) {
    const result = [];
    highlightBSTNode = null;
    drawBST();
    if(!bstRoot) return;
    if(type==='inorder') await inorderBST(bstRoot, result);
    else if(type==='preorder') await preorderBST(bstRoot, result);
    else if(type==='postorder') await postorderBST(bstRoot, result);
    document.getElementById('bst-traversal-output').textContent = `${type.toUpperCase()}: ${result.join(' → ')}`;
    highlightBSTNode = null;
    drawBST();
}
async function inorderBST(node, res) {
    if(node) {
        await inorderBST(node.left, res);
        res.push(node.val);
        highlightBSTNode = node;
        drawBST();
        await sleep(800);
        highlightBSTNode = null;
        drawBST();
        await inorderBST(node.right, res);
    }
}
async function preorderBST(node, res) {
    if(node) {
        res.push(node.val);
        highlightBSTNode = node;
        drawBST();
        await sleep(800);
        highlightBSTNode = null;
        drawBST();
        await preorderBST(node.left, res);
        await preorderBST(node.right, res);
    }
}
async function postorderBST(node, res) {
    if(node) {
        await postorderBST(node.left, res);
        await postorderBST(node.right, res);
        res.push(node.val);
        highlightBSTNode = node;
        drawBST();
        await sleep(800);
        highlightBSTNode = null;
        drawBST();
    }
}

// ====================== 6. AVL TREE ======================
class AVLNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
        this.height = 1;
        this.x = 0; // for visualization
        this.y = 0;
    }
}
let avlRoot = null;
function getHeight(node) {
    return node ? node.height : 0;
}
function getBalance(node) {
    return node ? getHeight(node.left) - getHeight(node.right) : 0;
}
function updateHeight(node) {
    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));
}
function rotateRight(y) {
    const x = y.left;
    const T2 = x.right;
    x.right = y;
    y.left = T2;
    updateHeight(y);
    updateHeight(x);
    drawAVL(x, `Right Rotation on node ${y.val}`);
    return x;
}
function rotateLeft(x) {
    const y = x.right;
    const T2 = y.left;
    y.left = x;
    x.right = T2;
    updateHeight(x);
    updateHeight(y);
    drawAVL(y, `Left Rotation on node ${x.val}`);
    return y;
}
async function insertAVLValue(node, val) {
    if(!node) return new AVLNode(val);
    
    if(val < node.val) node.left = await insertAVLValue(node.left, val);
    else if(val > node.val) node.right = await insertAVLValue(node.right, val);
    else return node; // Duplicate values not allowed
    
    updateHeight(node);
    const balance = getBalance(node);
    
    // Check for rotations (Wait after insertion and before rotation)
    drawAVL(avlRoot, `Checking balance at ${node.val}. BF: ${balance}`);
    await sleep(600);
    
    // Left Left Case (Rotation Right)
    if(balance > 1 && val < node.left.val) {
        return rotateRight(node);
    }
    // Right Right Case (Rotation Left)
    if(balance < -1 && val > node.right.val) {
        return rotateLeft(node);
    }
    // Left Right Case (Rotation Left then Right)
    if(balance > 1 && val > node.left.val) {
        node.left = rotateLeft(node.left);
        drawAVL(avlRoot, `LR Case: Inner Left Rotation on ${node.left.val}`);
        await sleep(600);
        return rotateRight(node);
    }
    // Right Left Case (Rotation Right then Left)
    if(balance < -1 && val < node.right.val) {
        node.right = rotateRight(node.right);
        drawAVL(avlRoot, `RL Case: Inner Right Rotation on ${node.right.val}`);
        await sleep(600);
        return rotateLeft(node);
    }
    return node;
}
async function insertAVL() {
    const val = Number(document.getElementById('avl-insert-val').value);
    if(isNaN(val)) return;
    document.getElementById('avl-insert-val').value = '';
    avlRoot = await insertAVLValue(avlRoot, val);
    drawAVL(avlRoot, `Inserted ${val}. Final Tree.`);
}
async function buildAVL() {
    clearAVL();
    const vals = document.getElementById('avl-input').value.split(',').map(Number).filter(n=>!isNaN(n));
    for(const val of vals) {
        avlRoot = await insertAVLValue(avlRoot, val);
        drawAVL(avlRoot, `Inserted ${val}`);
        await sleep(1000);
    }
    drawAVL(avlRoot, `AVL Tree Built.`);
}
function clearAVL() {
    avlRoot = null;
    drawAVL(avlRoot, 'Tree cleared.');
}
function drawAVL(node, status = '') {
    const canvas = document.getElementById('avl-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    document.getElementById('avl-canvas').style.border = getBalance(node) > 1 || getBalance(node) < -1 ? '4px solid #f66' : 'none';

    if(!node) {
        ctx.fillStyle='#888'; 
        ctx.font='28px Arial'; 
        ctx.textAlign='center';
        ctx.fillText(status, canvas.width/2, canvas.height/2);
        return;
    }
    
    assignAVLPositions(node, canvas.width/2, 60, canvas.width/4);
    drawAVLNode(ctx, node);

    ctx.fillStyle = '#0f0';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Status: ${status}`, canvas.width/2, 20);
}
function assignAVLPositions(node, x, y, offset) {
    if(!node) return;
    node.x = x;
    node.y = y;
    if(node.left) assignAVLPositions(node.left, x - offset, y + 80, offset/2);
    if(node.right) assignAVLPositions(node.right, x + offset, y + 80, offset/2);
}
function drawAVLNode(ctx, node) {
    if(!node) return;
    const nodeR = 28;
    if(node.left) {
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.left.x, node.left.y);
        ctx.stroke();
        drawAVLNode(ctx, node.left);
    }
    if(node.right) {
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.right.x, node.right.y);
        ctx.stroke();
        drawAVLNode(ctx, node.right);
    }
    
    const balance = getBalance(node);
    let color = '#667eea'; // Balanced
    if (balance > 1 || balance < -1) color = '#f66'; // Imbalanced
    else if (balance !== 0) color = '#ffeb3b'; // Slightly Imbalanced

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(node.x, node.y, nodeR, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.fillStyle = (color === '#ffeb3b' || color === '#f66') ? '#000' : 'white';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(node.val, node.x, node.y - 10);
    
    // Draw Balance Factor (BF)
    ctx.font = '14px Arial';
    ctx.fillText(`BF:${balance}`, node.x, node.y + 10);
}

// ====================== 7. TRIE (PREFIX TREE) ======================
class TrieNode {
    constructor(char) {
        this.char = char;
        this.children = {};
        this.isEndOfWord = false;
        this.x = 0;
        this.y = 0;
    }
}
let trieRoot = new TrieNode(null);
let highlightTrieNode = null;
function insertTrie(word) {
    let node = trieRoot;
    for (const char of word) {
        if (!node.children[char]) {
            node.children[char] = new TrieNode(char);
        }
        node = node.children[char];
    }
    node.isEndOfWord = true;
}
function buildTrie() {
    const words = document.getElementById('trie-input').value.split(',').map(s => s.trim()).filter(s => s.length > 0);
    trieRoot = new TrieNode(null);
    words.forEach(insertTrie);
    drawTrie('Trie Built with ' + words.length + ' words.');
}
function insertTrieWord() {
    const word = document.getElementById('trie-insert-word').value.trim();
    if (word) {
        insertTrie(word);
        drawTrie(`Inserted word: ${word}`);
    }
}
function clearTrie() {
    trieRoot = new TrieNode(null);
    drawTrie('Trie is empty.');
}
async function searchTrieWord() {
    const word = document.getElementById('trie-search-word').value.trim();
    if (!word) return;

    let node = trieRoot;
    highlightTrieNode = trieRoot;
    drawTrie(`Searching for: ${word}`);
    await sleep(800);

    for (const char of word) {
        if (!node.children[char]) {
            drawTrie(`Prefix/Word not found: ${word}`);
            highlightTrieNode = null;
            return;
        }
        node = node.children[char];
        highlightTrieNode = node;
        drawTrie(`Current prefix: ${char}`);
        await sleep(800);
    }
    
    if(node.isEndOfWord) {
        document.getElementById('trie-status').innerHTML = `<span style="color:#0f0">Found word: ${word}</span>`;
    } else {
        document.getElementById('trie-status').innerHTML = `<span style="color:#ffeb3b">Prefix found, but not a full word: ${word}</span>`;
    }
    highlightTrieNode = null;
}
function drawTrie(status) {
    const canvas = document.getElementById('trie-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    document.getElementById('trie-status').textContent = status;

    if (Object.keys(trieRoot.children).length === 0) {
        ctx.fillStyle='#888'; 
        ctx.font='28px Arial'; 
        ctx.textAlign='center';
        ctx.fillText('Trie is empty', canvas.width/2, canvas.height/2);
        return;
    }

    const nodeR = 25;
    const hGap = 60;
    const vGap = 80;

    // 1. Assign positions using BFS for organized levels
    const queue = [{node: trieRoot, level: 0, parentX: canvas.width/2, parentY: 0}];
    trieRoot.x = canvas.width / 2;
    trieRoot.y = 50;
    
    let currentY = trieRoot.y;
    let levelPositions = {}; // Tracks nodes per level
    levelPositions[0] = [trieRoot];

    while(queue.length > 0) {
        const {node, level} = queue.shift();
        const children = Object.values(node.children);
        if(children.length === 0) continue;
        
        if (!levelPositions[level + 1]) levelPositions[level + 1] = [];
        
        // Calculate new level Y position if not set
        if (levelPositions[level+1].length === children.length) {
            currentY = node.y + vGap;
        }

        children.forEach((childNode) => {
            levelPositions[level + 1].push(childNode);
            queue.push({node: childNode, level: level + 1});
        });
    }

    // Recalculate horizontal positions based on total width and level node count
    Object.keys(levelPositions).forEach(level => {
        const nodes = levelPositions[level];
        const numNodes = nodes.length;
        const totalWidth = canvas.width;
        const spacing = totalWidth / (numNodes + 1);

        nodes.forEach((node, index) => {
            node.x = spacing * (index + 1);
            node.y = 50 + level * vGap;
        });
    });

    // 2. Draw connections and nodes (DFS for lines, then draw all nodes)
    function drawTrieConnections(node) {
        Object.values(node.children).forEach(child => {
            // Draw line
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(node.x, node.y);
            ctx.lineTo(child.x, child.y);
            ctx.stroke();

            // Draw character label
            const mx = (node.x + child.x)/2;
            const my = (node.y + child.y)/2;
            ctx.fillStyle = '#ffeb3b';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(child.char, mx, my - 5);

            drawTrieConnections(child);
        });
    }
    drawTrieConnections(trieRoot);

    // 3. Draw Nodes
    function drawTrieNodes(node) {
        if(node.char !== null) { // Skip the dummy root node visually
            let color = node === highlightTrieNode ? '#ff0' : (node.isEndOfWord ? '#0f0' : '#667eea');
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(node.x, node.y, nodeR, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = (color === '#ffeb3b' || color === '#ff0') ? '#000' : 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.char, node.x, node.y);
        }
        Object.values(node.children).forEach(drawTrieNodes);
    }
    drawTrieNodes(trieRoot);
}

// ====================== 8. HEAPS ======================
let heap = [];
let heapType = 'min';
function updateHeapType(type) {
    heapType = type;
    if (heap.length > 0) {
        buildHeap(heap.slice());
        drawHeap();
    }
}
function getCompare() {
    return heapType === 'min' ? (a, b) => a < b : (a, b) => a > b;
}
function heapInsert() {
    const val = Number(document.getElementById('heap-val').value);
    if (isNaN(val)) return;
    heap.push(val);
    heapifyUp(heap.length - 1);
    drawHeap();
}
function heapExtract() {
    if(heap.length === 0) return;
    heap[0] = heap[heap.length - 1];
    heap.pop();
    if(heap.length > 0) heapifyDown(0);
    drawHeap();
}
function heapifyUp(i) {
    const compare = getCompare();
    while(i > 0) {
        const parent = Math.floor((i-1)/2);
        if(!compare(heap[i], heap[parent])) break;
        [heap[i], heap[parent]] = [heap[parent], heap[i]];
        i = parent;
    }
}
function heapifyDown(i) {
    const compare = getCompare();
    while(true) {
        let smallest = i;
        const left = 2*i + 1;
        const right = 2*i + 2;
        if(left < heap.length && compare(heap[left], heap[smallest])) smallest = left;
        if(right < heap.length && compare(heap[right], heap[smallest])) smallest = right;
        if(smallest === i) break;
        [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
        i = smallest;
    }
}
function buildHeap(arr) {
    heap = arr;
    for (let i = Math.floor(heap.length / 2) - 1; i >= 0; i--) {
        heapifyDown(i);
    }
}
function loadHeap() {
    const vals = document.getElementById('heap-input').value.split(',').map(n => Number(n.trim())).filter(n => !isNaN(n));
    buildHeap(vals);
    drawHeap();
}
function randomHeap() {
    const size = Number(document.getElementById('heap-size').value);
    const arr = [];
    for (let i = 0; i < size; i++) {
        arr.push(Math.floor(Math.random() * 100) + 1);
    }
    buildHeap(arr);
    drawHeap();
}
function drawHeap() {
    const canvas = document.getElementById('heap-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(heap.length === 0) {
        ctx.fillStyle='#888'; 
        ctx.font='28px Arial'; 
        ctx.textAlign='center';
        ctx.fillText('Heap is empty - Insert elements', canvas.width/2, canvas.height/2);
        return;
    }
    const levels = Math.floor(Math.log2(heap.length)) + 1;
    const startY = 60;
    const levelGap = 90;
    for(let i = 0; i < heap.length; i++) {
        const level = Math.floor(Math.log2(i + 1));
        const posInLevel = i - (Math.pow(2, level) - 1);
        const nodesInLevel = Math.pow(2, level);
        const spacing = canvas.width / (nodesInLevel + 1);
        const x = spacing * (posInLevel + 1);
        const y = startY + level * levelGap;
        if(i > 0) {
            const parent = Math.floor((i-1)/2);
            const pLevel = Math.floor(Math.log2(parent + 1));
            const pPos = parent - (Math.pow(2, pLevel) - 1);
            const pNodes = Math.pow(2, pLevel);
            const pSpacing = canvas.width / (pNodes + 1);
            const px = pSpacing * (pPos + 1);
            const py = startY + pLevel * levelGap;
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(x, y);
            ctx.stroke();
        }
        ctx.fillStyle = '#764ba2';
        ctx.beginPath();
        ctx.arc(x, y, 26, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(heap[i], x, y);
    }
}

// ====================== 9. GRAPH BFS/DFS ======================
const graphNodes = [
    {id:0, x:200, y:150}, {id:1, x:400, y:100}, {id:2, x:600, y:150},
    {id:3, x:300, y:300}, {id:4, x:500, y:300}, {id:5, x:700, y:350}
];
const graphEdges = [[0,1],[0,3],[1,2],[1,4],[2,5],[3,4],[4,5]];
async function runBFS() {
    const canvas = document.getElementById('graph-canvas');
    const ctx = canvas.getContext('2d');
    const visited = new Set();
    const queue = [0];
    visited.add(0);
    while(queue.length > 0) {
        const node = queue.shift();
        drawGraph(ctx, visited, node);
        await sleep(800);
        for(let [a,b] of graphEdges) {
            const neighbor = a === node ? b : (b === node ? a : -1);
            if(neighbor !== -1 && !visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
    drawGraph(ctx, visited, -1);
}
async function runDFS() {
    const canvas = document.getElementById('graph-canvas');
    const ctx = canvas.getContext('2d');
    const visited = new Set();
    await dfsVisit(0, visited, ctx);
    drawGraph(ctx, visited, -1);
}
async function dfsVisit(node, visited, ctx) {
    visited.add(node);
    drawGraph(ctx, visited, node);
    await sleep(800);
    for(let [a,b] of graphEdges) {
        const neighbor = a === node ? b : (b === node ? a : -1);
        if(neighbor !== -1 && !visited.has(neighbor)) {
            await dfsVisit(neighbor, visited, ctx);
        }
    }
}
function drawGraph(ctx, visited, current) {
    ctx.clearRect(0,0,1100,500);
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 3;
    graphEdges.forEach(([a,b]) => {
        ctx.beginPath();
        ctx.moveTo(graphNodes[a].x, graphNodes[a].y);
        ctx.lineTo(graphNodes[b].x, graphNodes[b].y);
        ctx.stroke();
    });
    graphNodes.forEach(n => {
        ctx.fillStyle = current === n.id ? '#ff0' : (visited.has(n.id) ? '#0f0' : '#667eea');
        ctx.beginPath();
        ctx.arc(n.x, n.y, 30, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '22px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(n.id, n.x, n.y);
    });
}

// ====================== 10. BELLMAN-FORD ======================
async function runBellmanFord() {
    const canvas = document.getElementById('bellman-canvas');
    const ctx = canvas.getContext('2d');
    const nodes = [{id:0,x:150,y:250},{id:1,x:400,y:150},{id:2,x:650,y:250},{id:3,x:400,y:350}];
    const edges = [{from:0,to:1,weight:4},{from:0,to:3,weight:5},{from:1,to:2,weight:3},{from:3,to:1,weight:-6},{from:3,to:2,weight:2}];
    const dist = Array(nodes.length).fill(Infinity);
    dist[0] = 0;
    for(let i = 0; i < nodes.length - 1; i++) {
        for(let e of edges) {
            if(dist[e.from] !== Infinity && dist[e.from] + e.weight < dist[e.to]) {
                dist[e.to] = dist[e.from] + e.weight;
            }
        }
        drawBellman(ctx, nodes, edges, dist);
        await sleep(800);
    }
    document.getElementById('bellman-output').textContent = `Shortest distances from node 0: ${dist.map((d,i)=>`${i}:${d}`).join(', ')}`;
}
function drawBellman(ctx, nodes, edges, dist) {
    ctx.clearRect(0,0,1100,500);
    edges.forEach(e => {
        const from = nodes[e.from];
        const to = nodes[e.to];
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        const mx = (from.x + to.x)/2;
        const my = (from.y + to.y)/2;
        ctx.fillStyle = '#ff0';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(e.weight, mx, my-10);
    });
    nodes.forEach((n,i) => {
        ctx.fillStyle = i===0 ? '#0f0' : '#667eea';
        ctx.beginPath();
        ctx.arc(n.x, n.y, 35, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(n.id, n.x, n.y-8);
        ctx.font = '16px Arial';
        ctx.fillText(dist[i]===Infinity ? '∞' : dist[i], n.x, n.y+12);
    });
}

// ====================== 11. DIJKSTRA ======================
let dijkstraNodes = [];
let dijkstraEdges = [];
function loadDijkstraGraph() {
    const edgesInput = document.getElementById('graph-edges').value;
    const edgeList = edgesInput.split(',').map(s => s.trim());
    let maxNode = 0;
    dijkstraEdges = [];
    edgeList.forEach(e => {
        if (!e) return;
        const [fromTo, w] = e.split(':');
        const [from, to] = fromTo.split('-').map(Number);
        const weight = w ? Number(w) : 1;
        dijkstraEdges.push({from, to, weight});
        maxNode = Math.max(maxNode, from, to);
    });
    const numNodes = maxNode + 1;
    const isUndirected = document.getElementById('graph-dir').value === 'undirected';
    if (isUndirected) {
        for (let i = 0; i < dijkstraEdges.length; i++) {
            const e = dijkstraEdges[i];
            if (!dijkstraEdges.some(ee => ee.from === e.to && ee.to === e.from && ee.weight === e.weight)) {
                dijkstraEdges.push({from: e.to, to: e.from, weight: e.weight});
            }
        }
    }
    dijkstraNodes = [];
    for (let i = 0; i < numNodes; i++) {
        const angle = 2 * Math.PI * i / numNodes;
        const x = 550 + 300 * Math.cos(angle);
        const y = 250 + 200 * Math.sin(angle);
        dijkstraNodes.push({id: i, x, y});
    }
}
async function runDijkstra() {
    if (dijkstraNodes.length === 0) loadDijkstraGraph();
    const canvas = document.getElementById('dijkstra-canvas');
    const ctx = canvas.getContext('2d');
    const start = Number(document.getElementById('dijkstra-start').value);
    const end = Number(document.getElementById('dijkstra-end').value);
    const numNodes = dijkstraNodes.length;
    const dist = Array(numNodes).fill(Infinity);
    const prev = Array(numNodes).fill(-1);
    const visited = new Set();
    dist[start] = 0;
    while (visited.size < numNodes) {
        let u = -1;
        for (let i = 0; i < numNodes; i++) {
            if (!visited.has(i) && (u === -1 || dist[i] < dist[u])) u = i;
        }
        if (dist[u] === Infinity) break;
        visited.add(u);
        for (let e of dijkstraEdges) {
            if (e.from === u && dist[u] + e.weight < dist[e.to]) {
                dist[e.to] = dist[u] + e.weight;
                prev[e.to] = u;
            }
        }
        drawDijkstra(ctx, dijkstraNodes, dijkstraEdges, dist, visited, []);
        await sleep(1000);
    }
    let output = `Shortest distances from node ${start}: ${dist.map((d,i)=>`${i}:${d === Infinity ? '∞' : d}`).join(', ')}`;
    if (!isNaN(end) && end >= 0 && end < numNodes) {
        if (dist[end] === Infinity) {
            output += ' | No path to end';
        } else {
            let path = [];
            let curr = end;
            while (curr !== -1) {
                path.push(curr);
                curr = prev[curr];
            }
            path.reverse();
            output += ` | Path to ${end}: ${path.join(' -> ')} | Distance: ${dist[end]}`;
            drawDijkstra(ctx, dijkstraNodes, dijkstraEdges, dist, visited, path);
        }
    }
    document.getElementById('dijkstra-output').textContent = output;
}
function drawDijkstra(ctx, nodes, edges, dist, visited, path) {
    ctx.clearRect(0,0,1100,500);
    edges.forEach(e => {
        const from = nodes[e.from];
        const to = nodes[e.to];
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        const mx = (from.x + to.x)/2;
        const my = (from.y + to.y)/2;
        ctx.fillStyle = '#ff0';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(e.weight, mx, my-10);
    });
    nodes.forEach((n,i) => {
        ctx.fillStyle = path.includes(i) ? '#ff0' : (visited.has(i) ? '#0f0' : '#667eea');
        ctx.beginPath();
        ctx.arc(n.x, n.y, 35, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(n.id, n.x, n.y-8);
        ctx.font = '16px Arial';
        ctx.fillText(dist[i]===Infinity ? '∞' : dist[i], n.x, n.y+12);
    });
}

// ====================== 12. A* PATHFINDING ======================
const gridSize = 30;
const gridRows = 18;
const gridCols = 30;
let grid = [];
let startCell = {r:1,c:1};
let endCell = {r:16,c:28};
function initGrid() {
    grid = [];
    for(let r = 0; r < gridRows; r++) {
        grid[r] = [];
        for(let c = 0; c < gridCols; c++) {
            grid[r][c] = {wall:false, visited:false, path:false};
        }
    }
}
initGrid();
document.getElementById('astar-canvas').addEventListener('click', (e) => {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const c = Math.floor(x / gridSize);
    const r = Math.floor(y / gridSize);
    if(r >= 0 && r < gridRows && c >= 0 && c < gridCols) {
        if((r===startCell.r && c===startCell.c) || (r===endCell.r && c===endCell.c)) return;
        grid[r][c].wall = !grid[r][c].wall;
        drawAstarGrid();
    }
});
function clearGrid() {
    initGrid();
    drawAstarGrid();
}
function drawAstarGrid() {
    const canvas = document.getElementById('astar-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let r = 0; r < gridRows; r++) {
        for(let c = 0; c < gridCols; c++) {
            const cell = grid[r][c];
            if(r===startCell.r && c===startCell.c) ctx.fillStyle = '#0f0';
            else if(r===endCell.r && c===endCell.c) ctx.fillStyle = '#f00';
            else if(cell.path) ctx.fillStyle = '#ffeb3b';
            else if(cell.visited) ctx.fillStyle = '#00bcd4';
            else if(cell.wall) ctx.fillStyle = '#333';
            else ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(c*gridSize, r*gridSize, gridSize-1, gridSize-1);
        }
    }
}
function heuristic(r, c) {
    // Manhattan distance
    return Math.abs(r - endCell.r) + Math.abs(c - endCell.c);
}

// IMPROVED A* LOGIC
async function runAstar() {
    const walls = [];
    // Re-initialize grid state but preserve walls
    for(let r = 0; r < gridRows; r++) {
        for(let c = 0; c < gridCols; c++) {
            if(grid[r][c].wall) walls.push({r,c});
            grid[r][c].visited = false;
            grid[r][c].path = false;
        }
    }
    initGrid();
    walls.forEach(w => grid[w.r][w.c].wall = true);

    const speed = 101 - document.getElementById('astar-speed').value;
    
    // Data structures for A* state
    // openSet: Stores all nodes currently being considered, ordered by fScore
    let openSet = [{r:startCell.r, c:startCell.c}]; // Only store coordinates
    
    // cameFrom: For reconstructing the path
    let cameFrom = {}; // Key: "r,c", Value: {r:r, c:c} of parent
    
    // gScore: Cost from start to current node
    let gScore = {}; // Key: "r,c", Value: number (Infinity by default)
    gScore[`${startCell.r},${startCell.c}`] = 0;

    // fScore: Estimated total cost from start to goal through current node
    let fScore = {}; // Key: "r,c", Value: number (Infinity by default)
    fScore[`${startCell.r},${startCell.c}`] = heuristic(startCell.r, startCell.c);

    // Helper to get score from map or Infinity
    const getScore = (map, r, c) => map[`${r},${c}`] === undefined ? Infinity : map[`${r},${c}`];
    
    while(openSet.length > 0) {
        // Find the node with the lowest fScore in the openSet
        // Using sort here is inefficient (O(N log N)), but avoids a complex Min-Heap implementation in native JS
        openSet.sort((a,b) => getScore(fScore, a.r, a.c) - getScore(fScore, b.r, b.c));
        let current = openSet.shift(); // Get and remove the best node
        const currentKey = `${current.r},${current.c}`;

        if(current.r === endCell.r && current.c === endCell.c) {
            // Path found! Reconstruct and draw path
            let pathNode = current;
            while(pathNode.r !== startCell.r || pathNode.c !== startCell.c) {
                grid[pathNode.r][pathNode.c].path = true;
                pathNode = cameFrom[`${pathNode.r},${pathNode.c}`];
            }
            grid[startCell.r][startCell.c].path = true; // Mark start node as part of path
            drawAstarGrid();
            return;
        }

        // Mark as visited (Closed set is implicit, we only remove from openSet)
        grid[current.r][current.c].visited = true;
        drawAstarGrid();
        await sleep(speed);

        const neighbors = [{r:current.r-1,c:current.c},{r:current.r+1,c:current.c},{r:current.r,c:current.c-1},{r:current.r,c:current.c+1}];
        
        for(let n of neighbors) {
            if(n.r<0||n.r>=gridRows||n.c<0||n.c>=gridCols) continue; // Out of bounds
            if(grid[n.r][n.c].wall) continue; // Is a wall
            
            const neighborKey = `${n.r},${n.c}`;
            
            // tentative_gScore is the distance from start to neighbor through current
            const tentative_gScore = getScore(gScore, current.r, current.c) + 1;

            if (tentative_gScore < getScore(gScore, n.r, n.c)) {
                // This path to neighbor is better than any previous one. Record it!
                cameFrom[neighborKey] = current;
                gScore[neighborKey] = tentative_gScore;
                fScore[neighborKey] = tentative_gScore + heuristic(n.r, n.c);

                // Check if neighbor is already in openSet (O(N) check, better with a hash set/map)
                const inOpenSet = openSet.some(o => o.r === n.r && o.c === n.c);
                
                if (!inOpenSet) {
                    openSet.push(n);
                }
            }
        }
    }
    // No path found
    drawAstarGrid();
}
// END OF IMPROVED A* LOGIC


// ====================== 13. TOWERS OF HANOI ======================
let hanoiState = {pegs:[[],[],[]], moves:0};
async function solveHanoi() {
    const n = Number(document.getElementById('hanoi-disks').value);
    hanoiState = {pegs:[[],[],[]], moves:0};
    for(let i = n; i >= 1; i--) hanoiState.pegs[0].push(i);
    drawHanoi();
    await sleep(500);
    await hanoi(n, 0, 2, 1);
}
async function hanoi(n, from, to, aux) {
    if(n === 1) {
        const disk = hanoiState.pegs[from].pop();
        hanoiState.pegs[to].push(disk);
        hanoiState.moves++;
        drawHanoi();
        await sleep(600);
        return;
    }
    await hanoi(n-1, from, aux, to);
    const disk = hanoiState.pegs[from].pop();
    hanoiState.pegs[to].push(disk);
    hanoiState.moves++;
    drawHanoi();
    await sleep(600);
    await hanoi(n-1, aux, to, from);
}
function drawHanoi() {
    const canvas = document.getElementById('hanoi-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const pegX = [200, 550, 900];
    const baseY = 380;
    ctx.strokeStyle = '#00d4ff';
    ctx.lineWidth = 8;
    pegX.forEach(x => {
        ctx.beginPath();
        ctx.moveTo(x, baseY);
        ctx.lineTo(x, baseY-250);
        ctx.stroke();
        ctx.fillStyle = '#444';
        ctx.fillRect(x-80, baseY, 160, 15);
    });
    hanoiState.pegs.forEach((peg, i) => {
        peg.forEach((disk, j) => {
            const w = disk * 20 + 40;
            const h = 25;
            const x = pegX[i] - w/2;
            const y = baseY - (j+1)*h - 5;
            ctx.fillStyle = `hsl(${disk*30}, 80%, 60%)`;
            ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);
        });
    });
    ctx.fillStyle = '#0f0';
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Moves: ${hanoiState.moves}`, canvas.width/2, 50);
}

// ====================== INITIALIZE ======================
loadArrayFromInput();
loadSearchArray();
visualizeArray();
drawAstarGrid();
drawGraph(document.getElementById('graph-canvas').getContext('2d'), new Set(), -1);
document.getElementById('heap-type').value = heapType;
// Initialize all new sections
buildBT();
buildBST();
buildAVL();
buildTrie();
</script>
</body>
</html>